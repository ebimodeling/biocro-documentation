<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="BioCro">
<title>BioCro as a Dynamical System • BioCro</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="BioCro as a Dynamical System">
<meta property="og:description" content="BioCro">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">BioCro</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">3.0.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../about_pkgdown_documentation.html">About</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <h6 class="dropdown-header" data-toc-skip>GENERAL BIOCRO USAGE</h6>
    <div class="dropdown-divider"></div>
    <a class="dropdown-item" href="../articles/a_practical_guide_to_biocro.pdf">A Practical Guide to BioCro (PDF)</a>
    <a class="dropdown-item" href="../articles/a_practical_guide_to_biocro.R">    [R code]</a>
    <a class="dropdown-item" href="../articles/quantitative_model_comparison.pdf">Quantitative Comparison Between Two Photosynthesis Models (PDF)</a>
    <a class="dropdown-item" href="../articles/quantitative_model_comparison.R">    [R code]</a>
    <a class="dropdown-item" href="../articles/BioCro-II_Paper--Section-1.1-example.html">BioCro II Paper: Section 1.1 Example (HTML)</a>
    <a class="dropdown-item" href="../articles/dynamical_systems.pdf">BioCro as a Dynamical System</a>
    <a class="dropdown-item" href="../articles/an_introduction_to_biocro.pdf">An Introduction to BioCro for Those Who Want to Add Models (PDF)</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>CROP GROWTH MODELING TOPICS</h6>
    <div class="dropdown-divider"></div>
    <a class="dropdown-item" href="../articles/avoiding_pitfalls_fvcb.html">Avoiding Pitfalls When Using the FvCB Model (HTML)</a>
    <a class="dropdown-item" href="../articles/thick_layer_absorption.html">Light Absorption by a Thick Layer (HTML)</a>
    <a class="dropdown-item" href="../articles/ball_berry_model.html">Using the Ball-Berry Model (HTML)</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../../bookdown/index.html">Developer's Manual</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-c-library">C++ Library</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-c-library">
    <a class="dropdown-item" href="../../doxygen/doxygen_docs_complete/index.html">Complete Doxygen Documentation</a>
    <a class="dropdown-item" href="../../doxygen/doxygen_docs_framework/index.html">Framework Documentation</a>
    <a class="dropdown-item" href="../../doxygen/doxygen_docs_modules/index.html">BioCro Module Documentation</a>
    <a class="dropdown-item" href="../../doxygen/doxygen_docs_modules_public_members_only/index.html">BioCro Module Documentation (public members only)</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/ebimodeling/biocro/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>BioCro as a Dynamical System</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/ebimodeling/biocro/blob/HEAD/vignettes/dynamical_systems.Rmd" class="external-link"><code>vignettes/dynamical_systems.Rmd</code></a></small>
      <div class="d-none name"><code>dynamical_systems.Rmd</code></div>
    </div>

    
    
<!-- vector space -->
<!-- tuple or vector -->
<!-- reals -->
<!-- integers -->
<!-- natural numbers -->
<!-- identity function -->
<!-- BioCro module -->
<!-- BioCro system -->
<!-- Image operator -->
<div class="section level2">
<h2 id="dynamical-systems-real-and-mathematical">Dynamical systems, real and mathematical<a class="anchor" aria-label="anchor" href="#dynamical-systems-real-and-mathematical"></a>
</h2>
<p>In his book <em>Computation, Dynamics, and Cognition</em> <span class="citation">(<a href="#ref-Giunti1997-GIUCDS" role="doc-biblioref">Giunti 1997</a>)</span>, Giunti distinguishes
between real dynamical systems and mathematical dynamical systems:</p>
<blockquote>
<p>A real dynamical system is any real system that changes over time.
Therefore, since any real system can be thought to change in time (in
some respect), any real system is a real dynamical system. A
mathematical dynamical system, on the other hand, is an abstract
mathematical structure that can be used to describe the change of a real
system as an evolution through a series of states.</p>
</blockquote>
<p>It should be emphasized that when we create a mathematical system to
model a real one, we are doing more than just quantifying attributes of
the real system; we are also selecting which attributes to incorporate
into our model and which ones to ignore. For there are an endless
variety of attributes which could describe the state of a real system,
and we can’t even begin to hope to be able to model all of them.</p>
<p>As stated in the Giunti quote, a mathematical dynamical system will
describe the change of a real system as an evolution through a series of
states. (For now, we will interpret “series of states” loosely, so as to
encompass models that describe this change as a continuous evolution of
the system state as well as those that describe change in terms of a
discrete sequence of states.) The real usefulness of such a mathematical
structure, however, comes when it goes beyond merely describing the
series of states: the real power comes when we are able to derive a
complete picture of the evolution of a system from only partial
knowledge of the system, knowledge possibly consisting of, for example,
the state of the system at some particular time, the environment in
which the system is operating, and some general knowledge of the
processes that determine how the system behaves.</p>
<div class="section level3">
<h3 id="an-example-the-falling-body-problem">An example: the falling-body problem <a class="anchor" aria-label="anchor" href="#an-example-the-falling-body-problem"></a>
</h3>
<p>A classic example from physics is the falling-body problem: Given a
stationary, compact, relatively dense object dropped from a height <span class="math inline">\(h_0\)</span> above the surface of the earth, what
will be its height after a duration of time <span class="math inline">\(t\)</span>? The partial knowledge we have of this
system consists of:</p>
<ol style="list-style-type: decimal">
<li><p>the initial height <span class="math inline">\(h_0\)</span> of
the object</p></li>
<li><p>the initial velocity <span class="math inline">\(v_0\)</span> of
the object (In this system, we’ll assume <span class="math inline">\(v_0
= 0\)</span>: the object is stationary to begin with.)</p></li>
<li><p>the magnitude, which we’ll call <span class="math inline">\(g\)</span>, of the downward acceleration of the
body caused by the earth’s gravitational field</p></li>
</ol>
<p>If we use the function <span class="math inline">\(h(t)\)</span> to
embody the complete description of the evolution of the system—that is
<span class="math inline">\(h(t)\)</span> tells the height of the body
after an elapsed time of <span class="math inline">\(t\)</span>—then our
initial knowledge of the system consists of a system of equations
putting certain constraints on the function <span class="math inline">\(h\)</span>: <!-- (no par break) --> <span class="math display">\[\begin{align}
  h(0)         &amp; = h_0      \notag \\
  h'(t)\big|_{t=0} &amp; = 0    \label{eq:ode-system} \\
  h''(t)       &amp; = -g       \notag
\end{align}\]</span> <!-- (no par break) --> (The third constraint would
more accurately be written as <!-- (no par break) --> <span class="math display">\[\begin{equation*}
  h''(t) = -g \quad\text{\emph{if} h(t) &gt; 0},
\end{equation*}\]</span> <!-- (no par break) --> but for simplicity, we
will only consider the system over durations sufficiently small that the
object has not yet hit the ground.)</p>
<p>In the field of differential equations, this is known as an
initial-value problem, and it can be shown that its unique solution is
given by <!-- (no par break) --> <span class="math display">\[\begin{equation*}
  h(t) = h_0 - 1/2\,gt^2.
\end{equation*}\]</span> <!-- (no par break) --> Thus, from knowing only
the initial height and velocity of the object and some basic principles
of physics, we are able to obtain a complete description of the
evolution of this “falling object” system over time.</p>
</div>
<div class="section level3">
<h3 id="some-comments-on-mathematical-abstraction">Some comments on mathematical abstraction<a class="anchor" aria-label="anchor" href="#some-comments-on-mathematical-abstraction"></a>
</h3>
<p>As we mentioned, any mathematical dynamical system that purports to
model a real system will necessarily leave much out. In choosing what
attributes to retain in our abstract model, there are two main
considerations: First, which attributes of the system are of most
interest to us? For a model of plant growth, this might include, for
example, the rate of growth (mass accumulation) of a plant; the nutrient
or energy content of the growing plant; the effects of a group of plants
on the surrounding environment, including the temperature and <span class="math inline">\(\text{CO}_\text{2}\)</span> content of the
surrounding air, or the rate of erosion of the soil substrate; or the
resilience of the plant in drought conditions.</p>
<p>Second, there are attributes that may not be of particular intrinsic
interest but may help in predicting the behavior of those attributes
that <em>are</em> of interest.</p>
<p>Returning to the falling-object model for a moment, if the primary
object of interest in the <em>real</em> falling object system is the
height of the object at any given time, then there are certain things
about the system we may safely ignore: the color of the object or the
time of day, for example, will probably have no bearing on the
trajectory of object’s motion. On the other hand, knowing the velocity
of the object at any given time is crucial to predicting its height over
time, even if we may have no intrinsic interest in knowing the
velocity.</p>
<p>Other attributes that <em>could</em> have some bearing on the motion
of the object are (to give a very few examples)</p>
<ul>
<li>the size and shape of the object</li>
<li>the mass of the object</li>
<li>the air currents in the vicinity of the object’s path</li>
</ul>
<p><!-- Pandoc seemingly doesn't allow lists in the middle of a
               paragraph, so we fake it.  --> But as the Italian
experimenters of the 16th century demonstrated, the weight of a compact
and relatively dense object has little effect upon the rate at which it
falls. It turns out, as a matter of fact, that the predictive accuracy
of our model, in which we look only at the height and downward velocity
of the object (and the ambient gravitational field) and ignore all other
attributes of the system, is rather good in the case of compact,
relatively-dense objects.</p>
<p>Of course, if we consider a non-compact object with relatively low
density, such as a feather, this model may not do a good job of
predicting its path as it falls through the air. We may find that in
order to accurately model the free-fall of a feather, we <em>do</em>
need to include additional attributes in our system, such as those that
help us take into account the effects of air resistance. This process,
whereby a model is compared against observations and then updated when
it fails to predict the behavior of the real system it is meant to
represent, is a key part of the scientific process and has been
responsible for a great deal of progress and understanding. Thus, it is
never a problem when the process of abstraction has left out too many
details; instead this is an opportunity to learn more about the real
world and the model. A central goal for BioCro is to make it relatively
easy to add new components to an existing model, allowing this type of
model development to occur more rapidly.</p>
</div>
</div>
<div class="section level2">
<h2 id="continuous-time-versus-discrete-time">Continuous time versus discrete time <a class="anchor" aria-label="anchor" href="#continuous-time-versus-discrete-time"></a>
</h2>
<p>In the system just shown—a mathematical model of a real-world
dynamical system—the differential equation constraining the solution has
an exact solution as an easily-computable function. Most often, however,
we will not be able to find an exact solution, and so we will have to
settle for a numerical solution.</p>
<p>We will show how to model the falling-object system numerically, even
though this is one case where we don’t really need to resort to such
methods.</p>
<div class="section level3">
<h3 id="eulers-method">Euler’s method<a class="anchor" aria-label="anchor" href="#eulers-method"></a>
</h3>
<p>Euler’s method, the most basic of methods for numerical integration
of ordinary differential equations, may be applied to any system in
which the current rate of change of each of the state variables may be
expressed as a function of the current state. Here, we use <em>state
variable</em> to mean any quantifiable attribute of a system whose value
we would like to predict; the <em>state</em> of a system is then the
conglomeration of the values of all of these variables at any particular
time. Euler’s method makes the assumption that, given a known state of a
system at some particular time, the state of the system at some very
small interval of time later can be closely approximated by assuming
that the rate of change of each state variable remains essentially
constant over that very small time interval.</p>
<p>If <span class="math inline">\(\mathbf{s}\)</span> denotes the state,
with <span class="math inline">\(\mathbf{s}(t)\)</span> denoting its
value at time <span class="math inline">\(t\)</span>, and if <span class="math inline">\(x\)</span> is one of the state variables, with
<span class="math inline">\(x(t)\)</span> denoting its value at time
<span class="math inline">\(t\)</span>, then, given
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
  dx/dt = f(\mathbf{s}),
\end{equation*}\]</span> <!-- (no par break) --> we assume that for any
sufficiently small interval of time <span class="math inline">\(\Delta
t\)</span>, <!-- (no par break) --> <span class="math display">\[\begin{equation*}
  x(t+\Delta t) \approx x(t) + f(\mathbf{s}(t))\cdot\Delta t.
\end{equation*}\]</span></p>
</div>
<div class="section level3">
<h3 id="applying-eulers-method-to-the-falling-body-problem">Applying Euler’s method to the falling-body problem<a class="anchor" aria-label="anchor" href="#applying-eulers-method-to-the-falling-body-problem"></a>
</h3>
<p>In the system of equations <span class="math inline">\(\eqref{eq:ode-system}\)</span>, <span class="math inline">\(h\)</span> is the only system variable. But there
is no valid equation that gives <span class="math inline">\(dh/dt\)</span> as a function of the state when the
state is represented by <span class="math inline">\(h\)</span>
alone.</p>
<p>To solve this problem, we will also consider the velocity to be a
part of the state. If we think of the state of a system as a record of
the system at a particular time that can be used to predict a future
state, it makes sense that the velocity should be included. For example,
if we know the position of an object but we do not even know if it is
moving upwards or downwards, we will not be able to predict its position
in the near future.</p>
<p>And so now, the states of our system have two components, height and
velocity, and we can think of each state <span class="math inline">\(\mathbf{s}\)</span> as a point in a 2-dimensional
Euclidean space, that is, <!-- (no par break) --> <span class="math display">\[\begin{equation*}
  \mathbf{s} = (s_0, s_1).
\end{equation*}\]</span> <!-- (no par break) --> We will identify the
height <span class="math inline">\(h\)</span> with the first component
<span class="math inline">\(s_0\)</span> and the velocity <span class="math inline">\(v\)</span> with the second component <span class="math inline">\(s_1\)</span>. We will consider <span class="math inline">\(v\)</span> to be the velocity in the upward
direction so that when the object is falling, <span class="math inline">\(v &lt; 0\)</span>. We write <span class="math inline">\(v(t)\)</span> to denote <span class="math inline">\(v\)</span> as a function of time.</p>
<p>Since <span class="math inline">\(v = dh/dt\)</span>, we can rewrite
the system <span class="math inline">\(\eqref{eq:ode-system}\)</span> as
<!-- (no par break) --> <span class="math display">\[\begin{align}
  dh/dt &amp; = v   \label{eq:deriv_h} \\
  dv/dt &amp; = -g  \label{eq:deriv_v} \\
  h(0)  &amp; = h_0 \notag \\
  v(0)  &amp; = 0   \notag
\end{align}\]</span> <!-- (no par break) --> Now we can use equations
<span class="math inline">\(\eqref{eq:deriv_h}\)</span> and <span class="math inline">\(\eqref{eq:deriv_v}\)</span> to obtain the Euler
method formulas for estimating the state at time <span class="math inline">\(t + \Delta t\)</span> from the state at time <span class="math inline">\(t\)</span>: <!-- (no par break) --> <span class="math display">\[\begin{align*}
  h(t + \Delta t) &amp; = h(t) + v(t)\cdot\Delta t \\
  v(t + \Delta t) &amp; = v(t) - g\cdot\Delta t
\end{align*}\]</span></p>
<p>Let us consider this system over some sequence of times <span class="math inline">\(0 = t_0, t_1, t_2, t_3, \dots\)</span> where for
each <span class="math inline">\(i\)</span>, <span class="math inline">\(t_{i + 1} = t_i + \Delta t\)</span>. Further, let
write <span class="math inline">\(\delta\)</span> for <span class="math inline">\(\Delta t\)</span>, and let <span class="math inline">\(\pi_0\)</span> and <span class="math inline">\(\pi_1\)</span> denote the projection of the state
<span class="math inline">\(\mathbf{s}\)</span> onto its components,
that is <!-- (no par break) --> <span class="math display">\[\begin{align}
  \pi_0(\mathbf{s}) &amp; = s_0 \\
  \intertext{and}
  \pi_1(\mathbf{s}) &amp;= s_1.
\end{align}\]</span> <!-- (no par break) --> Now we can write a
recursive definition for the state <span class="math inline">\(\mathbf{s}\)</span> as a function of <span class="math inline">\(t\)</span>: <!-- (no par break) --> <span class="math display">\[\begin{align}
  \mathbf{s}(t_0) &amp;= (h_0, 0) \notag \\
  \mathbf{s}(t_{i + 1}) &amp;= (\pi_0(\mathbf{s}(t_i)) +  \delta \cdot
\pi_1(\mathbf{s}(t_i)),
                         \pi_1(\mathbf{s}(t_i)) - \delta\cdot
g)\quad\text{for i$\geq$0}.
                         \label{eq:falling_body_recursion}
\end{align}\]</span> <!-- (no par break) --> Note that we could also
express this definition using our original variable names and without
using the projection operators: <!-- (no par break) --> <span class="math display">\[\begin{align*}
  \mathbf{s}(t_0) &amp;= (h_0, 0) \notag \\
  \mathbf{s}(t_{i + 1}) &amp;= (h(t_i) +  \Delta t \cdot v(t_i),
                         v(t_i) - \Delta t \cdot g)\quad\text{for
i$\geq$0}.
\end{align*}\]</span> <!-- (no par break) --> Thus, Equation <span class="math inline">\(\eqref{eq:falling_body_recursion}\)</span> may
seem like a complicated way to write a relatively simple rule relating
height, velocity, and acceleration. This notation will, however, become
useful later when we consider systems less in terms a named state
variables and instead think of these variables as coordinates of a point
in a Euclidean space comprising the system state space.</p>
</div>
<div class="section level3">
<h3 id="note-about-abstraction-and-recursive-systems">Note about abstraction and recursive systems<a class="anchor" aria-label="anchor" href="#note-about-abstraction-and-recursive-systems"></a>
</h3>
<p>We have just performed the following abstraction to arrive at a
recursively-defined function giving the state of a system as a function
of time: <!-- (no par break) --> <span class="math display">\[\begin{equation*}
  \begin{array}{c}
    \text{\sc real system} \\
    \downarrow \\
    \text{\sc continuous mathematical system (ODE system)} \\
    \downarrow \\
    \text{\sc discrete-time approximation (recursive equations)}
  \end{array}
\end{equation*}\]</span> <!-- (no par break) --> One important point
here is that the process of developing a recursive equation (or a
discrete-time approximation) depends on the algorithm chosen for solving
the continuous ODE system. For example, if we had chosen to use the
fourth-order Runge-Kutta method rather than Euler’s method to solve the
falling-body problem, we would have arrived at a recursive definition
different from Equation <span class="math inline">\(\eqref{eq:falling_body_recursion}\)</span>.
Nevertheless, it would represent the same continuous system, and should
(usually) produce a similar sequence of states.</p>
<p>It should also be pointed out that not all discrete-time abstract
dynamical systems arise as abstractions of real systems or even as
abstractions of continuous-time abstract systems.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;There are also cases where it is convenient to abstract
directly from a (presumably continuous) real-world system to a discrete
mathematical model without passing through the intermediary stage of
making an ODE-based model. We shall say more about this in Section &lt;span class="math inline"&gt;\(\ref{sec:biocro_model}\)&lt;/span&gt;.&lt;/p&gt;'><sup>1</sup></a></p>
<p>Consider, for example, a system with a state space <span class="math inline">\(\mathbf{Z}^2\)</span> consisting of all ordered
pairs <span class="math inline">\(\mathbf{v} = (v_0, v_1)\)</span> of
integers, and a transition rule <!-- (no par break) --> <span class="math display">\[\begin{equation*}
  \mathbf{v}(t_{i + 1}) = (\pi_1(\mathbf{v}(t_i)),
\pi_0(\mathbf{v}(t_i)) + \pi_1(\mathbf{v}(t_i))).
\end{equation*}\]</span> <!-- (no par break) --> Given an initial state
<span class="math inline">\(\mathbf{v}(t_0)\)</span>, we now have a way
to compute the state <span class="math inline">\(\mathbf{v}(t_i)\)</span> at any time <span class="math inline">\(t_i\)</span>. This abstract dynamical system may
not have any relationship to any real dynamical system we might imagine,
but it is an abstract dynamical system nevertheless.</p>
<p>(If we take <span class="math inline">\(\mathbf{v}(t_0) = (0,
1)\)</span>, by the way, the function <span class="math inline">\(F:
\mathbf{N}\to\mathbf{Z}\)</span> defined by the rule
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
  i \mapsto \pi_0(\mathbf{v}(t_i))
\end{equation*}\]</span> <!-- (no par break) --> defines the Fibonacci
sequence <span class="math inline">\(0, 1, 1, 2, 3, 5, 8, 13,
\dots\,\)</span>.)</p>
<p>Another class of discrete-time abstract dynamical systems are the
cellular automata. These, however, may have some value in modeling
real-world phenomena. (See, for example, <span class="citation">Deutsch
(<a href="#ref-alma99496872912205899" role="doc-biblioref">2005</a>)</span>.)</p>
</div>
</div>
<div class="section level2">
<h2 id="an-overview-of-some-abstract-dynamical-system-formulations">An overview of some abstract dynamical system formulations <a class="anchor" aria-label="anchor" href="#an-overview-of-some-abstract-dynamical-system-formulations"></a>
</h2>
<p>This section will provide a short survey of some formulations of
abstract dynamical systems; in later sections, we will discuss how these
formulations relate to the types of systems represented in BioCro.</p>
<p>(For a insightful and thoroughly abstract mathematical study of the
theory of general systems, dynamical and otherwise, see <span class="citation">Mesarović and Takahara (<a href="#ref-alma99267312205899" role="doc-biblioref">1975</a>)</span>.)</p>
<div class="section level3">
<h3 id="some-notational-preliminaries">Some notational preliminaries <a class="anchor" aria-label="anchor" href="#some-notational-preliminaries"></a>
</h3>
<p>As is common, we will take <span class="math inline">\(f: C \to
B\)</span> to mean “<span class="math inline">\(f\)</span> is a function
with domain <span class="math inline">\(C\)</span> taking values in the
set <span class="math inline">\(B\)</span>.” Usually, this means <span class="math inline">\(f(c)\)</span> is defined for every <span class="math inline">\(c\in C\)</span>, but in what follows, we won’t
always be entirely strict about this. Following <span class="citation">Vaught (<a href="#ref-vaught" role="doc-biblioref">1985</a>)</span>, we write <span class="math inline">\(B^C\)</span> to denote the set of all such
functions <span class="math inline">\(f\)</span>.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;This notation is meant to be suggestive of
exponentiation. In fact, if &lt;span class="math inline"&gt;\(B\)&lt;/span&gt; and
&lt;span class="math inline"&gt;\(C\)&lt;/span&gt; are both finite sets having
cardinalities &lt;span class="math inline"&gt;\(\|B\|\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\|C\|\)&lt;/span&gt; respecively, then the cardinality
&lt;span class="math inline"&gt;\(\|B^C\|\)&lt;/span&gt; of &lt;span class="math inline"&gt;\(B^C\)&lt;/span&gt; will be &lt;span class="math inline"&gt;\(\|B\|^{\|C\|}\)&lt;/span&gt;. For example, if &lt;span class="math inline"&gt;\(C=\{\text{apple}, \text{pepper}\}\)&lt;/span&gt; and
&lt;span class="math inline"&gt;\(B=\{\text{red}, \text{yellow},
\text{green}\}\)&lt;/span&gt;, then there are &lt;span class="math inline"&gt;\(\|B\|^{\|C\|} = 3^2 = 9\)&lt;/span&gt; possible mappings
of the two food items to the three colors.&lt;/p&gt;'><sup>2</sup></a> We use <span class="math inline">\(\mathbf{R}\)</span>, <span class="math inline">\(\mathbf{Z}\)</span>, and <span class="math inline">\(\mathbf{N}\)</span> to denote the real numbers,
the integers, and the natural numbers (the finite ordinals, including
zero), respectively. <span class="math inline">\(\mathbf{Z}^+\)</span>
denotes the <em>positive</em> integers.</p>
<p>Following von Neumann, it will sometimes be convenient to identify
each natural number <span class="math inline">\(n\)</span> with the set
of all of its predecessors. For example, <span class="math inline">\(5 =
\{0, 1, 2, 3, 4\}\)</span>. This is particularly useful when speaking of
Euclidian spaces. For example, <span class="math inline">\(\mathbf{R}^3\)</span>, Euclidean 3-space, is
usually thought of as the set of all 3-coordinate vectors <span class="math inline">\((x, y, z)\)</span>. But we can equally well
consider it to be the set of all mappings <span class="math inline">\(v:
\{0,1,2\}\to \mathbf{R}\)</span>, which, using the set-of-functions
notation given above, can be denoted <span class="math inline">\(\mathbf{R}^{\{0,1,2\}}\)</span>. (Or, using von
Neumann’s notion of ordinals, this, too, is denoted <span class="math inline">\(\mathbf{R}^3\)</span>, since <span class="math inline">\(3=\{0,1,2\}\)</span>!) Thus, we can identify a
3-tuple <span class="math inline">\((x,y,z)\)</span> with a mapping
<span class="math inline">\(v: \{0,1,2\}\to \mathbf{R}\)</span>, where
<span class="math inline">\(v(0) = x\)</span>, <span class="math inline">\(v(1) = y\)</span>, and <span class="math inline">\(v(2) = z\)</span>. We often write <span class="math inline">\(v_i\)</span> in place of <span class="math inline">\(v(i)\)</span> and identify a mapping <span class="math inline">\(v: \{0, 1, 2, \dots, n-1\}\to \mathbf{R}\)</span>
with an n-tuple or n-coordinate vector <span class="math inline">\(\mathbf{v}=(v_0, v_1, v_2, \dots,
v_{n-1})\)</span>.</p>
<p>Often, however, there will be some level of indirection involved in
our use of the notation <span class="math inline">\(v_i\)</span> for a
coordinate of <span class="math inline">\(\mathbf{v}\)</span>. For
example, if <span class="math inline">\(\mathbf{U}\)</span> is a proper
subspace of <span class="math inline">\(\mathbf{R}^n\)</span> such that
<span class="math inline">\(\mathbf{U} = \mathbf{R}^U\)</span> for some
proper subset <span class="math inline">\(U\)</span> of <span class="math inline">\(n = \{0,1,\dots,n-1\}\)</span>, then we may regard
<span class="math inline">\(u_i\)</span> as the value taken by the <span class="math inline">\(i\)</span>th member of <span class="math inline">\(U\)</span> in some arbitrary but fixed ordering of
the members of <span class="math inline">\(U\)</span>. We even allow the
case where the function domain <span class="math inline">\(U\)</span>
isn’t a set of integers at all but just some finite collection of
objects. In this case, in the context of considering vectors
(<em>qua</em> mappings) <span class="math inline">\(\mathbf{v}\in
\mathbf{R}^U\)</span>, <span class="math inline">\(v_i\)</span> may
denote alternately the <span class="math inline">\(i^\text{th}\)</span>
member of <span class="math inline">\(U\)</span> in some fixed
enumeration; the name of a variable associated with that member; or the
value of the <span class="math inline">\(i^\text{th}\)</span> coordinate
of some particular vector <span class="math inline">\(\mathbf{v}\)</span>. In the later case, <span class="math inline">\(v_i\)</span> doesn’t abbreviate <span class="math inline">\(v(i)\)</span> for some function <span class="math inline">\(v\in \mathbf{R}^U\)</span>. Rather, it stands for
<span class="math inline">\(v(u_i)\)</span>, where <span class="math inline">\(u_i\)</span> denotes “the <span class="math inline">\(i^\text{th}\)</span> member of <span class="math inline">\(U\)</span>.”</p>
<p>Any function <span class="math inline">\(f: C \to B\)</span> may be
identified with the set <span class="math inline">\(\{(c, f(c))\,:\,c\in
C\}\)</span>. Thus, the target set <span class="math inline">\(B\)</span> is not an intrinsic part of the
function <span class="math inline">\(f\)</span>. But, defining the
<em>image set</em> of <span class="math inline">\(f\)</span> as
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \operatorname{Im}f = \{b\,: \text{there exists $c\in C$ such that}
(c, b) \in f\},
\end{equation*}\]</span> <!-- (no par break) --> we can at least say
<span class="math inline">\(\operatorname{Im}f\subseteq B\)</span>.</p>
<p>Given any function <span class="math inline">\(f: C \to B\)</span>
and any subset <span class="math inline">\(C_0\subseteq C\)</span>, we
can define <span class="math inline">\(f|C_0\)</span>, the
<em>restriction of <span class="math inline">\(f\)</span> to <span class="math inline">\(C_0\)</span></em>, as <!-- (no par break) -->
<span class="math display">\[\begin{equation*}
    f|C_0 := \{(c, b) \in f\,:\,c\in C_0\}
\end{equation*}\]</span> <!-- (no par break) --> We shall be
particularly interested in restrictions of functions specifying points
in Euclidean space. Suppose <span class="math inline">\(\mathbf{x}\in
\mathbf{R}^n\)</span>, and let <span class="math inline">\(W\)</span> be
an arbitrary subset of <span class="math inline">\(n=\{0,1,2,\dots,n-1\}\)</span>. Then <span class="math inline">\(\mathbf{x}|W\)</span> will be a member of <span class="math inline">\(\mathbf{R}^W\)</span>, the set of functions that
assign a real number to each member of <span class="math inline">\(W\)</span>. We regard <span class="math inline">\(\mathbf{R}^W\)</span> as a subspace of <span class="math inline">\(\mathbf{R}^n\)</span>. Moreover, if <span class="math inline">\(W\)</span> has <span class="math inline">\(k\)</span> members, <span class="math inline">\(\mathbf{R}^W\)</span> will be isomorphic to, but
not necessarily equal to, the Euclidean space <span class="math inline">\(\mathbf{R}^k\)</span>. (<span class="math inline">\(\mathbf{R}^W\)</span> and <span class="math inline">\(\mathbf{R}^k\)</span> are equal iff <span class="math inline">\(W=k\)</span> (that is, iff <span class="math inline">\(W = \{0, 1, \dots, k-1\})\)</span>.) We define the
projection mapping <span class="math inline">\(\pi^{n\to W}:
\mathbf{R}^n\to \mathbf{R}^W\)</span> by the rule
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
    v \mapsto v|W.
\end{equation*}\]</span></p>
<p>More generally, given any two finite sets <span class="math inline">\(W\subseteq U\)</span> (not necessarily sets of
integers), we may define a projection mapping <span class="math inline">\(\pi^{U\to W}: \mathbf{R}^U\to
\mathbf{R}^W\)</span> by the rule <!-- (no par break) --> <span class="math display">\[\begin{equation*}
   v \in \mathbf{R}^U \mapsto v|W.
\end{equation*}\]</span></p>
<p>Just as we can restrict the domain of a function, we can expand it as
well.</p>
<p>Suppose we have two functions <span class="math inline">\(f\in\mathbf{R}^X\)</span> and <span class="math inline">\(g\in\mathbf{R}^Y\)</span>, where either <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are disjoint, or <span class="math inline">\(f(z) = g(z)\)</span> for all <span class="math inline">\(z\in X\cap Y\)</span>. We define the
<em>union</em> <span class="math inline">\(f\cup g\)</span> of <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> by the rule <!-- (no par break) -->
<span class="math display">\[\begin{equation*}
    (f\cup g)(z) = \begin{cases}
           f(z) &amp; \text{if $z\in X$,} \\
           g(z) &amp; \text{if $z\in Y\smallsetminus X$.}
       \end{cases}
\end{equation*}\]</span> <!-- (no par break) --> Note that this is
exactly the same function as that we get by regarding functions as sets
of ordered pairs and then taking the literal (set) union of <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span>. Also, clearly, <!-- (no par break) -->
<span class="math display">\[\begin{align*}
    f &amp;= (f\cup g)|X \\
    \intertext{and}
    g &amp;= (f\cup g)|Y.
\end{align*}\]</span></p>
<p>Lastly, given any two sets <span class="math inline">\(A\)</span> and
<span class="math inline">\(B\)</span>, we define the <em>Cartesian
product</em> of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> to be a set of ordered couples: <span class="math display">\[\begin{equation*}
    A\times B = \{(a, b): a\in A \text{ and } b\in B\}
\end{equation*}\]</span> <!-- (no par break) --> If <span class="math inline">\(A=\mathbf{R}^X\)</span> and <span class="math inline">\(B=\mathbf{R}^Y\)</span> with <span class="math inline">\(X\cap Y=\emptyset\)</span>, then there is a
natural isomorphism between <span class="math inline">\(\mathbf{R}^X\times\mathbf{R}^Y\)</span> and <span class="math inline">\(\mathbf{R}^{X\cup Y}\)</span> given by
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
    (\mathbf{x}, \mathbf{y}) \mapsto \mathbf{x}\cup\mathbf{y}.
\end{equation*}\]</span> (The inverse mapping is given by <span class="math inline">\(\mathbf{v} \mapsto (\mathbf{v}|X,
\mathbf{v}|Y)\)</span> for <span class="math inline">\(\mathbf{v}\in
\mathbf{R}^{X\cup Y}\)</span>.) <!-- (no par break) --> Where convenient
and warranted, we will consider <span class="math inline">\(\mathbf{R}^X\times\mathbf{R}^Y\)</span> and <span class="math inline">\(\mathbf{R}^{X\cup Y}\)</span> identical.</p>
<p>The notion of Cartisean product can be extended to three or more
sets. For example, since there is a natural isomophism between <span class="math inline">\((A\times B)\times C\)</span> and <span class="math inline">\(A\times(B\times C)\)</span>, we can just write the
product as <span class="math inline">\(A\times B\times C\)</span> and
write its members as ordered triplets <span class="math inline">\((a,b,c)\)</span> (instead of <span class="math inline">\(((a,b),c)\)</span> or <span class="math inline">\((a,(b,c)\)</span>).</p>
</div>
<div class="section level3">
<h3 id="the-khalil-model">The Khalil model<a class="anchor" aria-label="anchor" href="#the-khalil-model"></a>
</h3>
<p>The first model we consider is that described by Khalil <span class="citation">(<a href="#ref-alma99454477012205899" role="doc-biblioref">Khalil 2002</a>)</span>. This model is both
expressive and flexible, and we believe it is the most intuitively
natural way to view the sort of systems BioCro deals with at the systems
level (Section <span class="math inline">\(\ref{sec:BioCro_systems}\)</span>).</p>
<p>In the opening chapter, the author introduces dynamical systems as a
finite collection of coupled first-order ordinary differential
equations</p>
<p><span class="math display">\[\begin{align*}
  \dot{x}_0 &amp;= f_0(t, x_0, \dots, x_{n-1}, u_0, \dots, u_{p-1}) \\
  \dot{x}_1 &amp;= f_1(t, x_0, \dots, x_{n-1}, u_0, \dots, u_{p-1}) \\
  &amp;\; \vdots \\
  \dot{x}_{n-1} &amp;= f_{n-1}(t, x_0, \dots, x_{n-1}, u_0, \dots,
u_{p-1}).
\end{align*}\]</span></p>
<p>This is somewhat more general than the system we considered in
Section <span class="math inline">\(\ref{opening_example}\)</span> in
that the derivatives depend not only upon the state variables <span class="math inline">\(x_0, x_1, \dots, x_{n-1}\)</span>, but also upon
time <span class="math inline">\(t\)</span> and what Khalil refers to as
the <em>input</em> variables <span class="math inline">\(u_0, u_1,
\dots, u_{p-1}\)</span>.</p>
<p>Defining <!-- (no par break) --> <span class="math display">\[\begin{equation}
  \mathbf{x} = \begin{bmatrix}
                     x_0 \\
                     x_1 \\
                     \vdots \\
                     \vdots \\
                     x_{n-1}
               \end{bmatrix},\quad
  \mathbf{u} = \begin{bmatrix}
                     u_0 \\
                     u_1 \\
                     \vdots \\
                     \vdots \\
                     u_{p-1}
               \end{bmatrix},\quad
  \mathbf{f}(t, \mathbf{x}, \mathbf{u}) = \begin{bmatrix}
                     f_0(t, \mathbf{x}, \mathbf{u}) \\
                     f_1(t, \mathbf{x}, \mathbf{u}) \\
                     \vdots \\
                     \vdots \\
                     f_{n-1}(t, \mathbf{x}, \mathbf{u})
               \end{bmatrix}, \label{eq:khalil_vectors}
\end{equation}\]</span> <!-- (no par break) --> the state equation may
be written more succinctly as the vector equation
<!-- (no par break) --> <span class="math display">\[\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}, \mathbf{u}).
\label{eq:Khalil_state_equation}
\end{equation}\]</span> <!-- (no par break) --> (Note that Khalil
actually uses 1-based indexing of vector coordinates in his exposition,
so the vector <span class="math inline">\(\mathbf{x}\)</span>, for
example, is defined by <!-- (no par break) --> <span class="math display">\[\begin{equation*}
  \mathbf{x} = \begin{bmatrix}
                     x_1 \\
                     x_2 \\
                     \vdots \\
                     \vdots \\
                     x_n
               \end{bmatrix}.
\end{equation*}\]</span> <!-- (no par break) --> Here we use 0-based
indexing instead in order to be consistent with other parts of this
article.)</p>
<div class="section level4">
<h4 id="variants-of-khalils-model">Variants of Khalil’s model<a class="anchor" aria-label="anchor" href="#variants-of-khalils-model"></a>
</h4>
<p>At this point, it is worth bringing up two restricted versions of the
Khalil model.</p>
<p>The first is when equation <span class="math inline">\(\eqref{eq:Khalil_state_equation}\)</span> can be
written as <!-- (no par break) --> <span class="math display">\[\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}).
\label{eq:unforced_state_equation}
\end{equation}\]</span> <!-- (no par break) --> Khalil refers to this as
the <em>unforced</em> state equation: it lacks any explicit mention of
inputs. But, he points out, if the input can be specified as an explicit
function of time, <!-- (no par break) --> <span class="math display">\[\begin{align}
  \mathbf{u} &amp;= \boldsymbol\gamma(t), \\
  \intertext{an explicit function of the state,}
  \mathbf{u} &amp;= \boldsymbol\gamma(\mathbf{x}), \\
  \intertext{or an explicit function of both,}
  \mathbf{u} &amp;= \boldsymbol\gamma(t, \mathbf{x}),
\end{align}\]</span> <!-- (no par break) --> then an equation of the
form <span class="math inline">\(\eqref{eq:Khalil_state_equation}\)</span> can
always be reduced to an equation of the form <span class="math inline">\(\eqref{eq:unforced_state_equation}\)</span>.</p>
<p>Khalil goes on to mention one particular special case of the class of
systems described by equation <span class="math inline">\(\eqref{eq:unforced_state_equation}\)</span>:
namely, those that are <em>autonomous</em> or <em>time-invariant</em>. A
system is <em>autonomous</em> if the function <span class="math inline">\(f\)</span> does not depend explicitly on <span class="math inline">\(t\)</span>, that is, if <!-- (no par break) -->
<span class="math display">\[\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(\mathbf{x}).
\label{eq:autonomous_state_equation}
\end{equation}\]</span> <!-- (no par break) --> The behavior of an
autonomous system is invariant to shifts in time origin. (Formally,
however, as we shall see later in Section <span class="math inline">\(\ref{sec:biocro_time}\)</span>, a non-autonomous
system can be made into an automous one by introducing a time-related
variable into the state.)</p>
<p>The falling body system considered above was autonomous: the motion
of the body will follow the same pattern independent of when it is
released. On the other hand, most realistic biological models tend to be
non-autonomous or time-varying. This is largely due to the influence of
weather and other environmental factors; for example, it matters whether
seeds are sown in March or in May.</p>
</div>
</div>
<div class="section level3">
<h3 id="the-giunti-mazzola-model">The Giunti-Mazzola model <a class="anchor" aria-label="anchor" href="#the-giunti-mazzola-model"></a>
</h3>
<p>The model due to Giunti and Mazzola is a further generalization of
the autonomous version of the Khalil model, though cast in a somewhat
different form. Being autonomous, it is in some respects more
restrictive than the general model given in <span class="math inline">\(\eqref{eq:Khalil_state_equation}\)</span>; but in
other respects it is considerably more general.</p>
<p>We highlight this model for two reasons: First, it is mentioned in
the supplementary materials to <span class="citation">Lochocki et al.
(<a href="#ref-10.1093/insilicoplants/diac003" role="doc-biblioref">2022</a>)</span>. Second, it generalizes the
concept of time used for dynamical systems from the real numbers (which
the Khalil model assumes) to any monoid. In particular, we may consider
time domains consisting of the non-negative integers, or some fixed
multiple of the same, such as the non-negative even integers. This is
one of the natural ways to view time in discrete-time systems, which
often arise in practice because continuous-time systems are discretized
when applying numeric solution methods (Section <span class="math inline">\(\ref{sec:discrete_time}\)</span>).</p>
<p>We quote Giunti and Mazzola’s definition of a dynamical system
verbatim ( in <span class="citation">Giunti and Mazzola (<a href="#ref-Giunti&amp;Mazzola" role="doc-biblioref">2012</a>)</span>):</p>
<blockquote>
<p><span class="math inline">\(DS_L\)</span> is a dynamical system on
<span class="math inline">\(L\)</span> iff <span class="math inline">\(DS_L\)</span> is a pair <span class="math inline">\((M,(g^t)_{t \in T})\)</span> and <span class="math inline">\(L\)</span> is a pair <span class="math inline">\((T, +)\)</span> such that</p>
<ol style="list-style-type: lower-roman">
<li><p><span class="math inline">\(L = (T, +)\)</span> is a monoid. Any
<span class="math inline">\(t \in T\)</span> is called a
<em>duration</em> of the system, <span class="math inline">\(T\)</span>
is called its <em>time set</em>, and <span class="math inline">\(L\)</span> its <em>time model</em>;</p></li>
<li><p><span class="math inline">\(M\)</span> is a non-empty set. Any
<span class="math inline">\(x \in M\)</span> is called a <em>state</em>
of the system, and <span class="math inline">\(M\)</span> is called its
<em>state space</em>;</p></li>
<li><p><span class="math inline">\((g^t)_{t \in T}\)</span> is a family
indexed by <span class="math inline">\(T\)</span> of functions from
<span class="math inline">\(M\)</span> to <span class="math inline">\(M\)</span>. For any <span class="math inline">\(t\in T\)</span>, the function <span class="math inline">\(g^t\)</span> is called the <em>state transition of
duration <span class="math inline">\(t\)</span></em> (briefly, <em><span class="math inline">\(t\)</span>-transition</em>, or <em><span class="math inline">\(t\)</span>-advance</em>) of the system;</p></li>
<li>
<p>for any <span class="math inline">\(v,t\in T\)</span>, for any
<span class="math inline">\(x\in M\)</span>,</p>
<ol style="list-style-type: lower-alpha">
<li><p><span class="math inline">\(g^0(x) = x\)</span>, where <span class="math inline">\(0\)</span> is the unity of <span class="math inline">\(L\)</span>;</p></li>
<li><p><span class="math inline">\(g^{v+t}(x) =
g^v(g^t(x))\)</span>.</p></li>
</ol>
</li>
</ol>
</blockquote>
<p> Notice that not only can the time model now be any monoid, the state
space can now be any non-empty set: it is no longer required to be a
subset of a Euclidean space. It needn’t even be a continuum! <em>A
fortiori</em>, there is no longer any requirement that the state
transitions be differential equation based.</p>
<p>Instead of differential equations, we have condition (iv.b),
sometimes called the <em>semi-group</em> property, which relates the
structure of the time model to that of the class of state transitions.
Just as <span class="math inline">\(T\)</span> is a monoid with
operation <span class="math inline">\(+\)</span> and additive identity
<span class="math inline">\(0\)</span>, so too is the collection <span class="math inline">\((g^t)_{t \in T}\)</span> of state transitions,
with the monoid operation being function composition and the identity
element being the identity function. Condition (iv) asserts that the
mapping from <span class="math inline">\((T, +)\)</span> to <span class="math inline">\(((g^t)_{t \in T}, \circ)\)</span> whereby <span class="math inline">\(t \mapsto g^t\)</span> is a monoid
homomorphism.</p>
<p>Condition (iv) is in fact the crux of this definition of a dynamical
system. Without it, there is no structure to the way in which such a
system evolves: the system may pass from one state to the next
willy-nilly without any constraint on the relationship between states
over time.</p>
</div>
<div class="section level3">
<h3 id="the-barreira-valls-model">The Barreira-Valls model<a class="anchor" aria-label="anchor" href="#the-barreira-valls-model"></a>
</h3>
<p>We briefly mention one further model for the discrete time case,
mainly because the formulation is the epitome of simplicity.
<em>Definition 1.1</em> in <span class="citation">Barreira (<a href="#ref-alma99954905266605899" role="doc-biblioref">2019</a>)</span>
states simply</p>
<blockquote>
<p><em>A map <span class="math inline">\(f:
\mathbf{X}\to\mathbf{X}\)</span> is called a</em> dynamical system
<em>with discrete time.</em></p>
</blockquote>
<p> The definition goes on to define higher-order mappings:</p>
<blockquote>
<p><em>We define recursively</em></p>
<p><span class="math display">\[\begin{equation*}
    f^n = f\circ f^{n-1}
\end{equation*}\]</span></p>
<p><em>for each <span class="math inline">\(n\in\mathbf{Z}^+\)</span>,
with the convention that <span class="math inline">\(f^0 =
\operatorname{id}\)</span>. When <span class="math inline">\(f\)</span>
is invertible, we also define <span class="math inline">\(f^{-n} =
(f^{-1})^n\)</span> for each <span class="math inline">\(n\in\mathbf{Z}^+\)</span>.</em></p>
</blockquote>
<p> This is entirely homologous to the Giunti-Mazzola model for the case
where the monoid chosen for the time model is either <span class="math inline">\(\mathbf{Z}\)</span> or <span class="math inline">\(\mathbf{N}\)</span>.</p>
<p>Note that the recursion equation <span class="math inline">\(\eqref{eq:falling_body_recursion}\)</span> derived
from applying Euler’s method to the falling body problem fits nicely
into this model: take <span class="math inline">\(\mathbf{X}\)</span> to
be Euclidean 2-space and the function <span class="math inline">\(f\)</span> to be defined by the rule</p>
<p><span class="math display">\[\begin{equation*}
    (x, y) \mapsto (x + \delta y, y - \delta g).
\end{equation*}\]</span></p>
<p>(Barreira and Valls go on to define “a dynamical system <em>with
continuous time</em>” <span class="citation">(<a href="#ref-alma99954905266605899" role="doc-biblioref">Barreira
2019</a>, Definition 1.7)</span> in precisely the same way as Giunti and
Mazzola (for the case where the time model is <span class="math inline">\(\mathbf{R}\)</span> or <span class="math inline">\(\mathbf{R}_{\geq 0}\)</span>)—that is, as a family
of mappings indexed by time satisfying the semi-group property.)</p>
</div>
</div>
<div class="section level2">
<h2 id="the-biocro-model">The BioCro model <a class="anchor" aria-label="anchor" href="#the-biocro-model"></a>
</h2>
<p>A BioCro system is determined by the specification of five
entities:</p>
<ol style="list-style-type: decimal">
<li>A set of initial values</li>
<li>A set of (constant) parameter values</li>
<li>A set of drivers</li>
<li>A set of direct modules</li>
<li>A set of differential modules</li>
</ol>
<p> These five entities tell us everything about the dynamics of the
system that we need in order to “solve” it. (How, precisely, it will be
solved is determined by specifying a solver.)<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;A less rigorous but much more succinct overview of the
BioCro model is given in Appendix 2 of &lt;span class="citation"&gt;Lochocki
et al. (&lt;a href="#ref-10.1093/insilicoplants/diac003" role="doc-biblioref"&gt;2022&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;'><sup>3</sup></a></p>
<p>Aside from differences in the concept of <em>state</em> (Section
<span class="math inline">\(\ref{sec:state}\)</span>), the Khalil model
fits very well with an idealized version of the BioCro model in which
time is considered to be continuous.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;There are rare cases where a BioCro model uses a module
corresponding to a difference equation rather than a differential
equation. Such models assume discrete time steps and are not naturally
viewed as simply discretizations of systems of ordinary differential
equations. They correspond to a variant of the Khalil model in which the
state equation (Equation &lt;span class="math inline"&gt;\(\eqref{eq:Khalil_state_equation}\)&lt;/span&gt;) has
been replaced with the difference equation &lt;span class="math inline"&gt;\(\Delta\mathbf{x} = \mathbf{f}(t, \mathbf{x},
\mathbf{u})\)&lt;/span&gt;. Since these modules are rare, and since we hope to
eventually phase them out of the standard BioCro module library, we
won’t consider such modules further.&lt;/p&gt;'><sup>4</sup></a> We will see this in the section <span class="math inline">\(\ref{sec:BioCro_systems}\)</span>, where we
discuss the two models side-by-side. But first, we must elaborate a bit
further on the Khalil model.</p>
<div class="section level3">
<h3 id="elaboration-on-the-khalil-model">Elaboration on the Khalil model <a class="anchor" aria-label="anchor" href="#elaboration-on-the-khalil-model"></a>
</h3>
<p>Recall that the Khalil model expresses the derivative <span class="math inline">\(d\mathbf{x}/dt\)</span> of the state as a function
of time <span class="math inline">\(t\)</span>, the state <span class="math inline">\(\mathbf{x}\)</span>, and the input <span class="math inline">\(\mathbf{u}\)</span>: <!-- (no par break) --> <span class="math display">\[\begin{equation*}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}, \mathbf{u}).
\end{equation*}\]</span></p>
<p>Let us denote the domains of <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(\mathbf{u}\)</span> (vis-à-vis the function <span class="math inline">\(\mathbf{f}\)</span>) by <span class="math inline">\(\mathbf{X}\)</span> and <span class="math inline">\(\mathbf{U}\)</span>. <span class="math inline">\(\mathbf{X}\)</span> and <span class="math inline">\(\mathbf{U}\)</span> are vector spaces over the
reals, and following the conventions set out in Section <span class="math inline">\(\ref{sec:notation}\)</span>, we may view them as
sets of mappings from finite <em>index</em> sets into the reals. Thus
<!-- (no par break) --> <span class="math display">\[\begin{align}
    \mathbf{X} = \mathbf{R}^X \\
    \intertext{and}
    \mathbf{U} = \mathbf{R}^U
\end{align}\]</span> <!-- (no par break) --> for some finite sets <span class="math inline">\(X\)</span> and <span class="math inline">\(U\)</span>, where we assume <span class="math inline">\(X\)</span> and <span class="math inline">\(U\)</span> are disjoint.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;If &lt;span class=&quot;math inline&quot;&gt;\(\|X\|=n\)&lt;/span&gt; and
&lt;span class=&quot;math inline&quot;&gt;\(\|U\|=p\)&lt;/span&gt;, then &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{R}^X\)&lt;/span&gt; is isomorphic to the
Euclidean space &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{R}^n\)&lt;/span&gt; and
&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{R}^U\)&lt;/span&gt; is isomorphic to &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{R}^p\)&lt;/span&gt;. In many contexts, we could
just go ahead and consider them not just isomorphic but identical. But
here we want to be more careful because we want to be able to
simultaneously consider functions into &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{R}\)&lt;/span&gt; having non-overlapping
domains.&lt;/p&gt;
&lt;p&gt;Note that in practice, in a model of a real-world system, &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{f}\)&lt;/span&gt; may not be defined for all
&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{x}\in\mathbf{X}\)&lt;/span&gt; and all
&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{u}\in\mathbf{U}\)&lt;/span&gt;. A
coordinate corresponding to temperature in degrees Kelvin, for example,
can not meaningfully take on values less than zero. In general, however,
&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{f}\)&lt;/span&gt; will be defined for all
&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{x}\in\mathbf{X'}\)&lt;/span&gt; and
all &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{u}\in\mathbf{U'}\)&lt;/span&gt;
where &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{X'}\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{U'}\)&lt;/span&gt; are connected subsets of
&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{X}\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{U}\)&lt;/span&gt;. We will reconsider this issue
in Section &lt;span class=&quot;math inline&quot;&gt;\(\ref{sec:manifold}\)&lt;/span&gt;.&lt;/p&gt;"><sup>5</sup></a></p>
<p>Furthermore, recall that in the Khalil model, the value of <span class="math inline">\(\mathbf{u}\)</span> may given by some function of
time and/or the state: <!-- (no par break) --> <span class="math display">\[\begin{align*}
  \mathbf{u} &amp;= \boldsymbol\gamma(t), \\
  \mathbf{u} &amp;= \boldsymbol\gamma(\mathbf{x}), \\
  \intertext{or}
  \mathbf{u} &amp;= \boldsymbol\gamma(t, \mathbf{x}).
\end{align*}\]</span> <!-- (no par break) --> Thinking in terms of the
individual components of <span class="math inline">\(\mathbf{u}\)</span>, each component <span class="math inline">\(u_i\)</span> of <span class="math inline">\(\mathbf{u}\)</span> can be expressed as a function
<span class="math inline">\(\gamma_i\)</span> of <span class="math inline">\(t\)</span> or <span class="math inline">\(\mathbf{x}\)</span> or both:
<!-- (no par break) --> <span class="math display">\[\begin{align*}
  u_i &amp;= \gamma_i(t), \\
  u_i &amp;= \gamma_i(\mathbf{x}), \\
  \intertext{or}
  u_i &amp;= \gamma_i(t, \mathbf{x}).
\end{align*}\]</span> <!-- (no par break) --> It is also possible that
some <span class="math inline">\(u_i\)</span> doesn’t actually depend on
either time or state, that it is in fact constant:
<!-- (no par break) --> <span class="math display">\[\begin{equation}
  u_i = k \quad \text{for some $k\in\mathbf{R}$}.
\end{equation}\]</span> <!-- (no par break) --> We can, in fact,
partition the variables <span class="math inline">\(u_0, u_1, \dots,
u_{p-1}\)</span> comprising the varying input <span class="math inline">\(\mathbf{u}\)</span> into three groups:</p>
<ol style="list-style-type: decimal">
<li><p>Let <span class="math inline">\(u_i\)</span> be in group <span class="math inline">\(K\)</span> if the value of <span class="math inline">\(u_i\)</span> depends on neither <span class="math inline">\(t\)</span> nor <span class="math inline">\(\mathbf{x}\)</span>; that is, it always has the
same value, no matter what the state or the time.</p></li>
<li><p>Let <span class="math inline">\(u_i\)</span> be in group <span class="math inline">\(D\)</span> if the value of <span class="math inline">\(u_i\)</span> depends on <span class="math inline">\(t\)</span> alone.</p></li>
<li><p>Let <span class="math inline">\(u_i\)</span> be in group <span class="math inline">\(W\)</span> otherwise, that is if the value of
<span class="math inline">\(u_i\)</span> depends on the value of <span class="math inline">\(\mathbf{x}\)</span> (and possibly also on <span class="math inline">\(t\)</span>).</p></li>
</ol>
<p> Thus <span class="math inline">\(U=K\cup D\cup W\)</span>, where
<span class="math inline">\(K\)</span>, <span class="math inline">\(D\)</span>, and <span class="math inline">\(W\)</span> are pairwise disjoint. This allows us
to partition the vector space <span class="math inline">\(\mathbf{U}\)</span> into corresponding sub-vector
spaces <span class="math inline">\(\mathbf{K}\)</span>, <span class="math inline">\(\mathbf{D}\)</span>, and <span class="math inline">\(\mathbf{W}\)</span>; that is,
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
  \mathbf{U} = \mathbf{K}\times\mathbf{D}\times\mathbf{W},
\end{equation*}\]</span> <!-- (no par break) --> where <span class="math inline">\(\mathbf{K}=\mathbf{R}^K\)</span>, <span class="math inline">\(\mathbf{D}=\mathbf{R}^D\)</span>, and <span class="math inline">\(\mathbf{W} = \mathbf{R}^W\)</span>. Each input
<span class="math inline">\(\mathbf{u}\)</span> may now be written as a
triplet <span class="math inline">\((\mathbf{k}, \mathbf{d},
\mathbf{w})\)</span> where <span class="math inline">\(\mathbf{k}\in
\mathbf{K}\)</span>, <span class="math inline">\(\mathbf{d}\in
\mathbf{D}\)</span>, and <span class="math inline">\(\mathbf{w}\in
\mathbf{W}\)</span>.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Note that any (or all!) of the sets &lt;span class="math inline"&gt;\(K\)&lt;/span&gt;, &lt;span class="math inline"&gt;\(D\)&lt;/span&gt;, or &lt;span class="math inline"&gt;\(W\)&lt;/span&gt; may be empty, in which case the
corresponding vector space is zero dimensional and the corresponding
vector argument can be eliminated from equation &lt;span class="math inline"&gt;\(\eqref{eq:BioCro_state_equation}\)&lt;/span&gt;. (If all
three sets are empty, then of course we have no inputs and the system is
automatically described by the unforced state equation &lt;span class="math inline"&gt;\(\eqref{eq:unforced_state_equation}\)&lt;/span&gt;.)&lt;/p&gt;'><sup>6</sup></a> Moreover, there exist functions <span class="math inline">\(\gamma^\mathbf{D}: T\to\mathbf{D}\)</span> and
<span class="math inline">\(\gamma^\mathbf{W}:
T\times\mathbf{X}\to\mathbf{W}\)</span> and a constant function <span class="math inline">\(\gamma^\mathbf{K}\)</span> with codomain <span class="math inline">\(\mathbf{K}\)</span> such that
<!-- (no par break) --> <span class="math display">\[\begin{align}
  \mathbf{k} &amp;= \gamma^\mathbf{K}(),       \label{eq:k} \\
  \mathbf{d} &amp;= \gamma^\mathbf{D}(t),      \label{eq:d} \\
  \intertext{and}
  \mathbf{w} &amp;= \gamma^\mathbf{W}(t, \mathbf{x}) \label{eq:s}
\end{align}\]</span> <!-- (no par break) --> at any moment in the life
of the system.</p>
<p>Since <span class="math inline">\(\mathbf{u} = (\mathbf{k},
\mathbf{d}, \mathbf{w})\)</span>, we can rewrite the state equation
<span class="math inline">\(\eqref{eq:Khalil_state_equation}\)</span> as
<!-- (no par break) --> <span class="math display">\[\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}, \mathbf{k}, \mathbf{d},
\mathbf{w}). \label{eq:BioCro_state_equation}
\end{equation}\]</span> <!-- (no par break) --> But using equations
<span class="math inline">\(\eqref{eq:k}\)</span>, <span class="math inline">\(\eqref{eq:d}\)</span>, and <span class="math inline">\(\eqref{eq:s}\)</span>, we can eliminate <span class="math inline">\(\mathbf{k}\)</span>, <span class="math inline">\(\mathbf{d}\)</span>, and <span class="math inline">\(\mathbf{w}\)</span> to get <span class="math inline">\(\mathbf{f}\)</span> as a function of <span class="math inline">\(t\)</span> and <span class="math inline">\(\mathbf{x}\)</span> alone: <!-- (no par break) -->
<span class="math display">\[\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}, \gamma^\mathbf{K}(),
\gamma^\mathbf{D}(t), \gamma^\mathbf{W}(t, \mathbf{x})).
\end{equation}\]</span> <!-- (no par break) --> In other words,
<!-- (no par break) --> <span class="math display">\[\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}^{\,*}(t, \mathbf{x})
\end{equation}\]</span> <!-- (no par break) --> for some suitable
function <span class="math inline">\(\mathbf{f}^{\,*}\)</span>, so that
we have now an unforced state equation as in equation <span class="math inline">\(\eqref{eq:unforced_state_equation}\)</span>.</p>
</div>
<div class="section level3">
<h3 id="biocro-viewed-in-terms-of-the-khalil-model">BioCro viewed in terms of the Khalil model <a class="anchor" aria-label="anchor" href="#biocro-viewed-in-terms-of-the-khalil-model"></a>
</h3>
<p>In BioCro, as noted above, a system is determined when we specify its
<em>initial values</em>, <em>parameters</em>, <em>drivers</em>,
<em>direct modules</em>, and <em>differential modules</em>. How do these
relate to the version of the Khalil model just discussed?</p>
<ul>
<li>The <em>initial values</em> correspond to the state <span class="math inline">\(\mathbf{x}\)</span> at some initial time <span class="math inline">\(t_0\)</span>, which for convenience, we will
always take to be 0. (Thus <em>time</em> is always the amount of time
that has elapsed since the start of the simulation.) We will denote this
initial state as <span class="math inline">\(\mathbf{x}_0 = (x_{0,0},
x_{1,0}, \dots, x_{n-1,0})\)</span>. In BioCro, the state variables are
referred to as <em>differential quantities</em>, since they evolve
according to differential equations. It is the <em>initial values</em>
specification that determines which variables comprise the state, and
the dimension of the state space <span class="math inline">\(\mathbf{X}\)</span> is equal to the number of
variables in <span class="math inline">\(\mathbf{x}_0\)</span>.</li>
</ul>
<p>For now, we shall consider the initial values as part of the
definition of a system only in so far as they determine the set of
variables comprising the state space for the system. The specification
of what values these variables have at time <span class="math inline">\(t_0\)</span> will be considered to be something
associated with a particular run of a system and not something inherent
in the system itself. This will make comparison with the Khalil and
Giunti models easier, since those models don’t specify anything
analogous to an initial state.</p>
<p>In what follows, when we need to make this distinction, we shall
refer to a dynamical system together with a specified initial state as a
<em>run</em> of a system. It should also be noted, as discussed in
Section <span class="math inline">\(\ref{sec:discrete_time}\)</span>,
that actually running the system (that is, allowing the state to evolve
from its initial values) requires the use of numerical methods that
effectively discretize the continous system of differential equations of
a Khalil system. Whether we consider this as the development of a new
discrete dynamical system from a continuous one or just a matter of
practical convenience is mostly matter of perspective.</p>
<ul>
<li><p>The <em>parameters</em> correspond to the sole value in the
codomain of the constant function <span class="math inline">\(\gamma^\mathbf{K}\)</span>. This will be a <span class="math inline">\(q\)</span>-tuple of values <span class="math inline">\(\mathbf{k} = (k_0, k_1, \dots, k_{q-1})\)</span>,
where <span class="math inline">\(q\)</span> is the number of
parameters, the dimension of the vector subspace <span class="math inline">\(\mathbf{K}\)</span>.</p></li>
<li><p>The <em>drivers</em> correspond to the function <span class="math inline">\(\gamma^\mathbf{D}:T\to\mathbf{R}^r\)</span>,
giving the value of <span class="math inline">\(\mathbf{d}\)</span> as a
function of time. Writing <span class="math inline">\(\mathbf{d}\)</span> as <span class="math inline">\((d_0, d_1, \dots, d_{r-1})\)</span>, where <span class="math inline">\(r\)</span> is the number of driver variables (the
dimension of <span class="math inline">\(\mathbf{D}\)</span>), we can
decompose <span class="math inline">\(\gamma^\mathbf{D}(t)\)</span> into
scalar-valued functions <span class="math inline">\(\gamma^\mathbf{D}_0(t)\)</span>, <span class="math inline">\(\gamma^\mathbf{D}_1(t)\)</span>, , <span class="math inline">\(\gamma^\mathbf{D}_{r-1}(t)\)</span>.</p></li>
</ul>
<p>It should be noted that the driver functions <span class="math inline">\(\gamma^\mathbf{D}_i\)</span> are rarely functions
that can easily be specified by and computed from some formula. In
example shown in Appendix 1 of <span class="citation">Lochocki et al.
(<a href="#ref-10.1093/insilicoplants/diac003" role="doc-biblioref">2022</a>)</span>, the function giving the value of
the driver variable <span class="math inline">\(Q\)</span> corresponding
to photosynthetic photon flux density is based on the function
<!-- (no par break) --> <span class="math display">\[\begin{equation}
  Q = \sin(\frac{t}{12\cdot 3600} \pi)\cdot 2000 \times 10^{-6}.
\end{equation}\]</span> <!-- (no par break) --> Here, <span class="math inline">\(t\)</span> is meant to represent the elapsed time
in seconds, and in this example, the actual values fed into the BioCro
system constructor are only the values of <span class="math inline">\(Q\)</span> for a set of integral values of <span class="math inline">\(t\)</span>, namely, <span class="math inline">\(t
= 0, 1, 2, \dots, 43200\)</span>. As acknowledged in the appendix, this
is a highly artificial example.</p>
<p>Usually, a driver variable function can only be defined via an
equation<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;This particular function is, in fact, the function you
would get if you expressed the total PAR flux density (in &lt;span class="math inline"&gt;\(\mu\text{mol}/m^2/s\)&lt;/span&gt;) measured at the
Earth’s surface in Champaign, Illinois (per the &lt;em&gt;weather&lt;/em&gt; data
set accompanying BioCro) as a function (taking &lt;span class="math inline"&gt;\(t_i = i\)&lt;/span&gt;) of the number of hours elapsed
since midnight on January 1, 2005.&lt;/p&gt;'><sup>7</sup></a>
of the form <!-- (no par break) --> <span class="math display">\[\begin{equation}
    \gamma^\mathbf{D}_i(t) = \begin{cases}
        0.046 &amp; \text{if $t = t_0$}, \\
        0.023 &amp; \text{if $t = t_1$}, \\
        \dots \\
        \dots \\
        1151.541 &amp; \text{if $t = t_{4000}$}, \\
        747.040 &amp; \text{if $t = t_{4001}$}, \\
        \dots \\
        \dots \\
        0.621 &amp; \text{if $t = t_{8758}$}, \\
        0.874 &amp; \text{if $t = t_{8759}$}.
    \end{cases}
\end{equation}\]</span> <!-- (no par break) --> Here, <span class="math inline">\(t_0, t_1, \dots, t_{8759}\)</span> is a sequence
of times representing the amount of time elapsed since the beginning of
the simulation, with <span class="math inline">\(t_0 = 0\)</span>, and
for some fixed positive value <span class="math inline">\(\Delta
t\)</span>, <span class="math inline">\(t_{j+1} = t_j + \Delta
t\)</span> for <span class="math inline">\(0 \leq j &lt; 8759\)</span>.
In practice, in BioCro, this equation is usually specified implicitly
via an R data frame: <span class="math inline">\(\gamma^\mathbf{D}_i\)</span> corresponds to some
column of the data frame, and the value of that column in row <span class="math inline">\(j\)</span> is that value for <span class="math inline">\(\gamma^\mathbf{D}_i\)</span> at time <span class="math inline">\(t_{j-1}\)</span>.</p>
<p>(For some numerical methods, we need to know values of <span class="math inline">\(\gamma^\mathbf{D}_i(t)\)</span> for values of
<span class="math inline">\(t\)</span> <em>between</em> the time points
given in this definition. In principle, many approaches are available
for this type of interpolation, such as cubic splines. At the moment,
BioCro only offers linear interpolation between neighboring time points.
In other words, an additional case is added to the above rule:
<!-- (no par break) --> <span class="math display">\[\begin{equation}
  \gamma^\mathbf{D}_i(t) = \frac{t_{j + 1} - t}{\Delta
t}\,\gamma^\mathbf{D}_i(t_j)
                       + \frac{t - t_j}{\Delta
t}\,\gamma^\mathbf{D}_i(t_{j+1})
                       \quad\text{if $t_j &lt; t &lt; t_{j+1}$}
\end{equation}\]</span> <!-- (no par break) --> This makes <span class="math inline">\(\gamma^\mathbf{D}_i(t)\)</span> into a
piecewise-linear continuous function.)</p>
<p>Now to the modules. As we will show later (Section <span class="math inline">\(\ref{sec:modularization}\)</span>), any BioCro
system is equivalent to a BioCro system having only a single module of
each type, but having the same initial values, parameters, and
drivers.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;This isn’t to say the requisite modules exist. In order
to realize this replacement, the user may have to write them!&lt;/p&gt;"><sup>8</sup></a>
Thus, for simplicity, we will here consider only the case where there is
a single module of each type.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;As an alternative to confining the discussion here to
the case where there is only a single module of each type, we could
instead make no stipulation about the number of modules and simply
substitute the phrase “the direct (differential) module component” in
every place where we speak of “the direct (differential) module”.&lt;/p&gt;"><sup>9</sup></a> Later, we will consider how a single module
may be broken up into multiple modules (Section <span class="math inline">\(\ref{sec:modularization}\)</span>).</p>
<ul>
<li>
<p>The <em>direct module</em> corresponds to the function <span class="math inline">\(\gamma^\mathbf{W}: T\times\mathbf{X} \to
\mathbf{W}\)</span>. In point of fact, we usually think of the direct
module as corresponding to a function <span class="math inline">\({}^*\gamma^\mathbf{W}:
\mathbf{X}\times\mathbf{K}\times\mathbf{D} \to \mathbf{W}\)</span>, but
using equations <span class="math inline">\(\eqref{eq:k}\)</span> and
<span class="math inline">\(\eqref{eq:d}\)</span> and substituting, we
can derive a function <span class="math inline">\(\gamma^\mathbf{W}\)</span> that gives the value of
<span class="math inline">\(\mathbf{w}\)</span> as a function of <span class="math inline">\(t\)</span> and <span class="math inline">\(\mathbf{x}\)</span> alone.</p>
<p>Note in particular that the number of output variables of this direct
module gives the dimension of the <span class="math inline">\(\mathbf{W}\)</span> component of <span class="math inline">\(\mathbf{U}\)</span>. We call these variables the
<em>direct quantities</em> of the system (for lack of a better term)
since they are the outputs of the direct module.</p>
</li>
</ul>
<p>Two observations should be made here.</p>
<p>First, in the general case, where multiple direct modules <span class="math inline">\(\mathcal{M}_1, \mathcal{M}_2, \dots\)</span> are
used in the construction of our system, some of those modules may depend
on the outputs of other direct modules. In this case, each module <span class="math inline">\(\mathcal{M}_i\)</span> corresponds to a function
of the form <!-- (no par break) --> <span class="math display">\[\begin{equation}
  \gamma^{\mathbf{W}_i}:
\mathbf{X}\times\mathbf{K}\times\mathbf{D}\times\mathbf{\overline{W}}_i
\to \mathbf{W}_i,
\end{equation}\]</span> <!-- (no par break) --> where <span class="math inline">\(\mathbf{W}_i\)</span> is the subspace of <span class="math inline">\(\mathbf{W}\)</span> generated by the variables in
the output of module <span class="math inline">\(\mathcal{M}_i\)</span>
and <span class="math inline">\(\mathbf{\overline{W}}_i\)</span> is the
subspace of <span class="math inline">\(\mathbf{W}\)</span> generated by
those inputs to module <span class="math inline">\(\mathcal{M}_i\)</span> that are not in <span class="math inline">\(X\)</span>, <span class="math inline">\(K\)</span>, or <span class="math inline">\(D\)</span>. (A direct module’s inputs and outputs
are required to be disjoint. Thus <span class="math inline">\(\mathbf{\overline{W}}_i\)</span> is complementary
to <span class="math inline">\(\mathbf{W}_i\)</span>, with <span class="math inline">\(\mathbf{W}_i \times
\mathbf{\overline{W}}_i\)</span> a subspace of <span class="math inline">\(\mathbf{W}\)</span>.) We will discuss this further
in the section on modularization (Section <span class="math inline">\(\ref{sec:modularization}\)</span>).</p>
<p>Second, it should be mentioned that the Khalil model allows for the
inclusion of an output function <!-- (no par break) --> <span class="math display">\[\begin{equation}
  \mathbf{y} = \mathbf{h}(t, \mathbf{x}, \mathbf{u}).
\end{equation}\]</span> <!-- (no par break) --> Khalil says that this
output vector <span class="math inline">\(\mathbf{y}\)</span> “comprises
variables of particular interest in the analysis of dynamical systems .”
In the Khalil model, these variables, unlike the variables that comprise
<span class="math inline">\(\mathbf{u}\)</span>, are not a part of the
state equation. They are there for informational purposes only.</p>
<p>The closest analogue to these variables in BioCro are those variables
that are outputs of the direct module of the system but are not inputs
to the differential module. An example of such variables in the BioCro
library are the <em>kinetic energy</em>, <em>spring energy</em>, and
<em>total energy</em> outputs of the harmonic energy module (class
<code>harmonic_energy</code>). These exist only to give information
about the system using this module since (at least of this writing)
there are no existing modules that use these as inputs.</p>
<ul>
<li>
<p>The <em>differential module</em> corresponds to the function
<span class="math inline">\(\mathbf{f}\)</span> in equation <span class="math inline">\(\eqref{eq:BioCro_state_equation}\)</span>. This is
the Khalil state equation, but with <span class="math inline">\(\mathbf{u}\)</span> divided into components <span class="math inline">\(\mathbf{k}\)</span>, <span class="math inline">\(\mathbf{d}\)</span>, and <span class="math inline">\(\mathbf{w}\)</span>. The primary constraint on the
differential module is that its output variables must all be
differential quantities (or, equivalently, state variables), which are
determined by the initial values specification as discussed above.</p>
<p>(BioCro doesn’t require that all state variables be included in the
differential module outputs: if some state variable <span class="math inline">\(x_i\)</span> is not, it is assumed that <span class="math inline">\(\dot{x}_i = 0\)</span>; that is, that component of
the state remains constant throughout the life of the system.)</p>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="biocros-concept-of-time">BioCro’s concept of time <a class="anchor" aria-label="anchor" href="#biocros-concept-of-time"></a>
</h3>
<p>In the C++ interface to the BioCro library, there is only one
required user-facing time-related variable—namely, the quantity
<code>timestep</code>, which must be provided as one (and possibly the
only) of the parameters when setting up a system.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;The timestep parameter is different in character from
the other parameters that make up part of the specification of a BioCro
system. It does not correspond to a physical attribute of the real
dynamical system being modeled. Rather, it is an artifact of the way in
which the real system is modeled mathematically. In fact, it should not
be included in the parameters at all and is only there due to a
“historical accident.” Eventually, it is intended that
&lt;code&gt;timestep&lt;/code&gt; will be removed from the BioCro parameters. As
such, we don’t consider it as one of the variables in the set &lt;span class="math inline"&gt;\(K\)&lt;/span&gt; that we introduced in Section &lt;span class="math inline"&gt;\(\ref{sec:khalil_elaboration}\)&lt;/span&gt;.&lt;/p&gt;'><sup>10</sup></a> (In the R interface,
there are always three additional quantities—<code>doy</code>,
<code>hour</code>, and <code>time</code>—which always come into play
when we set up or run a system. These are artifacts of certain aspects
of the R interface and are subject to revision, and we will mostly
ignore them here.)</p>
<p>The <code>timestep</code> quantity, however, gives rise to an
implicit quantity, the <em>elapsed time</em>, that corresponds well with
the <em>time</em> variable as used in the Khalil and the Giuli-Mazzola
models.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;We shall henceforth refer to the model from &lt;span class="citation"&gt;Giunti and Mazzola (&lt;a href="#ref-Giunti&amp;amp;Mazzola" role="doc-biblioref"&gt;2012&lt;/a&gt;)&lt;/span&gt; presented in Section &lt;span class="math inline"&gt;\(\ref{sec:giunti-mazzola}\)&lt;/span&gt; as simply the
&lt;em&gt;Giunti&lt;/em&gt; model: it is essentially the same model presented
fifteen years earlier in &lt;span class="citation"&gt;Giunti (&lt;a href="#ref-Giunti1997-GIUCDS" role="doc-biblioref"&gt;1997&lt;/a&gt;)&lt;/span&gt;, but
generalized to an arbitrary monoid, a generalization we have no need to
make use of in BioCro. (This is not entirely true: whereas &lt;span class="citation"&gt;Giunti (&lt;a href="#ref-Giunti1997-GIUCDS" role="doc-biblioref"&gt;1997&lt;/a&gt;)&lt;/span&gt; only considers time systems
consisting of the integers, the rationals, the reals, or the
non-negative members of the same, we allow time systems isomorphic to,
but not identical to, the non-negative integers, such as the set of
non-negative even integers. But our time systems will always be
commutative and linearly ordered: we have no need to consider arbitrary
monoids, such as time systems that correspond to cyclic groups,
arbitrary n-dimensional vector spaces, or the quaternions under
multiplication.)&lt;/p&gt;'><sup>11</sup></a> <code>timestep</code>, in fact, denotes
the amount of time that elapses between successive values of any of the
driver variables.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;We could make &lt;em&gt;elapsed time&lt;/em&gt; an explicit
quantity in our systems by writing a differential module with no inputs,
one that always returns the value &lt;span class="math inline"&gt;\(1\)&lt;/span&gt;
for its one output variable &lt;code&gt;elapsed_time&lt;/code&gt;. Then, assuming we
give it the initial value zero, its value at any time will represent the
amount of time that has elapsed since the start of the simulation, in
whatever time units &lt;code&gt;timestep&lt;/code&gt; is in.&lt;/p&gt;'><sup>12</sup></a></p>
<p><em>Time</em> often shows up explicitly in a BioCro system in the
form of a specific date and time, and what the value of some driver
variable was at that date and time; for example, from the information in
the drivers parameter we may able to make assertions such as <em></em>
But “3 p.m. on April 15, 2005” is not the sort of time with which the
Giunti model deals. Times—<em>durations</em>—in the Giunti model are
members of a monoid, which we can add together to get another time in
the monoid. But we can not add <em></em> and <em></em> in any meaningful
way to get some other date-time. We can, however, add durations: we can,
for example, look at the state of a system one hour after the initial
state of that system, and then look at the state two hours later, and
the second observation will be three hours after the time corresponding
to the system’s initial state (since <span class="math inline">\(2 + 1 =
3\)</span>).</p>
<p>As hinted above, the <code>timestep</code> quantity generates a
monoid: if the value of <code>timestep</code> is <span class="math inline">\(\delta\)</span>, then the members of that monoid
are <span class="math inline">\(0, \delta, \delta + \delta, \delta +
\delta + \delta, \delta + \delta + \delta + \delta, \dots\)</span>, ad
infinitum.</p>
<p>Of course, in BioCro, we don’t let our system simulations run
forever, so the set of times dealt with in any given run of a system
doesn’t really quite form a monoid because if we add <span class="math inline">\(\delta\)</span> to the final time point in our
simulation, we get a time that is outside the domain of our simulation.
Conceptually, we can deal with this problem (of reconciling BioCro’s
concept of time with that of the Giunti model) by imagining that our
system simulations <em>could</em> run forever if we let them (and if we
had knowledge infinitely far into the future of any driver variables we
happened to be using); we imagine that we <em>could</em> do this but
that instead, we choose to look at the behavior of the system only over
some finite period of time.</p>
</div>
<div class="section level3">
<h3 id="biocros-concept-of-state">BioCro’s concept of state <a class="anchor" aria-label="anchor" href="#biocros-concept-of-state"></a>
</h3>
<p>In BioCro, at the level of a module, all input quantities are
considered uniformly. There are good reasons for this, reasons that go
beyond mere programmatic convenience. For example, the input to some
module might in one system be determined mechanistically as the output
of some other module; but in a different system, it might come from data
observations and thereby be one of the drivers. But the module using
that input doesn’t care where it comes from.</p>
<p>Once we set up a system, however, each quantity falls neatly into one
of four categories: it is either a parameter, a driver, a differential
quantity, or a direct quantity. (These correspond, respectively, to the
subspaces <span class="math inline">\(\mathbf{K}\)</span>, <span class="math inline">\(\mathbf{D}\)</span>, <span class="math inline">\(\mathbf{X}\)</span>, and <span class="math inline">\(\mathbf{W}\)</span> discussed in Sections <span class="math inline">\(\ref{sec:khalil_elaboration}\)</span> and <span class="math inline">\(\ref{sec:BioCro_systems}\)</span> and to the
arguments <span class="math inline">\(\mathbf{k}\)</span>, <span class="math inline">\(\mathbf{d}\)</span>, <span class="math inline">\(\mathbf{x}\)</span>, and <span class="math inline">\(\mathbf{w}\)</span> in the state equation in the
form given in equation <span class="math inline">\(\eqref{eq:BioCro_state_equation}\)</span>.)</p>
<p>The uniform treatment of quantities at the module level is reflected
in the C++ code used to implement BioCro simulations: each quantity used
in a given system is incorporated into a C++ structure of a user-defined
type called <code>state_map</code>, which maps names of quantities to
the value such quantities have at some particular time. This naturally
leads to referring to the aggregate of the values of all quantities of
the system at some particular point in time as the <em>state</em> of the
system at that time. Thus, while Khalil’s model distinguishes betwee the
state and the inputs, the term state as used in BioCro refers to the
parameters, drivers, differential quantities, and direct quantities as a
whole (equivalent to Khalil’s state <em>and</em> drivers).</p>
<p>This section attempts to reconcile this conception of state with that
commonly used in dynamical systems theory, and in particular, with the
formulations presented in chapter <span class="math inline">\(\ref{sec:formulations}\)</span>. Elsewhere in this
document, we use the term <em>state</em> exclusively in reference to its
usual definition as employed in the Khalil, Giuli-Mazzola, and
Barreira-Valls models. When discussing BioCro, we refer to the state
variables as the <em>differential quantities</em> to avoid
misrepresenting BioCro’s idea of state. In this section, however, we
must necessarily use <em>state</em> to refer to both conceptions, and we
will try to clarify which definition is meant whenever it is unclear
from context.</p>
<div class="section level4">
<h4 id="biocro-state-and-the-khalil-model">BioCro state and the Khalil model<a class="anchor" aria-label="anchor" href="#biocro-state-and-the-khalil-model"></a>
</h4>
<p>Khalil remarks that the state variables “represent the memory that
the dynamical system has of its past.” As Laplace <span class="citation">(<a href="#ref-alma99954908866305899" role="doc-biblioref">Dale 1995</a>)</span> remarks, “We ought then to
consider the present state of the universe as the effect of its previous
state and as the cause of that which is to follow.” The inputs in the
model, on the other hand, are in general completely arbitrary. They are
not determined by the state or by their own past or future values. They
help determine, but are not determined by, the evolution of the state of
the system. In a sense, they are like the hand of the experimenter-god
touching and influencing this otherwise mechanistically-determined
system.</p>
<p>In BioCro, the inputs are considered part of the state, partly as a
matter of convenience; but, convenience aside, there is also a
philosophical justification for this: In many systems, the inputs may
clearly be thought of as somehow external to the system. When studying
an electrical circuit, for example, the experimenter may apply
electrical inputs to the system and see how the system responds. Even in
a controlled plant-growth experiment conducted in a climate-controlled
greenhouse, the environmental inputs may be applied somewhat
arbitrarily. In BioCro, by contrast, the inputs (the <em>drivers</em>)
are usually related to weather and other aspects of the
environment—temperature, humidity, radiation, and so on. Unlike in a
controlled experiment, these environmental variables evolve according to
their own laws; they are not under the control of the experimenter. In a
truly comprehensive model, their laws of evolution would be included
right alongside the laws determining plant growth. But generally, to do
so would overly complicate the model, and by and large, given the
inherently chaotic nature of meteorological processes and the vast
amounts of additional data that would be required, it is not at all
feasible to do so. So in BioCro, we regard them as a part of the
system—as part of the <em>state</em> of the system—but as a part that is
taken as given rather than as a part that is to be derived from some
general rules governing the evolution of natural systems.</p>
<p>None of this is to say, of course, that BioCro can’t also be used to
model controlled experiments, such as those carried out in a greenhouse;
or to model “thought experiments” or “what if” scenarios: <em>What would
happen if we used the weather data from 2005 but assumed a much higher
<span class="math inline">\(\text{CO}_\text{2}\)</span>
concentration?</em></p>
</div>
<div class="section level4">
<h4 id="biocro-state-and-the-giunti-model">BioCro state and the Giunti model<a class="anchor" aria-label="anchor" href="#biocro-state-and-the-giunti-model"></a>
</h4>
<p>Giunti and Mazzola’s model definition was cited in the supplementary
materials to <span class="citation">Lochocki et al. (<a href="#ref-10.1093/insilicoplants/diac003" role="doc-biblioref">2022</a>)</span> as justification for considering
all quantities involved in a system (except for time) as part of the
state. Whatever the merits of that argument, in retrospect, this
possibly amounts to a sort of cherry-picking of the Giunti-Mazzola
definition because it is not altogether clear whether BioCro dynamical
systems, as envisioned in that paper, have, in general, a collection of
well-defined transition functions <span class="math inline">\((g^t)_{t
\in T}\)</span>. Whether they do or do not turns on the question of how
we interpret the stipulation, given in the supplement, that “the term
state is used to refer to all quantities involved in the system, except
time.”</p>
<p>As we demonstrate here, a BioCro system having drivers but that does
not include a time-like variable amongst those drivers does not, in
general, conform to the Giunti model.</p>
<p>To see this, let us consider a typical BioCro system in which the
driver component consists of the values of a number of weather-related
variables over the course of a year, and suppose these variables happen
to all have the same values at two different times; for example, suppose
the weather at 1 p.m. on April 12, 2008 is exactly the same as the
weather at 3 p.m. on May 16, 2008 to the extent <em>weather</em> is
captured by the attributes in our model. Moreover, suppose our system
has what might be a typical array of differential variables—namely,
those that describe the state of growth of a plant that is subjected to
the environment described by the driver variables in the system.</p>
<p>Consider now two identical states—one, <span class="math inline">\(s_1\)</span>, corresponding to a seedling planted
at 1 p.m. on April 12, 2008, and one, <span class="math inline">\(s_2\)</span>, corresponding to an identical
seedling planted at 3 p.m. on May 16, 2008. The states are identical
because the attributes of the seedlings, described by the differential
variables, are identical, and the attributes of the weather, described
by the driver variables, are also identical; and because the parameters
(being constant) are identical, and the values of the “direct”
variables, being functions of the other three components, are also
identical. (Recall that we are specifically excluding date and time from
our notion of state here.) In other words, <span class="math inline">\(s_1 = s_2\)</span>.</p>
<p>Now consider one of the transition functions <span class="math inline">\(g^t\)</span>—say, for example, some function <span class="math inline">\(g^u\)</span>, where <span class="math inline">\(u\)</span> corresponds to a duration of 30 days.
Then <span class="math inline">\(g^u(s_1)\)</span> will be the state
corresponding the the attributes of the seedling planted on April 12 and
its environment one month later, on May 12, 2008. And <span class="math inline">\(g^u(s_2)\)</span> will be the state corresponding
the the attributes of the seedling planted on May 16 and its environment
approximately one month later, on June 15. Will the weather at 1 p.m. on
May 12, 2008 be identical to that at 3 p.m. on June 15, 2008? According
to the Giunti model, it should be, since <span class="math inline">\(s_1
= s_2\)</span> implies that state <span class="math inline">\(g^u(s_1)\)</span> equals state <span class="math inline">\(g^u(s_2)\)</span>; and if two states are equal,
those components of the state that describe the weather should be equal
as well.</p>
<p>But we know that something is wrong here, because even if the same
weather occurs at two different times, we can’t expect the weather
patterns going forward to develop in the same way. Moreover, in all
likelyhood the identical seedlings planted on April 12 and May 16 will
no longer be identical 30 days later because they likely will have been
subjected to different weather conditions.</p>
<p>There are two ways (at least) out of this predicament. One is to
ensure that the driver component of the state never repeats itself. Any
monotonically-increasing driver variable would do the trick, but the
most natural way of ensuring no repetitions is probably to include some
representation of the time, such as the calendar date and time, Julian
date, reduced Julian date, or Unix time as part of the driver component
of the state. (The R interface to BioCro in fact requires either both
the day-of-year and hour of the day as driver variables or it requires a
monotonically-increasing variable called <em>time</em>. The C++
interface, however, requires neither of these.)</p>
<p>A second way, one that makes the system formally time-independent, is
to modify the driver component in our notion of the state. In this
scheme, the driver component of a state is not just an array of values
the driver variables happen to have at some particular time. Now,
instead, it is an encapsulation of the future of the driver variable
values indefinitely far into the future. One way to imagine this, if we
are thinking of the drivers as corresponding to the weather, is to think
of the driver component of the state at some particular time as a
weather prediction giving the weather at that time <em>and for every
future time</em>, i.e., the weather one day from now, two days from now,
and so on; moreover, not just any prediction, but a 100% accurate one.
The state now, without having to include the date or time, encapsulates
all the information we need to have in order to know what the state will
be <span class="math inline">\(x\)</span> amount of time in the
future.</p>
<p>We bring this up to show that even in the presence of drivers
(<em>inputs</em>, in Khalil’s terminology), the notion of an autonomous
system is possible. And we can have systems that conform to the Giunti
model without requiring that states on different dates be distinct. For
example, imagine a greenhouse experiment in which the climate conditions
in the greenhouse repeat exactly the same pattern from one day to the
next. In this system, the driver state at noon—the “weather” prediction
for each moment going forward (one hour later, 10 hours later, 10 days
later)—will be exactly the same from one day to the next. And so too
will the evolution of a generic seedling: the evolution of a seedling
planted at noon on one day will be the same as the evolution of an
identical seedling planted at noon twenty days later.</p>
<p>In practical terms, however, this is a rather complicated model. The
state space will no longer be a Euclidean space, since <span class="math inline">\(\mathbf{D}\)</span>, the driver component of the
state space, will no longer be the Euclidean space <span class="math inline">\(\mathbf{R}^r\)</span> but will instead be the set
<span class="math inline">\((\mathbf{R}^r)^T\)</span> of all functions
<span class="math inline">\(\gamma^\mathbf{D}: T \to
\mathbf{R}^r\)</span>. (Note that the state transition of duration <span class="math inline">\(u\)</span> restricted to the <span class="math inline">\(\mathbf{D}\)</span> component of the state is at
least easily defined: if <span class="math inline">\(\gamma\)</span> is
the <span class="math inline">\(\mathbf{D}\)</span> component of some
state <span class="math inline">\(\mathbf{s}\)</span>, then <span class="math inline">\(g^u(\gamma)\)</span> will be the function defined
by the rule <span class="math inline">\(t \mapsto \gamma(u +
t)\)</span>.)</p>
<p>The upshot is that the Giunti model does not naturally describe a
BioCro system having drivers unless some proxy for time is allowed to be
a component of those drivers. It should also be noted that BioCro does
not make use of two important generalizations in the Giunti model: in
BioCro, the state space always <em>will</em> be a subset (in fact, a
<em>connected</em> subset) of a Euclidean space, and state transitions
(using <em>state</em> in Khalil’s sense) will always be differential
equation based. Thus, we find that Khalil’s model provides a better
description of BioCro systems.</p>
</div>
<div class="section level4">
<h4 id="the-state-space-as-a-manifold">The state space as a manifold <a class="anchor" aria-label="anchor" href="#the-state-space-as-a-manifold"></a>
</h4>
<p>One of the arguments given in the supplementary materials to <span class="citation">Lochocki et al. (<a href="#ref-10.1093/insilicoplants/diac003" role="doc-biblioref">2022</a>)</span> for considering <em>all</em>
variables as state variables is that “the division between state and
auxiliary variables is arbitrary.” Whether or not this is a compelling
argument for considering “all quantities equal”, this statement is, at
least on a formal level, largely true, at least in the case where
variables mutually determine one another. As stated at the conclusion of
Appendix II in <span class="citation">Mesarović and Takahara (<a href="#ref-alma99267312205899" role="doc-biblioref">1975</a>)</span>,</p>
<blockquote>
<p>The starting point for any modeling is the observations and the
assumption about the existence of relationships between them. The
primary concept of a system ought to be definable just with that much
data. Whether such a relationship can be described as a transition in a
state space is a point that needs to be proven. Even if this is
possible, <em>a state space is not unique, which indicates the secondary
nature of the concept of state</em> [emphasis mine].</p>
</blockquote>
<p>Here, the authors are presumably using <em>state</em> in the less
comprehensive sense, where it is distinguished from system inputs and
outputs, though conceivably they could simply mean that which attributes
we choose to observe and codify into a notion of <em>state</em> is not
unique; but for the sake of argument, we’ll assume they mean at least
the former.</p>
<p>(But the authors, in fact, hint at an altogether different view of
what is meant by the state of a system. In this view, everything that
can be observed about a system is encompassed by the system’s inputs and
outputs: the system is essentially a black box, and how it responds to
given inputs at any particular time is not always the same. This is
because some unobservable aspects of the system come into play. These
unobservables constitute the <em>state</em> of the system, and how it
responds at any given time to given inputs depends on what
<em>state</em> it happens to be in. A helpful analogy here might be the
notion of a person’s <em>state of mind</em> as a determinant of how they
might react to a particular event.)</p>
<p>However expansive we choose to make our notion of <em>state</em>, one
thing is clear: if we choose to regard the parameters, drivers, and the
relationship between quantities embodied in the direct modules as
constraints on the state space of our systems, then <em>given</em> that
a state lies in this state space, we can fully specify the state using
only the values of the so-called <em>differential</em> variables (plus
time); the values of all of the other quantities can be determined from
these. Thus, if the total number of quantites in the system (including
time) is <span class="math inline">\(n\)</span>, and the number of
differential variables is <span class="math inline">\(k\)</span>, then
the state space may be viewed as a <span class="math inline">\(k+1\)</span>-dimensional manifold embedded in
Euclidean <span class="math inline">\(n\)</span>-space <span class="math inline">\(\mathbf{R}^n\)</span>. Put another way, no matter
how many variables we use to describe the state of the system, there are
still only <span class="math inline">\(k+1\)</span> degrees of freedom:
the parameters can only take one value, the time variable determines the
values of all the driver variables, and the values of these together
with the values of the differential variables determine the values of
the remaining variables, the direct variables.</p>
<p>An analogy may help make this clearer: Say we wish to consider all
points on earth. If we don’t limit ourselves to points on the surface,
then we could specify such points with three coordinates—longitude,
latitude, and altitude. Large values of <em>altitude</em> will
correspond to points above the earth’s surface, and negative values will
usually correspond to points in the earth’s interior. We are considering
arbitrary points in a three-dimensional space, and so it makes sense
that we need all three coordinates to fully specify such a point.</p>
<p>But suppose we now say that we only want to consider points on the
earth’s surface. Given this constraint, this understanding that we are
only going to try to describe points on the surface of the earth, we can
get by with only two coordinates: we need only specify the longitude and
the latitude. We <em>could</em> include the third number, the altitude,
as well (provided we know it), but it is now not necessary, because it
is understood that the point lies on the earth’s surface. If we consider
a system whose <em>state</em> comprises the location of some given
object on the surface of the earth, then the state space <em>is</em>
that surface, a two-dimensional space embedded in Euclidean 3-space.</p>
<p>Note that in this example, it matters which two coordinates we choose
for describing states. Generally, it will not, for example, suffice to
know only the altitude and the longitude, since, given some choice of
altitude and longitude, there may be many points of various latitudes
that match. (There are exceptional cases, of course: if we specify the
altitude as 8848.86 (meters), even without having specified a longitude
or latitude (let alone both), we know the object is at the top of Mount
Everest.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;Here, we are using &lt;em&gt;altitude&lt;/em&gt; to mean “height
above sea level”, or what is, for points on the earth’s surface, usually
called &lt;em&gt;elevation&lt;/em&gt;.&lt;/p&gt;"><sup>13</sup></a>)</p>
</div>
</div>
<div class="section level3">
<h3 id="modularization-in-biocro">Modularization in BioCro <a class="anchor" aria-label="anchor" href="#modularization-in-biocro"></a>
</h3>
<p>As mentioned in Section <span class="math inline">\(\ref{sec:BioCro_systems}\)</span>, any BioCro
system can be replaced by an equivalent system using only a single
module of each type. We merely have to write one direct module and one
differential module, where each (respectively) combines the effects of
all the individual direct and differential modules that were used in the
original system.</p>
<p>We use “merely” advisedly here, because one of the main strengths of
BioCro is the ability to modularize, so that once we have a wide
repertoire of modules to choose from, we can choose and combine them in
whatever way is useful, without having to write a new module each time
we want to tweak some aspect of the system as a whole.</p>
<p>In this section, we look at this combining of modules on a formal
level, delineating the requirements for using two or more modules in
place of one and the effects of doing so. We start with the differential
module case since it is the simpler of the two.</p>
<div class="section level4">
<h4 id="modularization-of-the-derivative-function">Modularization of the derivative function<a class="anchor" aria-label="anchor" href="#modularization-of-the-derivative-function"></a>
</h4>
<p>As mentioned in Section <span class="math inline">\(\ref{sec:BioCro_systems}\)</span>, when a BioCro
system uses only a single differential module, that module corresponds
to the function <span class="math inline">\(\mathbf{f}\)</span> in
Khalil state equation <span class="math inline">\(\eqref{eq:BioCro_state_equation}\)</span>. We
shall henceforth refer to <span class="math inline">\(\mathbf{f}\)</span> as the <em>derivative</em>
function for the system.</p>
<p>As it turns out, in BioCro, the derivative function never depends on
<span class="math inline">\(t\)</span> directly; if there is any
temporal dependence in function <span class="math inline">\(\mathbf{f}\)</span>, it is always via some driver
variable or differential variable. (Recall that <span class="math inline">\(t\)</span> represents the elapsed time in a BioCro
system; although some calculations may depend on the time of year or the
time of day, they do not depend on the elapsed time.) Therefore, we can
rewrite equation <span class="math inline">\(\eqref{eq:BioCro_state_equation}\)</span> as
<!-- (no par break) --> <span class="math display">\[\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(\mathbf{x}, \mathbf{k}, \mathbf{d},
\mathbf{w}).
\end{equation}\]</span> <!-- (no par break) --> Thus, <span class="math inline">\(\mathbf{f}:
\mathbf{X}\times\mathbf{K}\times\mathbf{D}\times\mathbf{W}\to\mathbf{X}\)</span>.
From here on out, we shall adopt BioCro’s notion of state space and
denote it as <span class="math inline">\(\mathbf{S}\)</span>, so that
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \mathbf{S} =
\mathbf{X}\times\mathbf{K}\times\mathbf{D}\times\mathbf{W}.
\end{equation*}\]</span> <!-- (no par break) --> <span class="math inline">\(\mathbf{f}\)</span> is then a function <span class="math inline">\(\mathbf{f}: \mathbf{S} \to \mathbf{X}\)</span>,
and the state equation, which we shall now refer to as the
<em>derivative</em> equation, is just <!-- (no par break) --> <span class="math display">\[\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(\mathbf{s}),
\end{equation}\]</span> <!-- (no par break) --> where <span class="math inline">\(\mathbf{s}\)</span> denotes a state in the state
space <span class="math inline">\(\mathbf{S}\)</span>.</p>
<p>In general, we can write any state <span class="math inline">\(\mathbf{s}\)</span> in terms of the coordinate
variables describing each of the component spaces; that is,
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \mathbf{s} = (x_0, x_1, \dots, x_{n-1}, k_0, k_1, \dots,
               k_{q-1}, d_0, d_1, \dots, d_{r-1}, w_0, w_1, \dots,
w_{s-1})
\end{equation*}\]</span> <!-- (no par break) --> where <span class="math inline">\(n\)</span>, <span class="math inline">\(q\)</span>, <span class="math inline">\(r\)</span>, and <span class="math inline">\(s\)</span> are the dimensions of the component
spaces <span class="math inline">\(\mathbf{X}\)</span>, <span class="math inline">\(\mathbf{K}\)</span>, <span class="math inline">\(\mathbf{D}\)</span>, and <span class="math inline">\(\mathbf{W}\)</span>, respectively.</p>
<p>Before we talk about decomposing the derivative function of a system,
we will first describe what we mean by a valid differential module for a
BioCro system.</p>
<p>Let <span class="math inline">\(X = \{x_0, x_1, \dots,
x_{n-1}\}\)</span> be the set of differential variables of the system,
and let <!-- (no par break) --> <span class="math display">\[\begin{equation*}
    S = \{x_0, x_1, \dots, x_{n-1}, k_0, k_1, \dots, k_{q-1},
          d_0, d_1, \dots, d_{r-1}, w_0, w_1, \dots, w_{s-1}\}
\end{equation*}\]</span> <!-- (no par break) --> be the set of
<em>all</em> the coordinate variables needed to specify a state in the
state space of the system. Then <span class="math inline">\(\mathcal{M}\)</span> is a valid differential
module for the system if the input variables are contained in <span class="math inline">\(S\)</span> and the output variables are contained
in <span class="math inline">\(X\)</span>.</p>
<p>Let <span class="math inline">\(\mathbf{M}_\text{in}\)</span> be the
vector subspace of <span class="math inline">\(\mathbf{S}\)</span>
generated by the input variables of <span class="math inline">\(\mathcal{M}\)</span> and let <span class="math inline">\(\mathbf{M}_\text{out}\)</span> be the vector
subspace of <span class="math inline">\(\mathbf{X}\)</span> generated by
the output variables of <span class="math inline">\(\mathcal{M}\)</span>. Then the <em>derivative
function</em> for <span class="math inline">\(\mathcal{M}\)</span> is
some function <!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \hat{\mathbf{f}}_\mathbf{M}: \mathbf{M}_\text{in} \to
\mathbf{M}_\text{out}.
\end{equation*}\]</span> <!-- (no par break) --> To each such function,
we may associate a unique function <span class="math inline">\(\mathbf{f}_\mathbf{M}: \mathbf{S} \to
\mathbf{X}\)</span> as follows:</p>
<p>Let <span class="math inline">\(\pmb{\pi}\)</span> be the projection
of <span class="math inline">\(\mathbf{S}\)</span> onto <span class="math inline">\(\mathbf{M}_\text{in}\)</span>, and let <span class="math inline">\(\pmb{\iota}\)</span> be the injective function of
<span class="math inline">\(\mathbf{M}_\text{out}\)</span> into <span class="math inline">\(\mathbf{X}\)</span> that assigns each coordinate
in <span class="math inline">\(X\)</span> that is not an output variable
of <span class="math inline">\(\mathcal{M}\)</span> the value zero. Then
we define <!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \mathbf{f}_\mathbf{M} = \pmb{\iota} \circ
\hat{\mathbf{f}}_\mathbf{M} \circ \pmb{\pi}:
        \mathbf{S} \stackrel{\pmb{\pi}}{\to} \mathbf{M}_\text{in}
               \stackrel{\hat{\mathbf{f}}_\mathbf{M}}{\longrightarrow}
\mathbf{M}_\text{out}
               \stackrel{\pmb{\iota}}{\to} \mathbf{X}.
\end{equation*}\]</span> <!-- (no par break) --> We shall call the
function <span class="math inline">\(\mathbf{f}_\mathbf{M}\)</span> the
<em>system-complete derivative function for <span class="math inline">\(\mathcal{M}\)</span></em>.</p>
<p>Now suppose we have a collection <span class="math inline">\(\{\mathcal{M}_1, \mathcal{M}_2, \dots,
\mathcal{M}_m\}\)</span> of differential modules assumed to be
consistent with (the rest of) our system, and let <span class="math inline">\(\{\mathbf{f}_\mathbf{M_1},
\mathbf{f}_\mathbf{M_1}, \dots, \mathbf{f}_\mathbf{M_m}\}\)</span> be
their corresponding system-complete derivative functions. Then the
<em>combined derivative function</em> for <span class="math inline">\(\{\mathcal{M}_1, \mathcal{M}_2, \dots,
\mathcal{M}_m\}\)</span> is the function <!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \mathbf{f} = \sum_{i\in \{1, 2, \dots, m\}} \mathbf{f}_\mathbf{M_i},
\end{equation*}\]</span> <!-- (no par break) --> defined by the rule</p>
<p><span class="math display">\[\begin{equation*}
    \mathbf{s} \mapsto \sum_{i\in \{1, 2, \dots, m\}}
\mathbf{f}_\mathbf{M_i}(\mathbf{s}).
\end{equation*}\]</span> <!-- (no par break) --> If <span class="math inline">\(\{\mathcal{M}_1, \mathcal{M}_2, \dots,
\mathcal{M}_m\}\)</span> comprise the differential modules for a system,
then <span class="math inline">\(\mathbf{f}\)</span> is that system’s
derivative function.</p>
<p>In other words, the outputs from each individual differential module
are treated as terms that must be added together to form the full
derivative. For each module, the system-complete derivative function as
defined above calculates the values of some elements of <span class="math inline">\(X\)</span>, setting the rest to 0. Then, the
output from each system-complete derivative function can be added
together to form the full derivative. This is the operation performed by
the combined derivative function.</p>
<p>We could always write a single differential module <span class="math inline">\(\mathcal{M}\)</span> that has <span class="math inline">\(\mathbf{f}\)</span> as its system-complete
derivative function and then use it in place of the collection of
modules <span class="math inline">\(\{\mathcal{M}_1, \mathcal{M}_2,
\dots, \mathcal{M}_m\}\)</span> in any system that uses them. But this
module will likely combine several mechanistic bio-systems concepts, and
one of the strengths of BioCro is the ability to tweak one mechanistic
model without having to rewrite multiple modules that might use it.</p>
</div>
<div class="section level4">
<h4 id="decomposing-the-direct-module-function">Decomposing the direct module function<a class="anchor" aria-label="anchor" href="#decomposing-the-direct-module-function"></a>
</h4>
<p>Let <span class="math inline">\(\mathcal{S}\)</span> be a BioCro
system, and let <span class="math inline">\(\mathbf{S} =
\mathbf{X}\times\mathbf{K}\times\mathbf{D} \times \mathbf{W}\)</span> be
the state space of <span class="math inline">\(\mathcal{S}\)</span>. As
mentioned in Section <span class="math inline">\(\ref{sec:BioCro_systems}\)</span>, the direct
module component of a BioCro system <span class="math inline">\(\mathcal{S}\)</span> corresponds to a function
<!-- (no par break) --> <span class="math display">\[\begin{equation}
    \gamma^\mathbf{W}: \mathbf{X}\times\mathbf{K}\times\mathbf{D} \to
\mathbf{W} \label{eq:dir_mod_component_fn}
\end{equation}\]</span> <!-- (no par break) --> that determines the
value of the “direct variable” component of a state from the value of
the other components. For convenience in what follows, we shall write
<span class="math inline">\(\mathbf{H}\)</span> to abbreviate the cross
product <span class="math inline">\(\mathbf{X}\times\mathbf{K}\times\mathbf{D}\)</span>.
Thus we may write <span class="math inline">\(\eqref{eq:dir_mod_component_fn}\)</span> as
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \gamma^\mathbf{W}: \mathbf{H} \to \mathbf{W}.
\end{equation*}\]</span></p>
<p>In general, however, the direct module component of a system will be
subdivided into two or more submodules. In this section, we will show
that the <em>ordered sum</em> of two modules (a notion defined below) is
itself a module; this is the key to understanding how to modularize the
direct module function.</p>
<p>As mentioned in Section <span class="math inline">\(\ref{sec:BioCro_systems}\)</span>, when a system
has more than one direct module, each constituent module <span class="math inline">\(\mathcal{M}_i\)</span> corresponds to a function
<!-- (no par break) --> <span class="math display">\[\begin{equation}
  \gamma^{\mathbf{W}_i}:
\mathbf{X}\times\mathbf{K}\times\mathbf{D}\times\mathbf{\overline{W}}_i
\to \mathbf{W}_i,
\end{equation}\]</span> <!-- (no par break) --> or, using the
abbreviation used above, <!-- (no par break) --> <span class="math display">\[\begin{equation}
  \gamma^{\mathbf{W}_i}: \mathbf{H}\times\mathbf{\overline{W}}_i \to
\mathbf{W}_i. \label{eq:dir_mod_fn}
\end{equation}\]</span></p>
<p>Letting <span class="math inline">\(H\)</span> denote the set of
variables corresponding to <span class="math inline">\(\mathbf{H}\)</span> and denoting the input and
output variables of module <span class="math inline">\(\mathcal{M}_i\)</span> as <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i\)</span>
and <span class="math inline">\(\operatorname{\mathbf{Out}}\mathcal{M}_i\)</span>
respectively, we can write <!-- (no par break) --> <span class="math display">\[\begin{align*}
    \mathbf{W}_i &amp;=
\mathbf{R}^{\operatorname{\mathbf{Out}}\mathcal{M}_i} \\
    \intertext{and}
    \mathbf{\overline{W}}_i &amp;=
\mathbf{R}^{\operatorname{\mathbf{In}}\mathcal{M}_i\smallsetminus H},
\end{align*}\]</span> <!-- (no par break) --> where <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i\)</span>
and <span class="math inline">\(\operatorname{\mathbf{Out}}\mathcal{M}_i\)</span>
are disjoint, since direct modules never share inputs and outputs.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;When we say that direct modules never share inputs and
outputs, we are specifically referring to direct modules used in the
construction of a dynamical system, that is, direct modules that are
members of the &lt;em&gt;set of direct modules&lt;/em&gt; mentioned at the outset in
our discussion of the BioCro model. But there do, in fact, exist
modules, also going by the name &lt;em&gt;direct module&lt;/em&gt;, that &lt;em&gt;do&lt;/em&gt;
have one or more input and output variables in common. We won’t consider
such modules here, and it what follows, we always consider only direct
modules of the former type, where the input and output sets are
disjoint.&lt;/p&gt;"><sup>14</sup></a> Note
that it may be the case that <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i\subseteq
H\)</span>; in this case <span class="math inline">\(\mathbf{\overline{W}}_i\)</span> is 0-dimensional
and <span class="math inline">\(\ref{eq:dir_mod_fn}\)</span> reduces to
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \gamma^{\mathbf{W}_i}: \mathbf{H} \to \mathbf{W}_i.
\end{equation*}\]</span></p>
<p><span class="math inline">\(H\)</span> corresponds to the union of
all the differential variables, parameters, and driver variables of the
system. Usually, it will be the case that any given direct module in a
system will not use all of the variables in <span class="math inline">\(H\)</span>: not all of the variables in <span class="math inline">\(H\)</span> will affect the value of the output,
nor will they even be listed in the list returned by the module’s
<code>get_inputs()</code> function. But they are all always
<em>potentially</em> available for use by any direct module, and in what
follows, it will be convenient to assume that the direct module inputs
include all the variables of <span class="math inline">\(H\)</span>;
that is, <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i\supseteq
H\)</span>, for all direct modules <span class="math inline">\(\mathcal{M}_i\)</span>. This way, the only thing
that changes about the domain of the module function between various
direct modules is the <span class="math inline">\(\mathbf{\overline{W}}_i\)</span> component of
<span class="math inline">\(\mathbf{H}\times\mathbf{\overline{W}}_i\)</span>.
This will simplify the exposition of what follows.</p>
<p>(To take a simple example of formal dependence versus actual
dependence, consider a two-variable function <span class="math inline">\(f(x,y)\)</span> defined by the rule <span class="math inline">\((x,y)\mapsto x^2\)</span>. Formally, this is a
function of two variables <span class="math inline">\(x\)</span> and
<span class="math inline">\(y\)</span>. But the value of the function
never actually depends on the value of <span class="math inline">\(y\)</span>.)</p>
<div class="section level5">
<h5 class="unnumbered" id="the-ordered-sum-of-two-direct-modules">The ordered sum of two direct modules<a class="anchor" aria-label="anchor" href="#the-ordered-sum-of-two-direct-modules"></a>
</h5>
<p>Suppose that <span class="math inline">\(\mathcal{M}_i\)</span> and
<span class="math inline">\(\mathcal{M}_j\)</span> are two direct
modules having disjoint sets of output variables (that is, <span class="math inline">\(\operatorname{\mathbf{Out}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset\)</span>),
and suppose also that none of the outputs of <span class="math inline">\(\mathcal{M}_j\)</span> are inputs for <span class="math inline">\(\mathcal{M}_i\)</span>; that is, <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset\)</span>.
Let <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> be their corresponding functions. For
convenience, we put <!-- (no par break) --> <span class="math display">\[\begin{align*}
    A &amp;=\operatorname{\mathbf{In}}\mathcal{M}_i \\
    B &amp;=\operatorname{\mathbf{Out}}\mathcal{M}_i \\
    C &amp;=\operatorname{\mathbf{In}}\mathcal{M}_j \\
    \intertext{and}
    D &amp;=\operatorname{\mathbf{Out}}\mathcal{M}_j,
\end{align*}\]</span> <!-- (no par break) --> so that
<!-- (no par break) --> <span class="math display">\[\begin{align*}
    f&amp;: \mathbf{R}^A \to \mathbf{R}^B \\
    \intertext{and}
    g&amp;: \mathbf{R}^C \to \mathbf{R}^D,
\end{align*}\]</span> <!-- (no par break) --> with <span class="math inline">\(A\cap B=C\cap D=A\cap D=B\cap
D=\emptyset\)</span>.</p>
<p>At this point, it is possible to see how we might combine these two
direct modules to come up with something that is itself a module; the
key is to think in terms of module inputs and outputs: Given mappings
for all values in <span class="math inline">\(A\)</span> and all values
in <span class="math inline">\(C\)</span> that aren’t in <span class="math inline">\(B\)</span>, we can obtain mappings for all values
in <span class="math inline">\(B\)</span> and <span class="math inline">\(D\)</span> as follows: Since we know all the
inputs <span class="math inline">\(A\)</span> to module <span class="math inline">\(\mathcal{M}_i\)</span>, we can use the module to
obtain all the outputs <span class="math inline">\(B\)</span>. Now we
know all the inputs <span class="math inline">\(C\)</span> to module
<span class="math inline">\(\mathcal{M}_j\)</span>—both those that
<em>aren’t</em> in <span class="math inline">\(B\)</span> (which were
given at the outset), and those that <em>are</em> in <span class="math inline">\(B\)</span> (which were obtained by applying module
<span class="math inline">\(\mathcal{M}_i\)</span>). This yields all the
outputs <span class="math inline">\(D\)</span> of module <span class="math inline">\(\mathcal{M}_j\)</span>. We can also describe this
more formally, as we now proceed to do.</p>
<p>We define <span class="math inline">\(\mathcal{M}_i +
\mathcal{M}_j\)</span>, the <em>ordered sum of <span class="math inline">\(\mathcal{M}_i\)</span> and <span class="math inline">\(\mathcal{M}_j\)</span></em>, to be the direct
module whose corresponding function <!-- (no par break) --> <span class="math display">\[\begin{equation}
    f\ast g: \mathbf{R}^{ A\cup (C\smallsetminus B)}\to\mathbf{R}^{
B\cup D} \label{eq:ordered_sum_function}
\end{equation}\]</span> <!-- (no par break) --> is defined by
<!-- (no par break) --> <span class="math display">\[\begin{equation}
    f\ast g = (f\circ\pi^{ A\cup (C\smallsetminus B)\to A})
              \cup
              (g\circ(
                \pi^{ A\cup (C\smallsetminus B)
                     \to C\smallsetminus B}
                  \cup
                (\pi^{ B\to C\cap B}\circ
                f\circ
                \pi^{ A\cup (C\smallsetminus B)\to A}))).
\label{eq:ordered_sum}
\end{equation}\]</span> <!-- (no par break) --> (Note that if <span class="math inline">\(B\cap C=\emptyset\)</span>, then <span class="math inline">\(C\smallsetminus B=C\)</span>, and <span class="math inline">\(\ref{eq:ordered_sum}\)</span> reduces to
<!-- (no par break) --> <span class="math display">\[\begin{equation}
    f\ast g = (f\circ\pi^{ A\cup C\to A})
              \cup
              (g\circ\pi^{ A\cup C \to C}).
\end{equation}\]</span> <!-- (no par break) --> In this case, the
ordering is immaterial, and <span class="math inline">\(\mathcal{M}_j+\mathcal{M}_i=\mathcal{M}_i+\mathcal{M}_j\)</span>,
with <span class="math inline">\(g\ast f=f\ast g\)</span>.)</p>
<p>Recalling that the inputs and outputs of a direct module function
must be disjoint, we can check that this is indeed the case for the sum.
First we note that whenever we can take the ordered sum of two modules
<span class="math inline">\(\mathcal{M}_i\)</span> and <span class="math inline">\(\mathcal{M}_j\)</span>, <!-- (no par break) -->
<span class="math display">\[\begin{align}
    \operatorname{\mathbf{In}}(\mathcal{M}_i+\mathcal{M}_j) &amp;=
\operatorname{\mathbf{In}}\mathcal{M}_i \cup
(\operatorname{\mathbf{In}}M_j\smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i) \label{eq:input_of_sum} \\
    \intertext{and}
    \operatorname{\mathbf{Out}}(\mathcal{M}_i+\mathcal{M}_j) &amp;=
\operatorname{\mathbf{Out}}\mathcal{M}_i\cup\operatorname{\mathbf{Out}}\mathcal{M}_j.
\label{eq:output_of_sum}
\end{align}\]</span> <!-- (no par break) --> (The fact that the set of
inputs for the ordered sum is <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i \cup
(\operatorname{\mathbf{In}}M_j\smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i)\)</span> is readily apparent
from <span class="math inline">\(\ref{eq:ordered_sum_function}\)</span>:
the domain of <span class="math inline">\(f\ast g\)</span> being <span class="math inline">\(\mathbf{R}^{ A\cup (C\smallsetminus B)}\)</span>
corresponds to the inputs for the corresponding module being <span class="math inline">\(A\cup (C\smallsetminus B)\)</span>, which is just
<span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i \cup
(\operatorname{\mathbf{In}}M_j\smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i)\)</span>. Similarly for the
outputs.)</p>
<p>Using this, we then have that <!-- (no par break) --> <span class="math display">\[\begin{alignat*}{2}
    \operatorname{\mathbf{In}}(\mathcal{M}_i+\mathcal{M}_j) \cap
\operatorname{\mathbf{Out}}(\mathcal{M}_i+\mathcal{M}_j)
&amp;=\;&amp;&amp;
        (\operatorname{\mathbf{In}}\mathcal{M}_i \cup
(\operatorname{\mathbf{In}}M_j \smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i)) \cap
        (\operatorname{\mathbf{Out}}\mathcal{M}_i \cup
\operatorname{\mathbf{Out}}\mathcal{M}_j)
            \quad \text{by \ref{eq:input_of_sum} and
\ref{eq:output_of_sum}} \\
        &amp;= &amp;&amp;(\operatorname{\mathbf{In}}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_i) \\
           &amp;&amp;&amp;        \cup
              (\operatorname{\mathbf{In}}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_j) \\
           &amp;&amp;&amp;        \cup
              ((\operatorname{\mathbf{In}}M_j \smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i) \cap
\operatorname{\mathbf{Out}}\mathcal{M}_i) \\
           &amp;&amp;&amp;        \cup
              ((\operatorname{\mathbf{In}}M_j \smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i) \cap
\operatorname{\mathbf{Out}}\mathcal{M}_j)
                 \qquad \text{by distributivity of $\cap$ over $\cup$}
\\
        &amp;= &amp;&amp;\emptyset \cup \emptyset \cup \emptyset \cup
\emptyset \\
        &amp;= &amp;&amp;\emptyset
\end{alignat*}\]</span> <!-- (no par break) --> That each of the
intersections in the distributive expansion is empty is easily verified:
<span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_i\)</span> and <span class="math inline">\((\operatorname{\mathbf{In}}M_j \smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i) \cap
\operatorname{\mathbf{Out}}\mathcal{M}_j)\)</span> are both empty as a
consequence of direct modules having non-overlapping inputs and outputs.
<span class="math inline">\((\operatorname{\mathbf{In}}M_j
\smallsetminus \operatorname{\mathbf{Out}}\mathcal{M}_i) \cap
\operatorname{\mathbf{Out}}\mathcal{M}_i\)</span> must be empty since a
member of <span class="math inline">\(\operatorname{\mathbf{In}}M_J\)</span> that is
<em>not</em> in <span class="math inline">\(\operatorname{\mathbf{Out}}\mathcal{M}_i\)</span>
can’t also be <em>in</em> <span class="math inline">\(\operatorname{\mathbf{Out}}\mathcal{M}_i\)</span>.
Finally, <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset\)</span>
was a stipulation made when defining the ordered sum of <span class="math inline">\(\mathcal{M}_i\)</span> and <span class="math inline">\(\mathcal{M}_j\)</span>.</p>
<p>Equation <span class="math inline">\(\ref{eq:ordered_sum}\)</span>
perhaps requires a little explication in order to be comprehended.</p>
<p>Suppose we are given some value <span class="math inline">\(\mathbf{x}\)</span> in <span class="math inline">\(\mathbf{R}^{ A\cup (C\smallsetminus B)}\)</span>,
the domain of <span class="math inline">\(f\ast g\)</span>. We can
describe <span class="math inline">\((f\ast
g)(\mathbf{x})\in\mathbf{R}^{ B\cup D}\)</span> by describing the way to
compute how <span class="math inline">\((f\ast g)(\mathbf{x})\)</span>
maps each <span class="math inline">\(y\in B\cup D\)</span> into <span class="math inline">\(\mathbf{R}\)</span>.</p>
<p>First suppose <span class="math inline">\(y\in B\)</span>. Then we
need only look at the first component in the union on the right-hand
side of <span class="math inline">\(\ref{eq:ordered_sum}\)</span>—namely, <span class="math inline">\(f\circ\pi^{ A\cup (C\smallsetminus B)\to
A}\)</span>. The projection <span class="math inline">\(\pi^{ A\cup
(C\smallsetminus B)\to A}(\mathbf{x}) = \mathbf{x}|A\)</span> of <span class="math inline">\(\mathbf{x}\)</span> to <span class="math inline">\(\mathbf{R}^A\)</span> tells us that we need
consider only the coordinates of <span class="math inline">\(\mathbf{x}\)</span> that correspond to members of
<span class="math inline">\(A\)</span>. Once we have a vector in <span class="math inline">\(\mathbf{R}^A\)</span>, we can apply the function
<span class="math inline">\(f\)</span> to obtain a value in <span class="math inline">\(\mathbf{R}^B\)</span>. This is all we need, since
<span class="math inline">\(y\)</span> is in <span class="math inline">\(B\)</span>.</p>
<p>Now suppose <span class="math inline">\(y\in D\)</span>. Here we need
to look at the somewhat more complicated second component of the
right-hand side of <span class="math inline">\(\ref{eq:ordered_sum}\)</span>, that is, <span class="math inline">\(g\circ(\pi^{ A\cup (C\smallsetminus B) \to
C\smallsetminus B} \cup (\pi^{ B\to C\cap B}\circ f\circ \pi^{ A\cup
(C\smallsetminus B)\to A}))\)</span>. Since <span class="math inline">\(g: \mathbf{R}^C\to\mathbf{R}^D\)</span>, we need
to feed <span class="math inline">\(g\)</span> some value in <span class="math inline">\(\mathbf{R}^C\)</span> to obtain a mapping to <span class="math inline">\(\mathbf{R}\)</span> of values (such as <span class="math inline">\(y\)</span>) in <span class="math inline">\(D\)</span>. But <span class="math inline">\(\mathbf{x}\)</span> is in <span class="math inline">\(\mathbf{R}^{A\cup(C\smallsetminus B)}\)</span>, so
<span class="math inline">\(\mathbf{x}\)</span> only tells how values in
<span class="math inline">\(C\)</span> that aren’t also in <span class="math inline">\(B\)</span> are mapped. The mapping for these
values corresponds to the projection <span class="math inline">\(\pi^{
A\cup (C\smallsetminus B) \to C\smallsetminus B}(\mathbf{x}) =
\mathbf{x}|(C\smallsetminus B)\)</span>, a value in <span class="math inline">\(\mathbf{R}^{C\smallsetminus B}\)</span>. To find
the portion of the mapping we need that belongs to <span class="math inline">\(\mathbf{R}^{C\cap B}\)</span>, we look at <span class="math inline">\(\pi^{ B\to C\cap B}\circ f\circ \pi^{ A\cup
(C\smallsetminus B)\to A}\)</span>. As we have just seen, <span class="math inline">\(f\circ \pi^{ A\cup (C\smallsetminus B)\to
A}\)</span> maps <span class="math inline">\(\mathbf{x}\)</span> to a
member of <span class="math inline">\(\mathbf{R}^B\)</span>. Then we can
apply the projection <span class="math inline">\(\pi^{ B\to C\cap
B}\)</span> to obtain a member of <span class="math inline">\(\mathbf{R}^{C\cap B}\)</span>. Taking the union of
the components in <span class="math inline">\(\mathbf{R}^{C\smallsetminus B}\)</span> and <span class="math inline">\(\mathbf{R}^{C\cap B}\)</span> gives us a value in
<span class="math inline">\(\mathbf{R}^C\)</span>, to which we can apply
function <span class="math inline">\(g\)</span>. The result is a
function in <span class="math inline">\(\mathbf{R}^D\)</span> telling
how all values (such as <span class="math inline">\(y\)</span>) in <span class="math inline">\(D\)</span> are mapped.</p>
</div>
<div class="section level5">
<h5 class="unnumbered" id="general-ordered-sum">General ordered sum<a class="anchor" aria-label="anchor" href="#general-ordered-sum"></a>
</h5>
<p>We now generalize the notion of an ordered sum of two direct modules
to the ordered sum of any finite number of direct modules.</p>
<p>Suppose we have an ordered collection <span class="math inline">\((\mathcal{M}_1, \mathcal{M}_2, \dots,
\mathcal{M}_n)\)</span> of direct modules. As is the case with all
direct modules, <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_i=\emptyset\)</span>
for all <span class="math inline">\(i\)</span>. Further, assume that
<span class="math inline">\(\operatorname{\mathbf{Out}}\mathcal{M}_i\cup\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset\)</span>
for all <span class="math inline">\(i\neq j\)</span>, and that <span class="math inline">\(\operatorname{\mathbf{In}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset\)</span>
whenever <span class="math inline">\(i&lt;j\)</span>. Then we define the
ordered sum <span class="math inline">\(\sum_{i=1}^n\mathcal{M}_i\)</span> recursively as
follows: <!-- (no par break) --> <span class="math display">\[\begin{alignat}{2}
    \sum_{i=1}^k\mathcal{M}_i &amp;= M_1 &amp;&amp; \qquad\text{for
$k=1$} \notag \\
    \sum_{i=1}^k\mathcal{M}_i &amp;= \sum_{i=1}^{k-1}\mathcal{M}_i
                        + \mathcal{M}_k &amp;&amp; \qquad
                        \text{for $1&lt;k\leq
n$}\label{eq:recursive_module_sum}
\end{alignat}\]</span></p>
<p>Things are not quite as simple as this, however, since we must show
that the ordered sum given on the right-hand side of <span class="math inline">\(\ref{eq:recursive_module_sum}\)</span> is always
defined. Specifically, we must show that <!-- (no par break) --> <span class="math display">\[\begin{align}
    \operatorname{\mathbf{Out}}\sum_{i=1}^{k-1}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_k &amp;= \emptyset
        \label{eq:general_sum_disjoint_outputs} \\
\intertext{and}
    \operatorname{\mathbf{In}}\sum_{i=1}^{k-1}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_k &amp;= \emptyset.
\label{eq:general_sum_general_condition}
\end{align}\]</span></p>
<p>But it easily follows by induction from equation <span class="math inline">\(\ref{eq:output_of_sum}\)</span> that
<!-- (no par break) --> <span class="math display">\[\begin{equation*}
    \operatorname{\mathbf{Out}}\sum_{i=1}^{k-1}\mathcal{M}_i =
\bigcup_{i=1}^{k-1}\operatorname{\mathbf{Out}}\mathcal{M}_i,
\end{equation*}\]</span> <!-- (no par break) --> and <span class="math inline">\(\ref{eq:general_sum_disjoint_outputs}\)</span>
easily follows from this, the distributivity of <span class="math inline">\(\cap\)</span> over <span class="math inline">\(\cup\)</span>, and the assumption that the outputs
of the modules are pairwise disjoint.</p>
<p>To prove <span class="math inline">\(\ref{eq:general_sum_general_condition}\)</span>,
we first observe that it follows immediately from <span class="math inline">\(\ref{eq:input_of_sum}\)</span> that <span class="math inline">\(\operatorname{\mathbf{In}}(\mathcal{M}_i+\mathcal{M}_j)
\subseteq \operatorname{\mathbf{In}}\mathcal{M}_i \cup
\operatorname{\mathbf{In}}M_j\)</span>, and from this it is easy to show
by induction that <!-- (no par break) --> <span class="math display">\[\begin{equation}
    \operatorname{\mathbf{In}}\sum_{i=1}^{k-1}\mathcal{M}_i \subseteq
\bigcup_{i=1}^{k-1}\operatorname{\mathbf{In}}\mathcal{M}_i.
\end{equation}\]</span> <!-- (no par break) --> Since a stipulation in
defining the ordered sum of modules was that output of each module in
the ordered collection is disjoint from the inputs of each module
occuring earlier in the ordering, in light of the distributivity of
<span class="math inline">\(\cap\)</span> over <span class="math inline">\(\cup\)</span>, the desired result <span class="math inline">\(\ref{eq:general_sum_general_condition}\)</span>
immediately follows.</p>
<!-- Don't number any sections or subsections from here on out. -->
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="appendix-degenerate-biocro-systems">Appendix: Degenerate BioCro systems<a class="anchor" aria-label="anchor" href="#appendix-degenerate-biocro-systems"></a>
</h2>
<p>This appendix is meant to demonstrate certain edge cases and
“off-label” uses of BioCro systems. All of these systems are set up
using the R interface. A similar set of systems that use the C++ library
directly could be written in C++.</p>
<div class="section level3">
<h3 id="a-minimal-system">A minimal system<a class="anchor" aria-label="anchor" href="#a-minimal-system"></a>
</h3>
<p>This system contains the absolute minimum number of quantities. Since
it has only a single time point, <code>timestep</code> is present only
to satisfy a formal requirement of the validity checker; it is otherwise
meaningless.</p>
<p>A formal requirement of the R interface (but not of the C++
interface) is that the set of driver variables either contains
<code>time</code> or contains both <code>doy</code> and
<code>hour</code>. All three variables show up in the output.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/ebimodeling/biocro" class="external-link">BioCro</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>, drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>time<span class="op">=</span><span class="fl">45.625</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   doy hour ncalls   time</span></span>
<span><span class="co">## 1  45   15      1 45.625</span></span></code></pre>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>, drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>doy<span class="op">=</span><span class="fl">80</span>, hour<span class="op">=</span><span class="fl">14.25</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   doy  hour ncalls     time</span></span>
<span><span class="co">## 1  80 14.25      1 80.59375</span></span></code></pre>
<p>Note that <code>ncalls</code> always shows up in the output data
frame, even though it is constant and even though it is not a system
variable.</p>
<p>Note also that if <code>time</code> is a driver, it dominates:
<code>doy</code> and <code>hour</code> (if present) are overwritten. If
<code>time</code> is not present, both <code>doy</code> and
<code>hour</code> must be; if only one is, we get obscure error:</p>
<pre><code>  Error in floor(result$time) :
    non-numeric argument to mathematical function</code></pre>
</div>
<div class="section level3">
<h3 id="a-system-having-a-differential-variable-but-no-differential-module">A system having a differential variable but no differential
module<a class="anchor" aria-label="anchor" href="#a-system-having-a-differential-variable-but-no-differential-module"></a>
</h3>
<p>As noted in Section <span class="math inline">\(\ref{sec:BioCro_systems}\)</span>, it is the
<code>initial_values</code> parameter that determines which variables
are differential variables. Usually, each differential variable will be
an output of one or more differential modules, but this is not required.
Differential variables that are <em>not</em> in the output of any
differential module are assumed to have a derivative of zero; that is,
they are constant. This system exhibits such a case.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>initial_values <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">52</span><span class="op">)</span>,</span>
<span>           parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>           drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>time<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   doy hour ncalls time  x</span></span>
<span><span class="co">## 1   0    0      5    0 52</span></span>
<span><span class="co">## 2   1    0      5    1 52</span></span>
<span><span class="co">## 3   2    0      5    2 52</span></span>
<span><span class="co">## 4   3    0      5    3 52</span></span>
<span><span class="co">## 5   4    0      5    4 52</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="an-off-label-use-of-run_biocro">An <em>off-label</em> use of <code>run_biocro</code><a class="anchor" aria-label="anchor" href="#an-off-label-use-of-run_biocro"></a>
</h3>
<p>Here is an example of what might be called an “off-label” use of a
BioCro system. This system really doesn’t deserve to be called a
dynamical system at all. Although the <em>drivers</em> parameter
contains five rows of temporal and spacial data (each row specifies a
time and a place), the rows have no inherent relationship to one
another: they do not represent any sort of evolution of a system over
time. The times specified by the rows aren’t even in chronological
order: although the <code>timestep</code> variable is <em>supposed</em>
to indicate the temporal relationship between successive rows of the
<code>drivers</code> parameter value, this is a convention only, and it
is not enforced.</p>
<p>Nevertheless, this system is useful: it uses the
<code>BioCro:solar_position_michalsky</code> module to compute the
cosine of the zenith angle of the sun at noon in various terrestrial
locations on various days of the year. We could have gotten the same
information using five calls to <code>run_biocro</code> with drivers
having a single row, but doing it in one call is more convenient.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                     drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>doy <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">355</span>, <span class="fl">172</span>, <span class="fl">80</span>, <span class="fl">80</span>, <span class="fl">80</span><span class="op">)</span>,</span>
<span>                                          hour <span class="op">=</span> <span class="fl">12</span>,</span>
<span>                                          time_zone_offset <span class="op">=</span> <span class="op">-</span><span class="fl">6</span>,</span>
<span>                                          year <span class="op">=</span> <span class="fl">2022</span>,</span>
<span>                                          lat <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">40</span>, <span class="fl">40</span>, <span class="fl">40</span>, <span class="fl">0</span>, <span class="fl">89</span><span class="op">)</span>,</span>
<span>                                          longitude <span class="op">=</span> <span class="op">-</span><span class="fl">88</span><span class="op">)</span>,</span>
<span>                     direct_module_names <span class="op">=</span> <span class="st">'BioCro:solar_position_michalsky'</span><span class="op">)</span></span>
<span><span class="va">result</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'lat'</span>, <span class="st">'longitude'</span>, <span class="st">'doy'</span>, <span class="st">'hour'</span>, <span class="st">'cosine_zenith_angle'</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##   lat longitude doy hour cosine_zenith_angle</span></span>
<span><span class="co">## 1  40       -88 355   12          0.44655908</span></span>
<span><span class="co">## 2  40       -88 172   12          0.95824629</span></span>
<span><span class="co">## 3  40       -88  80   12          0.77093280</span></span>
<span><span class="co">## 4   0       -88  80   12          0.99996308</span></span>
<span><span class="co">## 5  89       -88  80   12          0.02509952</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="a-system-having-only-drivers-and-the-obligatory-timestep-parameter">A system having only drivers (and the obligatory
<code>timestep</code> parameter)<a class="anchor" aria-label="anchor" href="#a-system-having-only-drivers-and-the-obligatory-timestep-parameter"></a>
</h3>
<p>Like the minimal system shown in the first example, this system has
no differential variables and no modules. But the drivers include some
driver variables that aren’t time related. Like all systems not having
any modules, it doesn’t really <em>do</em> anything.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                     drivers <span class="op">=</span> <span class="va">weather</span><span class="op">$</span><span class="va">`2005`</span><span class="op">[</span><span class="fl">1000</span><span class="op">:</span><span class="fl">1010</span>,<span class="op">]</span><span class="op">)</span></span>
<span><span class="va">result</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'year'</span>, <span class="st">'doy'</span>, <span class="st">'hour'</span>, <span class="st">'precip'</span>, <span class="st">'rh'</span>, <span class="st">'solar'</span>, <span class="st">'temp'</span>, <span class="st">'windspeed'</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##    year doy hour     precip      rh   solar  temp windspeed</span></span>
<span><span class="co">## 1  2005  42   15 0.01058333 0.73690 755.964 4.530     7.475</span></span>
<span><span class="co">## 2  2005  42   16 0.01058333 0.70095 421.429 5.085     7.445</span></span>
<span><span class="co">## 3  2005  42   17 0.01058333 0.73080 101.775 4.375     5.935</span></span>
<span><span class="co">## 4  2005  42   18 0.01058333 0.80135   1.081 2.465     4.785</span></span>
<span><span class="co">## 5  2005  42   19 0.01058333 0.83150   0.345 1.650     4.115</span></span>
<span><span class="co">## 6  2005  42   20 0.01058333 0.84020   0.299 1.210     3.565</span></span>
<span><span class="co">## 7  2005  42   21 0.01058333 0.87250   0.115 0.635     3.255</span></span>
<span><span class="co">## 8  2005  42   22 0.01058333 0.86045   0.184 0.550     3.760</span></span>
<span><span class="co">## 9  2005  42   23 0.01058333 0.84600   0.138 0.890     4.815</span></span>
<span><span class="co">## 10 2005  43    0 0.00000000 0.82435   0.138 1.250     4.955</span></span>
<span><span class="co">## 11 2005  43    1 0.00000000 0.83260   0.414 1.025     5.675</span></span></code></pre>
<p>The weather information this run displays could just as easily be
displayed using</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">weather</span><span class="op">$</span><span class="va">`2005`</span><span class="op">[</span><span class="fl">1000</span><span class="op">:</span><span class="fl">1010</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'year'</span>, <span class="st">'doy'</span>, <span class="st">'hour'</span>, <span class="st">'precip'</span>, <span class="st">'rh'</span>, <span class="st">'solar'</span>, <span class="st">'temp'</span>, <span class="st">'windspeed'</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<!-- footnotes -->
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-alma99954905266605899" class="csl-entry">
Barreira, Luís. 2019. <em>Dynamical Systems by Example</em>. 1st ed.
2019. Problem Books in Mathematics. Cham: Springer International
Publishing.
</div>
<div id="ref-alma99954908866305899" class="csl-entry">
Dale, Andrew I. 1995. <em>Philosophical Essay on Probabilities /
<span>P</span>ierre-<span>S</span>imon <span>L</span>aplace</em>. 1st
ed. 1995. Sources in the History of Mathematics and Physical Sciences;
13. New York: Springer.
</div>
<div id="ref-alma99496872912205899" class="csl-entry">
Deutsch, Andreas. 2005. <em>Cellular Automaton Modeling of Biological
Pattern Formation: Characterization, Applications, and Analysis</em>.
Modeling and Simulation in Science, Engineering and Technology. Boston:
Birkhäuser.
</div>
<div id="ref-Giunti1997-GIUCDS" class="csl-entry">
Giunti, Marco. 1997. <em>Computation, Dynamics, and Cognition</em>.
Oxford University Press.
</div>
<div id="ref-Giunti&amp;Mazzola" class="csl-entry">
Giunti, Marco, and Claudio Mazzola. 2012. <span>“Dynamical Systems on
Monoids: Toward a General Theory of Deterministic Systems and
Motion.”</span> In <em>Methods, Models, Simulations &amp; Approaches
Towards A General Theory of Change - Proceedings of the Fifth National
Conference of the Italian Systems Society</em>, 173–85. <a href="https://www.researchgate.net/publication/272943599_Dynamical_Systems_on_Monoids_Toward_a_General_Theory_of_Deterministic_Systems_and_Motion" class="external-link">https://www.researchgate.net/publication/272943599_Dynamical_Systems_on_Monoids_Toward_a_General_Theory_of_Deterministic_Systems_and_Motion</a>.
</div>
<div id="ref-alma99454477012205899" class="csl-entry">
Khalil, Hassan K. 2002. <em>Nonlinear Systems</em>. 3rd ed. Upper Saddle
River, N.J: Prentice Hall.
</div>
<div id="ref-10.1093/insilicoplants/diac003" class="csl-entry">
Lochocki, Edward B., Scott Rohde, Deepak Jaiswal, Megan L. Matthews,
Fernando Miguez, Stephen P. Long, and Justin M. McGrath. 2022.
<span>“BioCro II: A Software Package for Modular Crop Growth
Simulations.”</span> <em>In Silico Plants</em> 4 (1). <a href="https://doi.org/10.1093/insilicoplants/diac003" class="external-link">https://doi.org/10.1093/insilicoplants/diac003</a>.
</div>
<div id="ref-alma99267312205899" class="csl-entry">
Mesarović, Mihajlo D., and Yasuhiko Takahara. 1975. <em>General Systems
Theory: Mathematical Foundations</em>. Mathematics in Science and
Engineering, v. 113. New York: Academic Press.
</div>
<div id="ref-vaught" class="csl-entry">
Vaught, Robert L. 1985. <em>Set Theory: An Introduction</em>. Boston:
Birkhäuser.
</div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Justin M. McGrath, Edward B. Lochocki, Scott Rohde, Deepak Jaiswal, Megan L. Matthews, Fernando E. Miguez, Stephen P. Long.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
