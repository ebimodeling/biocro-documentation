[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 BioCro authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/about_pkgdown_documentation.html","id":null,"dir":"","previous_headings":"","what":"About this documentation","title":"About this documentation","text":"document generated version BioCro specified follows: Commit Hash: 7d1ca55 Commit Date: Wed, 25 Oct 2023 21:12:41 -0500 Branch: merge-resolution Generation Date Time: Thu Oct 26 02:49:12 UTC 2023","code":""},{"path":"/articles/BioCro-II_Paper--Section-1.1-example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"BioCro II Paper: Section 1.1 Example","text":"demonstration example discussed Section 1.1 Appendix 1 BioCro II paper (Lochocki et al. 2022). corrections clarifications exposition given paper given comments .","code":""},{"path":"/articles/BioCro-II_Paper--Section-1.1-example.html","id":"the-code","dir":"Articles","previous_headings":"","what":"The Code","title":"BioCro II Paper: Section 1.1 Example","text":"","code":"library(BioCro) library(lattice) library(knitr) # for kable(), which yields nicer-looking tables  ## customized version of kable with defined options: columns_to_print <- c('time', 'Q', 'mass_gain', 'Root', 'Leaf') show_row_number <- FALSE format <- list(scientific = FALSE, digits = 7) cable <- function(x, ...) {    kable(x[, columns_to_print],          row.names = show_row_number,          format.args = format,          ...) }  ## Set plotting character globally trellis.par.set(\"plot.symbol\", list(pch = '.'))  ################################################################################  parameters <- list(     alpha_rue = 0.07, # kg / mol     SLA = 25,         # m^2 / kg     C_conv = 0.03,    # kg / mol     f_leaf = 0.2,     # kg / kg     f_root = 0.8,     # kg / kg     timestep = 1      # s )  initial_values <- list(     Leaf = 1, # kg     Root = 1  # kg )  Q <- function(time) sin(time/3600/12 * pi) * 2000e-6 # mol / m^2 / s  times <- 0:(3600 * 12) # seconds  light_intensity <- data.frame(     time = times,     Q = Q(times) )  result <- run_biocro(     initial_values,     parameters,     light_intensity,     'BioCro:example_model_mass_gain',     'BioCro:example_model_partitioning' )  xyplot(Q ~ time, data = result, xlab = \"time (s)\", ylab = \"Q (mol / m^2 / s)\")  xyplot(Leaf ~ time, data = result, xlab = \"time (s)\", ylab = \"Leaf (kg)\")"},{"path":[]},{"path":"/articles/BioCro-II_Paper--Section-1.1-example.html","id":"the-formula-for-the-driver","dir":"Articles","previous_headings":"The Code > A few comments","what":"The formula for the driver","title":"BioCro II Paper: Section 1.1 Example","text":"somewhat plausible mechanistic model photosynthetic photon flux density Q due sun give roughly proportional sine angle sun makes horizon. Assuming 12 hours daylight, sun passing directly overhead (condition approximately holds equator equinox), angle (measured radians) approximately time/3600/12 * pi, time number seconds elapsed since sunrise. (, angle greater pi/2 taken angle position sun measured position sunrise; value thus takes maximum value pi sunset.) Assuming maxumum flux density 2000e-6 mol / m^2 /s (attained solar noon sine 1) yields function given Q. Note instead supplying Q driver, instead written direct module computed Q time day. latter , example, driver.","code":""},{"path":"/articles/BioCro-II_Paper--Section-1.1-example.html","id":"the-timestep-parameter","dir":"Articles","previous_headings":"The Code > A few comments","what":"The timestep parameter","title":"BioCro II Paper: Section 1.1 Example","text":"Note timestep value given parameters seconds. also note almost differential modules BioCro library assume timestep values given hours! timestep value given seconds rather hours, three important things must kept mind: differential modules used simulation must assume timestep value given seconds. Another way saying outputs differential modules used represent rate change output quantities per second. almost cases, output columns “doy”, “hour”, possibly “time” won’t make sense (filtered ) ignored. almost cases, module time input used. (See discussion.) precepts apply, mutatis mutandi, timestep units one may wish use. always, difference time row n drivers dataframe row n + 1 immediately follows equal “timestep” (whatever units timestep given).","code":""},{"path":"/articles/BioCro-II_Paper--Section-1.1-example.html","id":"first-modification-24-hour-simulation","dir":"Articles","previous_headings":"","what":"First modification: 24 hour simulation","title":"BioCro II Paper: Section 1.1 Example","text":"Although paper stated “Light intensity given table values every second 24-h period,”, period actually 12 hours (time ranges 0 3600 × 12 seconds = 12 hours). noted , purposes example, may assumed time ranges sunrise sunset 12-hour day “time” represents number seconds elapsed since sunrise. Alternatively, assumed time range 24-hour period starting ending solar midnight, Q zero sunrise sunset. entails slight modification defining equations: (“− 6” adjusts phase sine function positive values correspond daylight hours, assumed begin 6 .m. solar time.) 24-hour version example look. rows result table printed significant portions day: beginning, just midnight, dark mass accumulation; dawn, rate mass accumulation first becomes non-zero; noon, flux Q highest; dusk, rate mass accumulation drops zero; end simulation, final leaf root mass known. noted , values result doy hour nonsensical context example filtered (along ncalls, particular interest). values time column interpreted number elapsed seconds solar midnight (number (fractional) days elapsed since midnight start December 31, correct interpretation “normal” BioCro simulation). following graphs, changed labeling x axis time shown hours rather seconds.","code":"times <- 0:(3600 * 24) # seconds  Q <- function(time) pmax(0, sin((time/3600 - 6)/12 * pi) * 2000e-6) # mol / m^2 / s times <- 0:(3600 * 24) # seconds  Q <- function(time) {     pmax(0, sin((time/3600 - 6)/12 * pi) * 2000e-6) # mol / m^2 / s }  light_intensity <- data.frame(     time = times,     Q = Q(times) )  result <- run_biocro(     initial_values,     parameters,     light_intensity,     'BioCro:example_model_mass_gain',     'BioCro:example_model_partitioning' )  ## cable = customized version of kable (see above) ## kable = (nicely-formatted) knitr table cable(result[1:4,]) # beginning cable(result[seq(21591, 21661, 10),]) # around dawn cable(result[43199:43203,]) # around mid day cable(result[seq(64741, 64811, 10),]) # around dusk cable(result[86398:86401,]) # end xyplot(Q ~ time / 3600, data = result, xlim = c(0, 24), xlab = \"time (in hours)\", ylab = \"Q (mol / m^2 / s)\")  xyplot(Leaf ~ time / 3600, data = result, xlim = c(0, 24), xlab = \"time (in hours)\", ylab = \"Leaf (kg)\")"},{"path":"/articles/BioCro-II_Paper--Section-1.1-example.html","id":"second-modification-changing-the-time-specification-from-seconds-to-days","dir":"Articles","previous_headings":"","what":"Second modification: Changing the time specification from seconds to days","title":"BioCro II Paper: Section 1.1 Example","text":"usual assumption BioCro time quantity represents time, days, beginning year, number seconds elapsed start simulation. (precisely, integral part time value day year, counting one, fractional part portion day elapsed since midnight begining day. Thus time = 4.25 occur 6 .m. January 4.) follows, , way using time variable previous examples inconsistent usual interpretation time two respects: First, units seconds rather days. Second, time represented amount time elapsed beginning simulation rather “absolute” time, , time value specifying specific time day specific day year. (great harm using time variable unconventional way previous examples, long know long aren’t using modules assume conventional interpretation time variable. fact, simulations ones, result table arguably readable time value seconds hours rather days.) first inconsistencies easily remedied rescaling time values instead running 0 86400 (seconds), run 0 1 (days): simply divide former time value 86400. Now, value time increases 1/86400 (day!) row row (amount still corresponding one second):","code":"light_intensity <- data.frame(     time = times/86400,     Q = Q(times) )  result <- run_biocro(     initial_values,     parameters,     light_intensity,     'BioCro:example_model_mass_gain',     'BioCro:example_model_partitioning' )  cable(result[1:4,]) # beginning cable(result[seq(21591, 21661, 10),]) # around dawn cable(result[43199:43203,]) # around mid day cable(result[seq(64741, 64811, 10),]) # around dusk cable(result[86398:86401,]) # end xyplot(Q ~ 24 * time, data = result, xlim = c(0, 24), xlab = \"hour\", ylab = \"Q (mol / m^2 / s)\")  xyplot(Leaf ~ 24 * time, data = result, xlim = c(0, 24), xlab = \"hour\", ylab = \"Leaf (kg)\")"},{"path":"/articles/BioCro-II_Paper--Section-1.1-example.html","id":"third-modification-making-the-time-variable-consistent-with-a-reasonable-time-of-year","dir":"Articles","previous_headings":"","what":"Third modification: Making the time variable consistent with a reasonable time of year","title":"BioCro II Paper: Section 1.1 Example","text":"simulation just shown takes care making time step consistent time duration represented time column usual interpretation. time value 0 corresponds (conventional BioCro interpretation) midnight start December 31, consistent sun passing directly overhead course 12 hour day, even equatorial location. may remedy shifting time values forward 79 days time March equinox. Now time represents just duration days, precisely, represents number (fractional) days elapsed since midnight start December 31 previous year. Direct modules rely meaning time, solar_position_michalsky, now used wished. (still can mix derivative modules, thermal time modules, use time input, since , unlike example_model_partitioning module using, assume timestep value hours, seconds.)","code":"light_intensity <- data.frame(     time = times/86400 + 79,     Q = Q(times) )  result <- run_biocro(     initial_values,     parameters,     light_intensity,     'BioCro:example_model_mass_gain',     'BioCro:example_model_partitioning' )   cable(result[1:4,]) # beginning cable(result[seq(21591, 21661, 10),]) # around dawn cable(result[43199:43203,]) # around mid day cable(result[seq(64741, 64811, 10),]) # around dusk cable(result[86398:86401,]) # end xyplot(Q ~ 24 * (time - 79), data = result, xlim = c(0, 24), xlab = \"hour of the 79th day of the year\\n(March 20)\", ylab = \"Q (mol / m^2 / s)\")  xyplot(Leaf ~ 24 * (time - 79), data = result, xlim = c(0, 24), xlab = \"hour of the 79th day of the year\\n(March 20)\", ylab = \"Leaf (kg)\")"},{"path":[]},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Avoiding Pitfalls When Using the FvCB Model","text":"Farquhar-von-Caemmerer-Berry (FvCB) model C3 photosynthesis first presented Farquhar et al. (1980), since initial publication, become one important models understanding photosynthetic response plants key environmental variables incident light, CO2, temperature. Many researchers familiar model contex fitting experimentally measured CO2 response curves, certain simplifying assumptions can reasonably applied model. However, assumptions reasonable using model wider range conditions usually encountered gas exchange measurements. goal document identify several possible pitfalls associated assumptions explain avoid using FvCB model.","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"sec:centraleq","dir":"Articles","previous_headings":"","what":"The Central FvCB Equation","title":"Avoiding Pitfalls When Using the FvCB Model","text":"FvCB model rooted biochemical understanding photosynthetic process, especially carboxylation (oxygenation) RuBP enzyme Rubisco. core, predicts net CO2 assimilation rate (\\(A_n\\)) values several key variables. initial equation \\(A_n\\) can developed following considerations: One carboxylation RuBP assimilates one molecule CO2. Two oxygenations RuBP produces hazardous byproducts require release one molecule CO2 neutralize. (Oxygenation RuBP often referred photorespiration.) Mitochondrial respiration also releases CO2 molecules. Putting together, can write initial equation net assimilation rate: \\[\\begin{equation} A_n = V_c - 0.5 \\cdot V_o - R_d, \\tag{2.1} \\end{equation}\\] \\(V_c\\) RuBP carboxylation rate, \\(V_o\\) RuBP oxygenation rate, \\(R_d\\) mitochondrial respiration rate. written, \\(V_c\\), \\(V_o\\), \\(R_d\\) non-negative rates, typically units \\(\\mu\\)mol m\\(^{-2}\\) s\\(^{-1}\\). first two terms equation (\\(V_c - 0.5 \\cdot V_o\\)) represent contribution photosynthesis (Rubisco) net CO2 assimilation, remaining term (\\(-R_d\\)) result mitochondrial respiration, separate process. current form, equation easy interpret use. modifications can use improve . One change introduce \\(\\phi\\), ratio RuBP oxygenation carboxylation: \\(\\phi = V_o / V_c\\). Now can rewrite Equation (2.1) follows: \\[\\begin{equation} A_n = V_c \\cdot \\left( 1 - 0.5 \\cdot \\phi \\right) - R_d. \\tag{2.2} \\end{equation}\\] version equation makes clear \\(\\phi\\) plays key role determining whether RuBP carboxylation able outweigh oxygenation; words, determines whether photosynthetic contribution net CO2 assimilation rate positive negative. \\(1 - 0.5 \\cdot \\phi < 0\\), oxygenation consumes carbon carboxylation produces; \\(1 - 0.5 \\cdot \\phi > 0\\), opposite true. crossover point carboxylation oxygenation exactly cancel occurs \\(1 - 0.5 \\cdot \\phi = 0\\). can shown \\(\\phi\\) depends relative specificity Rubisco CO2 versus O2 (\\(S_{c/o}\\)), partial pressure CO2 vicinity Rubisco (\\(C\\)), partial pressure O2 vicinity Rubisco (\\(O\\)): \\[\\begin{equation} \\phi = \\frac{1}{S_{c/o}} \\cdot \\frac{O}{C}. \\tag{2.3} \\end{equation}\\] (See, example, Equation 2.16 von Caemmerer (2000) surrounding discussion.) Equation (2.3) tells us amount CO2 near Rubisco increases, Rubisco’s specificity CO2 increases, \\(\\phi\\) decreases hence oxygenation rate also decreases. makes sense intuitive level. also helps clarify criteria photosynthesis become net producer assimilated carbon. One immediate conclusion Rubisco specificity oxygen levels generally constant particular chloroplast, reasonable way change \\(\\phi\\) change \\(C\\). can still learn . already seen crossover occurs \\(1 - 0.5 \\cdot \\phi = 0\\) , equivalently, \\(\\phi = 2\\). Now, can rewrite condition using (2.3): \\[\\begin{equation} \\phi = 2 \\\\ \\rightarrow \\frac{1}{S_{c/o}} \\cdot \\frac{O}{C} = 2 \\\\ \\rightarrow C = \\frac{O}{2 \\cdot S_{c/o}}. \\end{equation}\\] words, photosynthesis net producer carbon whenever \\(C\\) exceeds special value called \\(\\Gamma^*\\) defined : \\[\\begin{equation} \\Gamma^* = \\frac{O}{2 \\cdot S_{c/o}}. \\tag{2.4} \\end{equation}\\] \\(\\Gamma^*\\) often referred “CO2 compensation point absence mitochondrial respiration.” (general, term “CO2 compensation point” refers value \\(C\\) \\(A_n = 0\\).) Note since atmospheric oxygen levels fairly constant, \\(O\\) rarely changes conditions, \\(\\Gamma^*\\) largely property Rubisco; specifically, depends primarily \\(S_{c/o}\\). (major exception \\(O\\) artificially decreased gas exchange measurements order reduce \\(V_o\\).) new concept, can use Equations (2.3) (2.4) rewrite Equation (2.2) follows: \\[\\begin{equation} A_n = V_c \\cdot (1 - \\Gamma^* / C) - R_d \\tag{2.5} \\end{equation}\\] equation contains great deal useful information, refer central equation FvCB model. (terminology, standard name equation.) can found many notable descriptions FvCB model, : Equation 16.57 Farquhar von Caemmerer (1982). Equation 1 Kirschbaum Farquhar (1984). Equation 2.19 von Caemmerer (2000). Equation A6 von Caemmerer (2013). (big exception original FvCB paper (Farquhar et al. 1980), contain equation!) key piece information can learned equation RuBP carboxylation rate \\(V_c\\) can never negative, contribution photosynthesis net assimilation rate (\\(V_c \\cdot(1 - \\Gamma^* / C)\\)) can negative; occur whenever \\(V_c > 0\\) \\(C < \\Gamma^*\\). rest FvCB model consists method calculating \\(V_c\\); discussed following sections.","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"choosing-a-carboxylation-rate","dir":"Articles","previous_headings":"","what":"Choosing a Carboxylation Rate","title":"Avoiding Pitfalls When Using the FvCB Model","text":"original FvCB model, two scenarios considered determining RuBP carboxylation rate \\(V_c\\): plenty RuBP available Rubisco act upon, carboxylation rate said RuBP-saturated (Rubisco-limited). case, common denote carboxylation rate \\(W_c\\). equation \\(W_c\\) derivation can found many places, Equation 1.9 von Caemmerer (2000) surrounding discussion. Following carboxylation oxygenation, RuBP molecule must “regenerated,” , returned original state ready another carboxylation oxygenation. RuBP regeneration rate slow, may impose new maximum carboxylation rate, said RuBP-regeneration-limited. case, common denote carboxylation rate \\(W_j\\). equation \\(W_j\\) derivation can found many places, Equations 2.21 2.22 von Caemmerer (2000) surrounding discussion. Sometimes rate referred electron-transport-limited rate, terminology becoming less common since realized factors besides electron transport can limit RuBP regeneration. brevity, simply reproduce equations without derivations: \\[\\begin{equation} W_c = \\frac{V_{cmax} \\cdot C}{C + K_c \\cdot \\left( 1 + O / K_o \\right)} \\tag{3.1} \\end{equation}\\] \\[\\begin{equation} W_j = \\frac{J \\cdot C}{4 \\cdot C + 8 \\cdot \\Gamma^*}, \\tag{3.2} \\end{equation}\\] \\(V_{cmax}\\) maximum rate Rubisco carboxylation activity, \\(K_c\\) \\(K_o\\) Michaelis-Menten constants CO2 O2, \\(J\\) RuBP regeneration rate, may depend several external factors incident irradiance. \\(V_{cmax}\\), \\(K_c\\), \\(K_o\\) positive, \\(J\\) non-negative. Note several different versions Equation (3.2) can found literature, changes coefficients denominator (\\(4\\) \\(8\\) version; see Equation 16.60 Farquhar von Caemmerer (1982) Section 2.4.2 von Caemmerer (2000) information). coefficients related energy requirements involved electron transport chain, different estimates exist requirements. differences, coefficients can sometimes considered variables equation instead taking fixed values. One significant feature Equations (3.1) (3.2) neither one can ever return negative value, expected (required) equation calculates carboxylation rate. Another important thing notice \\(V_{cmax}\\), \\(K_c\\), \\(K_o\\), \\(O\\), \\(\\Gamma^*\\) generally constant within chloroplast, main environmental influences \\(W_c\\) \\(W_j\\) \\(C\\) \\(J\\). \\(C\\) \\(J\\) vary, one \\(W_c\\) \\(W_j\\) may become larger two. point, key question needs addressed: carboxylation rate (\\(W_c\\) \\(W_j\\)) used Equation (2.5) determine net CO2 assimilation rate? FvCB authors provide answer: choose whichever rate smaller current set conditions (specified \\(C\\), \\(J\\), etc). Intuitively, makes sense. doesn’t matter many RuBP molecules carboxylated Rubisco RuBP regenerated fast enough; alternatively, doesn’t matter many RuBP molecules regenerated Rubisco unable carboxylate . Converting idea mathematical form, arrive another essential equation: \\[\\begin{equation} V_c = \\min \\{ W_c, W_j \\} \\tag{3.3} \\end{equation}\\] common way choose rates, produce sudden transitions RuBP-saturated RuBP-regeneration-limited carboxylation. Sometimes alternatives simple minimum used, quadratic mixing method, produce smoother transitions. example, see Kirschbaum Farquhar (1984).","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"sec:pitfallci","dir":"Articles","previous_headings":"3 Choosing a Carboxylation Rate","what":"Pitfall: Limitations at Low CO2 Concentration","title":"Avoiding Pitfalls When Using the FvCB Model","text":"People familiar analyzing experimentally measured -Ci curves may impression low \\(C\\), carboxylation (hence net CO2 assimilation) always RuBP-saturated (Rubisco-limited). , “low \\(C\\)” may mean \\(\\Gamma^*\\), CO2 compensation point, possibly threshold. example, paper excellent discussion C3 -Ci curve fitting (Sharkey et al. 2007) includes following discussion limitations assimilation: routine described requires identifying whether data point limited Rubisco, RuBP regeneration TPU. good starting point assign points 30 Pa RuBP-regeneration-limited points 20 Pa Rubisco-limited; points 20 30 Pa might either. may good advice interpreting -Ci curve, generally true, instead relies unstated assumption \\(J\\) quite high (assumption often met measuring -Ci curve). nothing FvCB model equations (Equations (2.5), (3.1), (3.2), (3.3)) enforces \\(W_c < W_j\\) threshold value \\(C\\). fact, simple counterexample demonstrating situation \\(W_j < W_c\\) low \\(C\\): darkness. Darkness ensures \\(J = 0\\) hence \\(W_j \\leq W_c\\) values \\(C\\). possible find point process limiting carboxylation rate changes; can done setting \\(W_c = W_j\\) solving \\(C\\). result given Equation 2.52 von Caemmerer (2000), special value \\(C\\) called \\(C_c\\): \\[\\begin{equation} C_c = \\frac{K_c \\cdot \\left( 1 + O / K_o \\right) \\cdot J / \\left( 4 \\cdot V_{cmax} \\right) - 2 \\cdot \\Gamma^*}{1 - J / \\left( 4 \\cdot V_{cmax} \\right)} \\tag{3.4} \\end{equation}\\] physical point view, \\(C_c\\) negative; however, Equation (3.4) can mathematically produce negative values \\(C_c\\). happens, simply means crossover, one process limits carboxylation realistic values \\(C\\). occurs whenever denominator numerator opposite signs. denominator becomes negative \\(4 \\cdot V_{cmax} < J\\). situation \\(V_{cmax}\\) small carboxylation always RuBP-saturated. hand, numerator becomes negative \\(J < 8 \\cdot V_{cmax} \\cdot \\Gamma^* / \\left[ K_c \\cdot \\left( 1 + O / K_o \\right) \\right]\\). situation \\(J\\) small carboxylation always RuBP-regeneration-limited. (course, \\(C_c\\) positive numerator denominator negative, unlikely happen realistic values \\(K_c\\), \\(K_o\\), \\(O\\), \\(\\Gamma^*\\).) Even \\(C_c\\) positive, may realistically obtainable; example, \\(J\\) just tiny bit smaller \\(4 \\cdot Vcmax\\), \\(C_c\\) can take large values achievable gas evironment nearly pure CO2. Essentially, analysis Equation (3.4) tells us simple rule determining process limits carboxylation FvCB model, even possible crossover limiting processes may occur (see Figure 3.1). Figure 3.1: Solution space Equation (3.4) indicating crossover impossible Cc negative (pink), unlikely Cc large (dark blue), otherwise possible (white). upper pink region bounded Vcmax = J * [ Kc * (1 + O / Ko)] / (8 * GammaStar) lower pink region bounded Vcmax = J / 4. calculation, Kc = 259 microbar, O = 200 mbar, Ko = 179 mbar, GammaStar = 38.6 microbar, Cc considered large exceeds 2000 microbar.","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"sec:pitfallassim","dir":"Articles","previous_headings":"3 Choosing a Carboxylation Rate","what":"Pitfall: Choosing Minimal Assimilation Rates","title":"Avoiding Pitfalls When Using the FvCB Model","text":"carboxylation RuBP-saturated, corresponding net CO2 assimilation rate (called \\(A_c\\) rather \\(A_n\\) indicate type limitation) can found combining Equations (2.5) (3.1) follows: \\[\\begin{equation} A_c = W_c \\cdot (1 - \\Gamma^* / C) - R_d = \\frac{V_{cmax} \\cdot \\left( C - \\Gamma^* \\right)}{C + K_c \\cdot \\left( 1 + O / K_o \\right)} - R_d. \\tag{3.5} \\end{equation}\\] Likewise, carboxylation RuBP-regeneration-limited, corresponding net CO2 assimilation rate (called \\(A_j\\)) can found combining Equations (2.5) (3.2) follows: \\[\\begin{equation} A_j = W_j \\cdot (1 - \\Gamma^* / C) - R_d = \\frac{J \\cdot \\left( C - \\Gamma^* \\right)}{4 \\cdot C + 8 \\cdot \\Gamma^*} - R_d. \\tag{3.6} \\end{equation}\\] mind, FvCB model sometimes expressed following form, bit simpler using version bypasses separate calculation carboxylation rates requires three equations instead four: \\[\\begin{equation} A_n = \\min \\{ A_c, A_j \\}. \\tag{3.7} \\end{equation}\\] equation can found many publications, earliest instance may Equation A1 Collatz et al. (1991). paper, authors state Equation (A1) equivalent form proposed Kirschbaum Farquhar (1984), definitions \\(J_C\\), \\(J_E\\), \\(J_S\\) differ somewhat . (Note Kirschbaum Farquhar (1984) uses \\(W_c\\) \\(W_j\\), mentioned .) Unfortunately, claim paper simply untrue Equations (2.5) (3.3) produce different results Equation (3.7). see , suppose \\(W_c < W_j\\) \\(C < \\Gamma^*\\). case, \\(\\min \\{ W_c, W_j \\} = W_c\\) \\(A_n = A_c\\) according FvCB model. However, \\(1 - \\Gamma^* / C\\) negative, \\(A_c = W_c \\cdot \\left( 1 - \\Gamma^* / C \\right) - R_d\\) also negative. Likewise, \\(A_j\\) negative, magnitude larger \\(A_c\\) \\(W_c < W_j\\). , case, \\(\\min \\{ A_c, A_j \\} = A_j\\). Thus, Equation (3.7) chosen incorrect limiting factor. fact, Equation (3.7) always chooses wrong limiting factor \\(C < \\Gamma^*\\). Equation (3.7) implemented computer code aid fitting -Ci curves simulating photosynthesis, often paired additional condition like (Aj < 0) {Aj = 0}. attempt fix problem Equation (3.7) choosing wrong limiting factor low \\(C\\). Unfortunately, solution based another misunderstanding incorrectly assumed carboxylation always RuBP-saturated low \\(C\\) (see Section 3.1). Although “partial solution” might cause problems fitting -Ci curves, produce FvCB model’s true output \\(J\\) low. subtle issue \\(C < \\Gamma^*\\), better avoid Equation (3.7) favor Equations (2.5) (3.3). Although Equation (3.7) may seem like simply alternative way specify FvCB model, actually , accurate consider separate “pseudo-FvCB” model, term continue use rest document. Examples comparing FvCB model pseudo-FvCB model can found Section 6.","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"including-triose-phosphate-utilization","dir":"Articles","previous_headings":"","what":"Including Triose Phosphate Utilization","title":"Avoiding Pitfalls When Using the FvCB Model","text":"sum chemical reactions Calvin–Benson–Bassham (CBB) cycle can written \\[\\begin{multline} \\qquad 3 \\, \\mathrm{CO_2} + 6 \\, \\mathrm{NADPH} + 6 \\, \\mathrm{H^+} +  9 \\, \\mathrm{ATP} + 5 \\, \\mathrm{H_2O} \\rightarrow \\\\ \\mathrm{(G3P)} + 6 \\, \\mathrm{NADP^+} + 9 \\, \\mathrm{ADP} + 8 \\, \\mathrm{P_i}, \\qquad \\tag{4.1} \\end{multline}\\] G3P refers glyceraldehyde 3-phosphate (also known triose phosphate) Pi refers inorganic phosphate (ion). molecule ATP synthesized three inorganic phosphate ions; thus, CBB reaction requires nine Pi ions, eight remain free end. missing inorganic phosphate contained triose phosphate molecule, exported chloroplast eventually used form monosaccharide sugars. Since CBB reaction requires three CO2 molecules, originate RuBP carboxylation, can see carboxylation effectively consumes one third inorganic phosphate. separately considering impact RuBP oxygenation (included ), can shown overall rate inorganic phosphate consumption photosynthesis (\\(R_{pc}\\)) can given \\[\\begin{equation} R_{pc} = \\frac{V_c}{3} - \\frac{V_o}{6} - \\frac{\\alpha \\cdot V_o}{2}, \\end{equation}\\] \\(0 \\leq \\alpha \\leq 1\\) fraction glycolate carbon returned chloroplast (see Section 2.4.3 von Caemmerer (2000)). Section 2, can use \\(V_o = \\phi \\cdot V_c\\) \\(\\phi / 2 = \\Gamma^* / C\\) rewrite equation terms \\(\\Gamma^*\\) \\(C\\): \\[\\begin{equation} R_{pc} = \\frac{V_c}{3 \\cdot C} \\cdot \\left[ C - \\Gamma^* \\left( 1 + 3 \\cdot \\alpha \\right) \\right].  \\tag{4.2} \\end{equation}\\] inorganic phosphate supply replenished triose phosphate used form sugars; although happens elsewhere, inorganic phosphate liberated reaction returned chloroplast. circumstances, rate triose phosphate utilization (TPU) slow enough limit inorganic phosphate available use choloroplast photosynthesis; case, carboxylation rate said TPU-limited \\(R_{pc} = T_p\\), \\(T_p\\) rate triose phosphate utilization. expression \\(R_{pc}\\) Equation (4.2) can substuted \\(R_{pc} = T_p\\) solved corresponding carboxylation rate, referred \\(W_p\\) case: \\[\\begin{equation} W_p = \\frac{3 \\cdot T_p \\cdot C}{C - \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right)}. \\tag{4.3} \\end{equation}\\] represents third possible limitation carboxylation rate addition RuBP-saturated RuBP-regeneration-limited rates. limitation included original FvCB model, importance realized soon afterwards (Sharkey 1985; Harley Sharkey 1991) since become standard part model. Since now considering new process model, must update Equation (3.3) include \\(W_p\\): \\[\\begin{equation} V_c = \\min \\{ W_c, W_j, W_p \\}. \\tag{4.4} \\end{equation}\\]","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"pitfall-impossible-limitations","dir":"Articles","previous_headings":"4 Including Triose Phosphate Utilization","what":"Pitfall: Impossible Limitations","title":"Avoiding Pitfalls When Using the FvCB Model","text":"Inspecting Equation (4.3), can see \\(C < \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right)\\), denominator equation negative, hence \\(W_p < 0\\). However, \\(W_p\\) represents carboxylation rate, negative. ’s going ? One way understand situation evaluate Equation (4.2) \\(C\\) set \\(\\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right)\\). , find rate inorganic phosphate consumption case exactly 0. words, \\(C\\) low enough, photosynthesis consuming inorganic phosphate, therefore impossible carboxylation limited TPU. One way indicate restriction modify Equation (4.3) following: \\[\\begin{equation}   W_p =   \\begin{cases}     \\infty \\;, & 0 \\leq C \\leq \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right) \\\\[1ex]     \\frac{3 \\cdot T_p \\cdot C}{C - \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right)} \\;, & \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right) < C   \\end{cases} \\tag{4.5} \\end{equation}\\] modification, \\(W_p\\) never negative, can never smallest \\(W_c\\), \\(W_j\\), \\(W_p\\) \\(C \\leq \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right)\\), can safely use conjunction Equation (4.4). carboxylation TPU-limited, corresponding net CO2 assimilation rate (called \\(A_p\\) rather \\(A_n\\) indicate type limitation) can found combining Equations (2.5) (4.3) follows: \\[\\begin{equation} A_p = W_p \\cdot (1 - \\Gamma^* / C) - R_d = \\frac{3 \\cdot T_p \\cdot \\left( C - \\Gamma^* \\right)}{C - \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right)} - R_d. \\tag{4.6} \\end{equation}\\] equation often incorporated pseudo-FvCB model discussed Section 3.2; case, Equation (3.7) updated following: \\[\\begin{equation} A_n = \\min \\{ A_c, A_j, A_p \\}. \\tag{4.7} \\end{equation}\\] See, example, Equations 2.26 2.27 von Caemmerer (2000) (aware Equation 2.26 typo denominator). Using Equation (4.7) without considering domain Equation (4.6) valid can cause additional issues beyond ones discussed Section 3.2; particular, net assimilation rate may become TPU-limited \\(C < \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right)\\), although possible. just one reason choose minimal carboxylation rate (Equation (4.4)) rather minimal net assimilation rate (Equation (4.7)) using describing FvCB model. Examples comparing FvCB model pseudo-FvCB model can found Section 6.","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"handling-c-0","dir":"Articles","previous_headings":"","what":"Handling C = 0","title":"Avoiding Pitfalls When Using the FvCB Model","text":"One issue Equation (2.5) value becomes undefined \\(C = 0\\). significant issue \\(C > 0\\) realistic situation. However, possible extend model \\(C = 0\\) considering limiting value \\(C\\) approaches 0 right. First, carboxylation TPU-limited \\(C \\leq \\Gamma^* \\cdot \\left( 1 + 3 \\cdot \\alpha \\right)\\), TPU-limited \\(C = 0\\), need consider . Next, note although \\(1 - \\Gamma^* / C\\) undefined \\(C = 0\\), \\(A_c\\) \\(A_j\\) (Equations (3.5) (3.6)) . fact, following \\(C = 0\\): \\[\\begin{equation} A_c \\big|_{C = 0} = - \\frac{\\Gamma^* \\cdot V_{cmax}}{K_c \\cdot \\left( 1 + O / K_o\\right)} - R_d \\end{equation}\\] \\[\\begin{equation} A_j \\big|_{C = 0} = - \\frac{J}{8} - R_d. \\end{equation}\\] Remembering Equation (3.7) always makes wrong choice \\(C < \\Gamma^*\\), can reverse behavior find \\(A_n\\) \\(C = 0\\): \\[\\begin{equation} A_n \\big|_{C = 0} = \\max \\bigl\\{ A_c \\big|_{C = 0}, A_j \\big|_{C = 0} \\bigr\\}. \\end{equation}\\]","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"sec:examples","dir":"Articles","previous_headings":"","what":"Examples Comparing the FvCB and Pseudo-FvCB Models","title":"Avoiding Pitfalls When Using the FvCB Model","text":"use R demonstrate differences FvCB model pseudo-FcVB model. First, define function implements FvCB model: Now, define function implements pseudo-FvCB model; intentionally avoid restricting \\(A_p\\) proper \\(C\\) domain, allowing become limiting low \\(C\\): also define function runs model across range \\(C\\) values set input parameter values compares results creating figures. code function included article, can found source file. used generate figures following sections. Finally, also define default parameter values use simulations; correspond bright conditions \\(\\alpha = 0\\). values caption Figure 2.6 von Caemmerer (2000) exception \\(O\\), specified caption. value \\(O\\) chosen approximately atmospheric partial pressure O2. following sections include three separate figures representing model outputs certain set conditions: figure showing \\(W_c\\), \\(W_j\\), \\(W_p\\), \\(V_c\\), \\(A_n\\) (calculated using Equations (2.5) (4.4)). figure shows net CO2 assimilation rate determined FvCB model. figure showing \\(A_c\\), \\(A_j\\), \\(A_p\\) \\(A_n\\) (calculated using Equation (4.7)). figure shows net CO2 assimilation rate determined pseudo-FvCB model. figure showing \\(A_n\\) calculated two different models, highlighting differences .","code":"fvcb_model <- function(   C,     # microbar   Vcmax, # micromol / m^2 / s   Kc,    # microbar   O,     # mbar   Ko,    # mbar   J,     # micromol / m^2 / s   Gstar, # microbar   Tp,    # micromol / m^2 / s   alpha, # dimensionless   Rd     # micromol / m^2 / s ) {   Wc <- Vcmax * C / (C + Kc * (1 + O / Ko))    Wj <- J * C / (4 * C + 8 * Gstar)    Wp <- 3 * Tp * C / (C - Gstar * (1 + 3 * alpha))   Wp[C <= Gstar * (1 + 3 * alpha)] <- Inf    Vc <- pmin(Wc, Wj, Wp)    An <- (1 - Gstar / C) * Vc - Rd    list(Wc = Wc, Wj = Wj, Wp = Wp, Vc = Vc, An = An) } pseudo_fvcb_model <- function(   C,     # microbar   Vcmax, # micromol / m^2 / s   Kc,    # microbar   O,     # mbar   Ko,    # mbar   J,     # micromol / m^2 / s   Gstar, # microbar   Tp,    # micromol / m^2 / s   alpha, # dimensionless   Rd     # micromol / m^2 / s ) {   Ac <- Vcmax * (C - Gstar) / (C + Kc * (1 + O / Ko)) - Rd    Aj <- J * (C - Gstar) / (4 * C + 8 * Gstar) - Rd    Ap <- 3 * Tp * (C - Gstar) / (C - Gstar * (1 + 3 * alpha)) - Rd    An <- pmin(Ac, Aj, Ap)    list(Ac = Ac, Aj = Aj, Ap = Ap, An = An) } defaults <- list(   Vcmax = 100,  # micromol / m^2 / s   Kc = 259,     # microbar   O = 200,      # mbar   Ko = 179,     # mbar   J = 170,      # micromol / m^2 / s   Gstar = 38.6, # microbar   Tp = 11.8,    # micromol / m^2 / s   alpha = 0,    # dimensionless   Rd = 1        # micromol / m^2 / s )"},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"bright-conditions-alpha-0","dir":"Articles","previous_headings":"6 Examples Comparing the FvCB and Pseudo-FvCB Models","what":"Bright Conditions, \\(\\alpha = 0\\)","title":"Avoiding Pitfalls When Using the FvCB Model","text":"case, difference models occurs \\(C < \\Gamma^*\\), carboxylation RuBP-saturated FvCB model assimilation RuBP-regeneration-limited pseudo-FvCB model.","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"bright-conditions-alpha-0-5","dir":"Articles","previous_headings":"6 Examples Comparing the FvCB and Pseudo-FvCB Models","what":"Bright Conditions, \\(\\alpha = 0.5\\)","title":"Avoiding Pitfalls When Using the FvCB Model","text":"set \\(\\alpha\\) 0.5 reduce \\(T_p\\) 10 (make TPU limitations easier spot.) , difference models \\(C < \\Gamma^*\\), carboxylation RuBP-saturated FvCB model assimilation RuBP-regeneration-limited pseudo-FvCB model. also another difference \\(Ap\\) becomes negative \\(C < \\Gamma^* \\cdot \\left(1 + 3 \\cdot \\alpha \\right)\\), leading unrealistic sudden dip net assimilation pseudo-FvCB model near \\(C\\) = 100 \\(\\mu\\)bar.","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"dim-conditions-alpha-0","dir":"Articles","previous_headings":"6 Examples Comparing the FvCB and Pseudo-FvCB Models","what":"Dim Conditions, \\(\\alpha = 0\\)","title":"Avoiding Pitfalls When Using the FvCB Model","text":"set \\(J\\) 10, simulating dim light. , difference models \\(C < \\Gamma^*\\), now opposite scenario occurs respect bright conditions: carboxylation RuBP-regeneration-limited FvCB model assimilation RuBP-saturated pseudo-FvCB model.","code":""},{"path":"/articles/avoiding_pitfalls_fvcb.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Avoiding Pitfalls When Using the FvCB Model","text":"document, shown although pseudo-FvCB model equations frequently used plant biologists, exactly equivalent original FvCB model. Differences occur low CO2 concentrations \\(C < \\Gamma^*\\); situation, two models always disagree process limits carboxylation determines overall net CO2 assimilation rate. differences may always consequential (example, CO2 concentrations rarely low enough context typical crop growth simulation), nevertheless important ensure mathematical model described accurately, code implementation model faithfully represents . case, evaluating ability model represent reality—essential goal computational modeling—becomes impossible task. reason, recommend original formulation model preferred pseudo-FvCB version using FvCB model.","code":""},{"path":[]},{"path":"/articles/ball_berry_model.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"Ball-Berry simple empirical model steady-state response stomata external conditions first described Ball et al. (1987). main idea stomata open response brighter light low CO\\(_2\\) availability, close response low humidity (limit water losses transpiration). idea can expressed mathematically \\[\\begin{equation}   g_{sw} = b_0 + b_1 \\cdot \\frac{ A_n \\cdot h_s}{C_s} \\quad     \\text{} \\; A_n \\geq 0, \\tag{1.1} \\end{equation}\\] \\(g_{sw}\\) stomatal conductance water vapor diffusion, \\(A_n\\) net CO\\(_2\\) assimilation rate, \\(b_0\\) \\(b_1\\) Ball-Berry intercept slope, \\(h_s\\) relative humidity leaf surface, \\(C_s\\) CO\\(_2\\) concentration leaf surface. \\(A_n < 0\\), \\(g_{sw} = b_0\\). , net assimilation proxy incident light intensity captures nonlinear response \\(g_{sw}\\) light. quantity \\(A_n \\cdot h_s / C_s\\) often called Ball-Berry index; thus, model states stomatal conductance linear function Ball-Berry index, model parameterized Ball-Berry slope intercept. Several critiques model made, models stomatal response exist (Tardieu Davies 1993; Leuning 1995; Dewar 2002). Nevertheless, Ball-Berry model remains widely-used due simplicity. (However, see following section, always simple use context crop growth modeling!)","code":""},{"path":"/articles/ball_berry_model.html","id":"using-the-model-for-crop-growth-modeling","dir":"Articles","previous_headings":"","what":"Using the Model for Crop Growth Modeling","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"several complexities associated using equation crop growth modeling. One \\(A_n\\) depends CO\\(_2\\) concentration inside leaf, combined models employing Ball-Berry equation mechanistic equations photosynthesis must generally solved iteratively. Another complexity associated crop growth modeling CO\\(_2\\) H\\(_2\\)O concentrations leaf surface usually known beforehand. Instead, must determined ambient values, boundary layer conductances, fluxes using one-dimensional gas flow equations form \\(F = g \\cdot (c_2 - c_1)\\), \\(F\\) flux, \\(g\\) conductance, \\(c_1\\) \\(c_2\\) gas concentrations two physical locations. remainder section describe gas flow equations can used determine \\(C_s\\) \\(h_s\\).","code":""},{"path":"/articles/ball_berry_model.html","id":"determining-c_s","dir":"Articles","previous_headings":"2 Using the Model for Crop Growth Modeling","what":"Determining \\(C_s\\)","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"Assuming steady-state conditions, CO\\(_2\\) flux across boundary layer given \\(A_n\\), allowing us find \\(C_s\\) using single gas flow equation: \\[\\begin{equation}   C_s = C_a - \\frac{A_n}{g_{bc}} = C_a - \\frac{A_n \\cdot 1.37}{g_{bw}},     \\tag{2.1} \\end{equation}\\] \\(C_a\\) ambient CO\\(_2\\) concentration, \\(g_{bc}\\) boundary layer conductance CO\\(_2\\) diffusion, \\(g_{bw}\\) boundary layer conductance water vapor diffusion. two conductances related ratio diffusivities CO\\(_2\\) H\\(_2\\)O boundary layer, typically taken 1.37. (information ratio value, see discussion following Equation B16 Caemmerer Farquhar (1981).)","code":""},{"path":"/articles/ball_berry_model.html","id":"determining-h_s","dir":"Articles","previous_headings":"2 Using the Model for Crop Growth Modeling","what":"Determining \\(h_s\\)","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"situation water vapor complicated. first point water vapor flows along concentration gradients, relative humidity gradients. Concentrations relative humidities related \\[\\begin{equation}   h = P_w / P_{w,sat}(T) = w \\cdot P_{tot} / P_{w,sat}(T), \\tag{2.2} \\end{equation}\\] \\(h\\) relative humidity, \\(w\\) water vapor concentration, \\(P_w\\) partial pressure water vapor, \\(P_{w,sat}(T)\\) saturation water vapor pressure corresponding air temperature \\(T\\), \\(P_{tot}\\) total gas pressure. second point water vapor flux \\(E\\) initially unknown; instead, assume water vapor fully saturated within leaf water vapor flow reached steady-state conditions. Thus, can begin two gas flow equations corresponding water vapor flux across boundary layer stomata (\\(E_b\\) \\(E_s\\), respectively): \\[\\begin{equation}   E_b = g_{bw} \\cdot (w_s - w_a) \\tag{2.3} \\end{equation}\\] \\[\\begin{equation}   E_s = g_{sw} \\cdot (w_i - w_s), \\tag{2.4} \\end{equation}\\] \\(w_a\\), \\(w_s\\), \\(w_i\\) water vapor concentrations ambient air, leaf surface, leaf interior, respectively. Note Equation (2.2) can used re-express concentrations using corresponding relative humidities (\\(h_a\\), \\(h_s\\), \\(h_i\\)) air temperatures (\\(T_a\\), \\(T_s\\), \\(T_i\\)) locations follows: \\[\\begin{align}   w_a &= h_a \\cdot \\frac{P_{w,sat}(T_a)}{P_{tot}} \\\\   w_s &= h_s \\cdot \\frac{P_{w,sat}(T_s)}{P_{tot}} \\\\   w_i &= h_i \\cdot \\frac{P_{w,sat}(T_i)}{P_{tot}} =     \\frac{P_{w,sat}(T_i)}{P_{tot}}, \\tag{2.5} \\end{align}\\] set \\(h_i = 1\\) latter reflect assumption water vapor saturated inside leaf. leaf’s surface interior spaces assumed temperature hence saturation water vapor pressure, can also set \\[\\begin{equation}   T_s = T_i = T_l, \\tag{2.6} \\end{equation}\\] \\(T_l\\) leaf temperature. Now, can replace \\(g_{sw}\\) Equation (2.4) expression Equation (1.1), replace water vapor concentrations temperatures Equations (2.3) (2.4) expressions Equations (2.5) (2.6), equate two fluxes Equations (2.3) (2.4) since must equal steady-state conditions. Putting together, can write \\[\\begin{equation}   \\frac{g_{bw}}{P_{tot}} \\cdot     \\big[ h_s \\cdot P_{w,sat}(T_l) - h_a \\cdot P_{w,sat}(T_a) \\big] =     \\frac{P_{w,sat}(T_l)}{P_{tot}} \\cdot     \\left[ b_0 + b_1 \\cdot \\frac{A_n \\cdot h_s}{C_s} \\right]     \\cdot \\left( 1 - h_s \\right). \\tag{2.7} \\end{equation}\\] multiplied regrouped, Equation (2.7) becomes quadratic equation \\(h_s\\): \\[\\begin{equation}   h_s^2 \\cdot \\left( b_1 \\cdot \\frac{A_n}{C_s} \\right) +     h_s \\cdot \\left( b_0 + g_{bw} - b_1 \\cdot \\frac{A_n}{C_s} \\right) -     \\left( g_{bw} \\cdot h_a \\cdot \\frac{P_{w,sat}(T_a)}{P_{w,sat}(T_l)} +       b_0 \\right) = 0. \\tag{2.8} \\end{equation}\\] Equation (2.8) can solved \\(h_s\\) using quadratic formula: \\[\\begin{align}   h_s &= \\frac{-b \\pm \\sqrt{b^2 - 4 \\cdot \\cdot c}}{2 \\cdot }, \\\\     &= b_1 \\cdot \\frac{A_n}{C_s}, \\\\     b &= b_0 + g_{bw} - b_1 \\cdot \\frac{A_n}{C_s}, \\\\     c &= - \\left( g_{bw} \\cdot h_a \\cdot \\frac{P_{w,sat}(T_a)}{P_{w,sat}(T_l)} +       b_0 \\right). \\tag{2.9} \\end{align}\\] Note assumptions, \\(\\geq 0\\) \\(c \\leq 0\\). Thus, \\(b^2 - 4 \\cdot \\cdot c \\geq b^2\\), \\(\\sqrt{b^2 - 4 \\cdot \\cdot c}\\) term Equation (2.9) always larger (equal ) \\(|b|\\). Thus, “minus” root corresponds phyically-impossible negative value \\(h_s\\), always choose “plus” root \\[\\begin{equation}   h_s = \\frac{-b + \\sqrt{b^2 - 4 \\cdot \\cdot c}}{2 \\cdot }. \\tag{2.10} \\end{equation}\\]","code":""},{"path":"/articles/ball_berry_model.html","id":"dew","dir":"Articles","previous_headings":"2 Using the Model for Crop Growth Modeling > 2.2 Determining \\(h_s\\)","what":"Dew","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"leaf temperature lower ambient air temperature, possible water vapor concentration leaf surface exceed saturation water vapor pressure leaf temperature. result \\(h_s > 1\\), possible. outcome indicates water vapor condensed leaf surface; words, dew formed.","code":""},{"path":"/articles/ball_berry_model.html","id":"biocro-implementation","dir":"Articles","previous_headings":"","what":"BioCro Implementation","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"BioCro, Ball-Berry model implemented ball_berry_gs() C++ function, calculates \\(C_s\\), \\(h_s\\), \\(g_{sw}\\) Equations (2.1), (2.10), (1.1). way deal dew formation BioCro moment, \\(h_s \\leq 1\\) forced code. function can accessed via BioCro:ball_berry module. model also plays key role several functions modules call ball_berry_gs(): c3photoC() C++ function couples Ball-Berry model Farquhar-von-Caemmerer-Berry model C3 photosynthesis determine \\(A_n\\) \\(g_{sw}\\) environmental conditions. function can accessed via BioCro:c3_assimilation module. See module documentation information. BioCro:c3_leaf_photosynthesis module couples Ball-Berry model, Farquhar-von-Caemmerer-Berry model C3 photosynthesis, Penman-Monteith approach energy balance determine \\(A_n\\), \\(g_{sw}\\), \\(T_l\\) environmental conditions. See module documentation information. c3CanAC() C++ function applies fully-coupled model used BioCro:c3_leaf_photosynthesis module sunlit shaded leaves within crop canopy calculate canopy-level photosynthesis. function can accessed via BioCro:c3_canopy BioCro:ten_layer_c3_canopy modules. See module documentation information. c4photoC() C++ function couples Ball-Berry model Collatz model C4 photosynthesis determine \\(A_n\\) \\(g_{sw}\\) environmental conditions. function can accessed via BioCro:c4_assimilation module. See module documentation information. BioCro:c4_leaf_photosynthesis module couples Ball-Berry model, Collatz model C3 photosynthesis, Penman-Monteith approach energy balance determine \\(A_n\\), \\(g_{sw}\\), \\(T_l\\) environmental conditions. See module documentation information. CanAC() C++ function applies fully-coupled model used BioCro:c4_leaf_photosynthesis module sunlit shaded leaves within crop canopy calculate canopy-level photosynthesis. function can accessed via BioCro:c4_canopy BioCro:ten_layer_c4_canopy modules. See module documentation information.","code":""},{"path":"/articles/ball_berry_model.html","id":"biocro-examples","dir":"Articles","previous_headings":"","what":"BioCro Examples","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"show BioCro can used evaluate Ball-Berry model use conjunction models varying complexity. start, need load BioCro lattice libraries:","code":"library(BioCro) library(lattice)"},{"path":"/articles/ball_berry_model.html","id":"ball-berry","dir":"Articles","previous_headings":"4 BioCro Examples","what":"Ball-Berry","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"visualize Ball-Berry model’s output soybean leaves several different values \\(A_n\\) \\(T_a\\). can see \\(g_{sw}\\) \\(h_s\\) change ambient temperature (Figures 4.1 4.2) \\(C_s\\) (Figure 4.3). Figure 4.1: \\(g_{sw}\\) vs \\(A_n\\) several different \\(T_a\\) predicted Ball-Berry model soybean parameter values. Figure 4.2: \\(h_s\\) vs \\(A_n\\) several different \\(T_a\\) predicted Ball-Berry model soybean parameter values. Figure 4.3: \\(C_s\\) vs \\(A_n\\) several different \\(T_a\\) predicted Ball-Berry model soybean parameter values.","code":"# Choose a leaf temperature Tleaf = 25 # degrees C  # Run the model for different An and Tambient bb_rc <- module_response_curve(   'BioCro:ball_berry',   within(soybean$parameters, {     gbw = 1.2                # mol / m^2 / s     leaf_temperature = Tleaf # degress C     rh = 0.7                 # dimensionless   }),   expand.grid(     net_assimilation_rate = seq(-5, 40, length.out = 201), # micromol / m^2 / s     temp = seq(Tleaf - 6, Tleaf + 6, by = 2)               # degrees C   ) ) # Plot gsw xyplot(     leaf_stomatal_conductance ~ net_assimilation_rate,     group = temp,     data = bb_rc,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = \"An (micromol / m^2 / s)\",     ylab = \"Stomatal conductance (mmol / m^2 / s)\",     main = paste(         \"Ball-Berry model with T_leaf =\", Tleaf,         \"\\nand different T_ambient\"     ) ) # Plot hs xyplot(     hs ~ net_assimilation_rate,     group = temp,     data = bb_rc,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = \"An (micromol / m^2 / s)\",     ylab = \"Relative humidity at leaf surface (dimensionless)\",     main = paste(         \"Ball-Berry model with T_leaf =\", Tleaf,         \"\\nand different T_ambient\"     ) ) # Plot cs xyplot(     cs ~ net_assimilation_rate,     group = temp,     data = bb_rc,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = \"An (micromol / m^2 / s)\",     ylab = \"CO2 concentration at leaf surface (micromol / mol)\",     main = paste(         \"Ball-Berry model with T_leaf =\", Tleaf,         \"\\nand different T_ambient\"     ) )"},{"path":"/articles/ball_berry_model.html","id":"ball-berry-and-c3-photosynthesis","dir":"Articles","previous_headings":"4 BioCro Examples","what":"Ball-Berry and C3 Photosynthesis","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"calculate response \\(g_{sw}\\) \\(A_n\\) absorbed quantum photon flux (\\(Q_{abs}\\)) ambient humidity coupled model incorporating Ball-Berry Farquhar-von-Caemmerer-Berry (FvCB) models. Although coupled model also gives us option reduce crop’s “inherent” Ball-Berry parameters response water stress, simulation ignore water stress setting StomataWS = 1. calculations, can see stomatal conductance increases higher humidities (Figure 4.4), \\(A_n\\) \\(g_{sw}\\) reach plateaus high light levels (Figures 4.4 4.5). Figure 4.4: \\(g_{sw}\\) vs \\(Q_{abs}\\) several different \\(h_a\\) predicted coupled Ball-Berry + FvCB model soybean parameter values. Figure 4.5: \\(A_n\\) vs \\(Q_{abs}\\) several different \\(h_a\\) predicted coupled Ball-Berry + FvCB model soybean parameter values.","code":"# Run the model for different Qabs and rh lrc <- module_response_curve(   'BioCro:c3_assimilation',   within(soybean$parameters, {     StomataWS = 1 # dimensionless     Tleaf = 30    # degrees C     gbw = 1.2     # mol / m^2 / s     temp = 28     # degrees C   }),   expand.grid(     Qabs = seq(0, 1000, by = 5), # micromol / m^2 / s     rh = c(0.2, 0.4, 0.6, 0.8)   # dimensionless   ) ) # Plot gsw xyplot(     Gs ~ Qabs,     group = rh,     data = lrc,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = \"Absorbed PPFD (micromol / m^2 / s)\",     ylab = \"Stomatal conductance to H2O (mmol / m^2 / s)\",     main = \"Ball-Berry + FvCB models for\\ndifferent humidities\" ) # Plot An xyplot(     Assim ~ Qabs,     group = rh,     data = lrc,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = \"Absorbed PPFD (micromol / m^2 / s)\",     ylab = \"Net CO2 assimilation rate (micromol / m^2 / s)\",     main = \"Ball-Berry + FvCB models for\\ndifferent humidities\" )"},{"path":"/articles/ball_berry_model.html","id":"simulated-c3-co_2-response-curves","dir":"Articles","previous_headings":"4 BioCro Examples","what":"Simulated C3 CO\\(_2\\) Response Curves","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"can simulate CO\\(_2\\) response curves different humidity levels coupling Ball-Berry Farquhar-von-Caemmerer-Berry models energy balance equation. keep ambient temperature fixed increasing ambient CO\\(_2\\) concentration, can done gas exchange measurement system like Licor LI-6800. environmental conditions determine \\(g_{sw}\\), \\(A_n\\), \\(T_l\\), \\(C_i\\) value \\(C_a\\), plots can generated values. model, height windspeed determine boundary layer conductance; choose large wind speed ensure high conductance, occur measurement chamber. calculations: can see \\(g_{sw}\\) changes \\(C_i\\) \\(h_a\\) (Figure 4.6), \\(A_n\\) plotted \\(C_i\\) humidities (Figure 4.7). demonstrates -Ci curve reveals response photosynthesis CO\\(_2\\) without influence stomata. (Sometimes idea expressed saying -Ci curve “peels away epidermis.”) can also see value \\(C_i\\) corresponding \\(C_a\\) depend humidity, higher humidity corresponding higher \\(C_i\\) (Figure 4.9). relationship mediated stomata, open response higher humidity. Thus, although humidity impact shape -Ci curve, can effect range achievable \\(C_i\\) values. stomatal conductance largest \\(C_i\\) near 250 ppm, leaf temperature lowest range (Figures 4.6 4.8). occurs open stomata facilitate evaporative cooling; cooling effect stronger lower humidities transpiration rate higher. Figure 4.6: \\(g_{sw}\\) vs \\(C_i\\) several different \\(h_a\\) predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values. Figure 4.7: \\(A_n\\) vs \\(C_i\\) several different \\(h_a\\) predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values. Figure 4.8: \\(T_l\\) vs \\(C_i\\) several different \\(h_a\\) predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values. Figure 4.9: \\(C_i\\) vs \\(C_a\\) several different \\(h_a\\) predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values.","code":"# Set the absorbed photosynthetically active light (in micromol / m^2 / s) absorbed_ppfd <- 1000  # Determine the total absorbed light energy (in J / m^2 / s) absorbed_energy <-     absorbed_ppfd * soybean$parameters$par_energy_content /         soybean$parameters$par_energy_fraction  aci <- module_response_curve(     'BioCro:c3_leaf_photosynthesis',     within(soybean$parameters, {         StomataWS = 1 # dimensionless         temp = 30     # degrees C         windspeed = 3 # m / s         height = 0.8  # m         absorbed_ppfd = absorbed_ppfd         average_absorbed_shortwave = absorbed_energy     }),     expand.grid(         Catm = seq(100, 1800, by = 5), # micromol / mol         rh = c(0.4, 0.6, 0.8)          # dimensionless     ) ) # Plot the gsw-Ci curves xyplot(     Gs ~ Ci,     group = rh,     data = aci,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Intercellular CO2 concentration (micromol / mol)',     ylab = 'Stomatal conductance to H2O (mmol / m^2 / s)',     main = 'Ball-Berry + FvCB + energy balance\\nfor different humidities' ) # Plot the A-Ci curves xyplot(     Assim ~ Ci,     group = rh,     data = aci,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Intercellular CO2 concentration (micromol / mol)',     ylab = 'Net CO2 assimilation rate (micromol / m^2 / s)',     main = 'Ball-Berry + FvCB + energy balance\\nfor different humidities' ) # Plot the Tl-Ci curves xyplot(     leaf_temperature ~ Ci,     group = rh,     data = aci,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Intercellular CO2 concentration (micromol / mol)',     ylab = 'Leaf temperature (degrees C)',     main = 'Ball-Berry + FvCB + energy balance\\nfor different humidities' ) # Plot the Ci-Ca curves xyplot(     Ci ~ Catm,     group = rh,     data = aci,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Ambient CO2 concentration (micromol / mol)',     ylab = 'Intercellular CO2 concentration (micromol / mol)',     main = 'Ball-Berry + FvCB + energy balance\\nfor different humidities' )"},{"path":"/articles/ball_berry_model.html","id":"gas-concentrations-within-a-c3-canopy","dir":"Articles","previous_headings":"4 BioCro Examples","what":"Gas Concentrations Within a C3 Canopy","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"can see several quantities change throughout soybean canopy fixed set environmental conditions using fully-coupled Ball-Berry + FvCB + energy balance model leaf level photosynthesis. sunlit leaves, observe following trends: CO\\(_2\\) concentration leaf surface (\\(C_s\\)) decreases canopy depth (Figure 4.10). relative humidity leaf surface (\\(C_s\\)) increases canopy depth (Figure 4.11). stomatal conductance (\\(g_{sw}\\)) increases canopy depth (Figure 4.12). leaf temperature (\\(T_l\\)) generally increases canopy depth, although trend monotonic (Figure 4.13). net assimilation rate (\\(A_n\\)) decreases canopy depth (Figure 4.14). Figure 4.10: \\(C_s\\) vs canopy layer sunlit shaded leaves predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values. Figure 4.11: \\(h_s\\) vs canopy layer sunlit shaded leaves predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values. Figure 4.12: \\(g_{sw}\\) vs canopy layer sunlit shaded leaves predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values. Figure 4.13: \\(T_l\\) vs canopy layer sunlit shaded leaves predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values. Figure 4.14: \\(A_n\\) vs canopy layer sunlit shaded leaves predicted coupled Ball-Berry + FvCB + energy balance model soybean parameter values.","code":"# Run canopy modules RH_a <- 0.8     # dimensionless; ambient relative humidity T_ambient <- 30 # degrees C; ambient air temperature StomataWS <- 1  # no water stress  canres <- run_biocro(     direct_module_names = c(         'BioCro:solar_position_michalsky',         'BioCro:shortwave_atmospheric_scattering',         'BioCro:incident_shortwave_from_ground_par',         'BioCro:ten_layer_canopy_properties',         'BioCro:ten_layer_c3_canopy'     ),     parameters = within(soybean$parameters, {         year = 2022         time_zone_offset = -6 # CDT         solar = 1500          # micromol / m^2 / s         lai = 3               # dimensionless         rh = RH_a             # dimensionless         windspeed = 2         # m / s         temp = T_ambient      # degrees C         StomataWS = StomataWS # dimensionless     }),     drivers = data.frame(time = 210.5) # noon on day 210 (July 29 for 2022) )  # Extract canopy profiles canopy_profiles_list <- lapply(     c('sunlit', 'shaded'),     function(leaf_class) {         cs_column_names <- grep(             paste0(leaf_class, '_Cs_layer_[0-9]'),             colnames(canres),             value = TRUE         )          rhs_column_names <- grep(             paste0(leaf_class, '_RHs_layer_[0-9]'),             colnames(canres),             value = TRUE         )          gsw_column_names <- grep(             paste0(leaf_class, '_Gs_layer_[0-9]'),             colnames(canres),             value = TRUE         )          tl_column_names <- grep(             paste0(leaf_class, '_leaf_temperature_layer_[0-9]'),             colnames(canres),             value = TRUE         )          a_column_names <- grep(             paste0(leaf_class, '_Assim_layer_[0-9]'),             colnames(canres),             value = TRUE         )          data.frame(             type = leaf_class,             layer = seq(0, 9),             Cs = as.numeric(canres[cs_column_names]),             RHs = as.numeric(canres[rhs_column_names]),             gsw = as.numeric(canres[gsw_column_names]),             tl = as.numeric(canres[tl_column_names]),             A = as.numeric(canres[a_column_names])         )     } )  canopy_profiles <- do.call(rbind, canopy_profiles_list) # Plot the Cs profiles xyplot(     Cs ~ layer,     group = type,     data = canopy_profiles,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Canopy layer (0 is top, 9 is bottom)',     ylab = 'CO2 concentration at leaf surface (micromol / mol)',     main = 'Ball-Berry + FvCB + energy balance\\nwithin a soybean canopy' ) # Plot the RHs profiles xyplot(     RHs ~ layer,     group = type,     data = canopy_profiles,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Canopy layer (0 is top, 9 is bottom)',     ylab = 'Relative humidity at leaf surface (micromol / mol)',     main = 'Ball-Berry + FvCB + energy balance\\nwithin a soybean canopy' ) # Plot the gsw profiles xyplot(     gsw ~ layer,     group = type,     data = canopy_profiles,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Canopy layer (0 is top, 9 is bottom)',     ylab = 'Stomatal conductance to H2O (mmol / m^2 / s)',     main = 'Ball-Berry + FvCB + energy balance\\nwithin a soybean canopy' ) # Plot the leaf temperature profiles xyplot(     tl ~ layer,     group = type,     data = canopy_profiles,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Canopy layer (0 is top, 9 is bottom)',     ylab = 'Leaf temperature (degrees C)',     main = 'Ball-Berry + FvCB + energy balance\\nwithin a soybean canopy' ) # Plot the assimilation profiles xyplot(     A ~ layer,     group = type,     data = canopy_profiles,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Canopy layer (0 is top, 9 is bottom)',     ylab = 'Net CO2 assimilation rate (micromol / m^2 / s)',     main = 'Ball-Berry + FvCB + energy balance\\nwithin a soybean canopy' )"},{"path":"/articles/ball_berry_model.html","id":"soybean-modeling","dir":"Articles","previous_headings":"4 BioCro Examples","what":"Soybean Modeling","title":"Using the Ball-Berry Model in Crop Growth Simulations","text":"can see Ball-Berry slope can affect soybean yield. slope encapsulates “willingness” crop open stomata. resources plentiful, higher stomatal conductance may allow carbon assimilation hence growth. hand, higher stomatal conductance increases water losses due transpiration, can exacerbate drought stress. Thus, exact impact change \\(b_1\\) therefore strongly depend particular location weather. BioCro, soil water content determines water stress level plant, reducing Ball-Berry parameters times low water availability. time, canopy transpiration influences soil water content, higher transpiration rates causing faster depletion soil water. example, just use weather data 2002 Champaign, Illinois; conditions, increasing Ball-Berry slope causes final seed mass (called Grain ) increase (Figure 4.15). Figure 4.15: Soybean biomass values predicted Champaign, Illinois 2002 using different values Ball-Berry slope \\(b_1\\).","code":"# Use partial application to create a function that runs a soybean simulation # for a given value of the Ball-Berry slope bb1_func <- with(soybean, {partial_run_biocro(     initial_values,     parameters,     soybean_weather[['2002']],     direct_modules,     differential_modules,     ode_solver,     'b1' # the name of the parameter we wish to vary )})  # Run the soybean model for several different slope values bb1_result_list <- lapply(     seq(soybean$parameters$b1 - 3, soybean$parameters$b1 + 3, by = 1.5),     function(x) {         within(bb1_func(x), {b1 = x})     } )  # Collect the results into a single data frame bb1_result <- do.call(rbind, bb1_result_list) # Plot soybean biomass values for different values of the Ball-Berry slope xyplot(     Leaf + Stem + Root + Grain ~ time,     group = b1,     data = bb1_result,     type = 'l',     auto.key = list(space = 'right'),     grid = TRUE,     xlab = 'Day of year (2002)',     ylab = 'Biomass (Mg / ha)',     main = 'Testing different soybean Ball-Berry slope values' )"},{"path":[]},{"path":"/articles/dynamical_systems.html","id":"dynamical-systems-real-and-mathematical","dir":"Articles","previous_headings":"","what":"Dynamical systems, real and mathematical","title":"BioCro as a Dynamical System","text":"book Computation, Dynamics, Cognition (Giunti 1997), Giunti distinguishes real dynamical systems mathematical dynamical systems: real dynamical system real system changes time. Therefore, since real system can thought change time (respect), real system real dynamical system. mathematical dynamical system, hand, abstract mathematical structure can used describe change real system evolution series states. emphasized create mathematical system model real one, just quantifying attributes real system; also selecting attributes incorporate model ones ignore. endless variety attributes describe state real system, can’t even begin hope able model . stated Giunti quote, mathematical dynamical system describe change real system evolution series states. (now, interpret “series states” loosely, encompass models describe change continuous evolution system state well describe change terms discrete sequence states.) real usefulness mathematical structure, however, comes goes beyond merely describing series states: real power comes able derive complete picture evolution system partial knowledge system, knowledge possibly consisting , example, state system particular time, environment system operating, general knowledge processes determine system behaves.","code":""},{"path":"/articles/dynamical_systems.html","id":"an-example-the-falling-body-problem","dir":"Articles","previous_headings":"Dynamical systems, real and mathematical","what":"An example: the falling-body problem","title":"BioCro as a Dynamical System","text":"classic example physics falling-body problem: Given stationary, compact, relatively dense object dropped height \\(h_0\\) surface earth, height duration time \\(t\\)? partial knowledge system consists : initial height \\(h_0\\) object initial velocity \\(v_0\\) object (system, ’ll assume \\(v_0 = 0\\): object stationary begin .) magnitude, ’ll call \\(g\\), downward acceleration body caused earth’s gravitational field use function \\(h(t)\\) embody complete description evolution system—\\(h(t)\\) tells height body elapsed time \\(t\\)—initial knowledge system consists system equations putting certain constraints function \\(h\\):  \\[\\begin{align}   h(0)         & = h_0      \\notag \\\\   h'(t)\\big|_{t=0} & = 0    \\label{eq:ode-system} \\\\   h''(t)       & = -g       \\notag \\end{align}\\]  (third constraint accurately written  \\[\\begin{equation*}   h''(t) = -g \\quad\\text{\\emph{} h(t) > 0}, \\end{equation*}\\]  simplicity, consider system durations sufficiently small object yet hit ground.) field differential equations, known initial-value problem, can shown unique solution given  \\[\\begin{equation*}   h(t) = h_0 - 1/2\\,gt^2. \\end{equation*}\\]  Thus, knowing initial height velocity object basic principles physics, able obtain complete description evolution “falling object” system time.","code":""},{"path":"/articles/dynamical_systems.html","id":"some-comments-on-mathematical-abstraction","dir":"Articles","previous_headings":"Dynamical systems, real and mathematical","what":"Some comments on mathematical abstraction","title":"BioCro as a Dynamical System","text":"mentioned, mathematical dynamical system purports model real system necessarily leave much . choosing attributes retain abstract model, two main considerations: First, attributes system interest us? model plant growth, might include, example, rate growth (mass accumulation) plant; nutrient energy content growing plant; effects group plants surrounding environment, including temperature \\(\\text{CO}_\\text{2}\\) content surrounding air, rate erosion soil substrate; resilience plant drought conditions. Second, attributes may particular intrinsic interest may help predicting behavior attributes interest. Returning falling-object model moment, primary object interest real falling object system height object given time, certain things system may safely ignore: color object time day, example, probably bearing trajectory object’s motion. hand, knowing velocity object given time crucial predicting height time, even may intrinsic interest knowing velocity. attributes bearing motion object (give examples) size shape object mass object air currents vicinity object’s path Italian experimenters 16th century demonstrated, weight compact relatively dense object little effect upon rate falls. turns , matter fact, predictive accuracy model, look height downward velocity object (ambient gravitational field) ignore attributes system, rather good case compact, relatively-dense objects. course, consider non-compact object relatively low density, feather, model may good job predicting path falls air. may find order accurately model free-fall feather, need include additional attributes system, help us take account effects air resistance. process, whereby model compared observations updated fails predict behavior real system meant represent, key part scientific process responsible great deal progress understanding. Thus, never problem process abstraction left many details; instead opportunity learn real world model. central goal BioCro make relatively easy add new components existing model, allowing type model development occur rapidly.","code":""},{"path":"/articles/dynamical_systems.html","id":"continuous-time-versus-discrete-time","dir":"Articles","previous_headings":"","what":"Continuous time versus discrete time","title":"BioCro as a Dynamical System","text":"system just shown—mathematical model real-world dynamical system—differential equation constraining solution exact solution easily-computable function. often, however, able find exact solution, settle numerical solution. show model falling-object system numerically, even though one case don’t really need resort methods.","code":""},{"path":"/articles/dynamical_systems.html","id":"eulers-method","dir":"Articles","previous_headings":"Continuous time versus discrete time","what":"Euler’s method","title":"BioCro as a Dynamical System","text":"Euler’s method, basic methods numerical integration ordinary differential equations, may applied system current rate change state variables may expressed function current state. , use state variable mean quantifiable attribute system whose value like predict; state system conglomeration values variables particular time. Euler’s method makes assumption , given known state system particular time, state system small interval time later can closely approximated assuming rate change state variable remains essentially constant small time interval. \\(\\mathbf{s}\\) denotes state, \\(\\mathbf{s}(t)\\) denoting value time \\(t\\), \\(x\\) one state variables, \\(x(t)\\) denoting value time \\(t\\), , given  \\[\\begin{equation*}   dx/dt = f(\\mathbf{s}), \\end{equation*}\\]  assume sufficiently small interval time \\(\\Delta t\\),  \\[\\begin{equation*}   x(t+\\Delta t) \\approx x(t) + f(\\mathbf{s}(t))\\cdot\\Delta t. \\end{equation*}\\]","code":""},{"path":"/articles/dynamical_systems.html","id":"applying-eulers-method-to-the-falling-body-problem","dir":"Articles","previous_headings":"Continuous time versus discrete time","what":"Applying Euler’s method to the falling-body problem","title":"BioCro as a Dynamical System","text":"system equations \\(\\eqref{eq:ode-system}\\), \\(h\\) system variable. valid equation gives \\(dh/dt\\) function state state represented \\(h\\) alone. solve problem, also consider velocity part state. think state system record system particular time can used predict future state, makes sense velocity included. example, know position object even know moving upwards downwards, able predict position near future. now, states system two components, height velocity, can think state \\(\\mathbf{s}\\) point 2-dimensional Euclidean space, ,  \\[\\begin{equation*}   \\mathbf{s} = (s_0, s_1). \\end{equation*}\\]  identify height \\(h\\) first component \\(s_0\\) velocity \\(v\\) second component \\(s_1\\). consider \\(v\\) velocity upward direction object falling, \\(v < 0\\). write \\(v(t)\\) denote \\(v\\) function time. Since \\(v = dh/dt\\), can rewrite system \\(\\eqref{eq:ode-system}\\)  \\[\\begin{align}   dh/dt & = v   \\label{eq:deriv_h} \\\\   dv/dt & = -g  \\label{eq:deriv_v} \\\\   h(0)  & = h_0 \\notag \\\\   v(0)  & = 0   \\notag \\end{align}\\]  Now can use equations \\(\\eqref{eq:deriv_h}\\) \\(\\eqref{eq:deriv_v}\\) obtain Euler method formulas estimating state time \\(t + \\Delta t\\) state time \\(t\\):  \\[\\begin{align*}   h(t + \\Delta t) & = h(t) + v(t)\\cdot\\Delta t \\\\   v(t + \\Delta t) & = v(t) - g\\cdot\\Delta t \\end{align*}\\] Let us consider system sequence times \\(0 = t_0, t_1, t_2, t_3, \\dots\\) \\(\\), \\(t_{+ 1} = t_i + \\Delta t\\). , let write \\(\\delta\\) \\(\\Delta t\\), let \\(\\pi_0\\) \\(\\pi_1\\) denote projection state \\(\\mathbf{s}\\) onto components,  \\[\\begin{align}   \\pi_0(\\mathbf{s}) & = s_0 \\\\   \\intertext{}   \\pi_1(\\mathbf{s}) &= s_1. \\end{align}\\]  Now can write recursive definition state \\(\\mathbf{s}\\) function \\(t\\):  \\[\\begin{align}   \\mathbf{s}(t_0) &= (h_0, 0) \\notag \\\\   \\mathbf{s}(t_{+ 1}) &= (\\pi_0(\\mathbf{s}(t_i)) +  \\delta \\cdot \\pi_1(\\mathbf{s}(t_i)),                          \\pi_1(\\mathbf{s}(t_i)) - \\delta\\cdot g)\\quad\\text{$\\geq$0}.                          \\label{eq:falling_body_recursion} \\end{align}\\]  Note also express definition using original variable names without using projection operators:  \\[\\begin{align*}   \\mathbf{s}(t_0) &= (h_0, 0) \\notag \\\\   \\mathbf{s}(t_{+ 1}) &= (h(t_i) +  \\Delta t \\cdot v(t_i),                          v(t_i) - \\Delta t \\cdot g)\\quad\\text{$\\geq$0}. \\end{align*}\\]  Thus, Equation \\(\\eqref{eq:falling_body_recursion}\\) may seem like complicated way write relatively simple rule relating height, velocity, acceleration. notation , however, become useful later consider systems less terms named state variables instead think variables coordinates point Euclidean space comprising system state space.","code":""},{"path":"/articles/dynamical_systems.html","id":"note-about-abstraction-and-recursive-systems","dir":"Articles","previous_headings":"Continuous time versus discrete time","what":"Note about abstraction and recursive systems","title":"BioCro as a Dynamical System","text":"just performed following abstraction arrive recursively-defined function giving state system function time:  \\[\\begin{equation*}   \\begin{array}{c}     \\text{\\sc real system} \\\\     \\downarrow \\\\     \\text{\\sc continuous mathematical system (ODE system)} \\\\     \\downarrow \\\\     \\text{\\sc discrete-time approximation (recursive equations)}   \\end{array} \\end{equation*}\\]  One important point process developing recursive equation (discrete-time approximation) depends algorithm chosen solving continuous ODE system. example, chosen use fourth-order Runge-Kutta method rather Euler’s method solve falling-body problem, arrived recursive definition different Equation \\(\\eqref{eq:falling_body_recursion}\\). Nevertheless, represent continuous system, (usually) produce similar sequence states. also pointed discrete-time abstract dynamical systems arise abstractions real systems even abstractions continuous-time abstract systems.1 Consider, example, system state space \\(\\mathbf{Z}^2\\) consisting ordered pairs \\(\\mathbf{v} = (v_0, v_1)\\) integers, transition rule  \\[\\begin{equation*}   \\mathbf{v}(t_{+ 1}) = (\\pi_1(\\mathbf{v}(t_i)), \\pi_0(\\mathbf{v}(t_i)) + \\pi_1(\\mathbf{v}(t_i))). \\end{equation*}\\]  Given initial state \\(\\mathbf{v}(t_0)\\), now way compute state \\(\\mathbf{v}(t_i)\\) time \\(t_i\\). abstract dynamical system may relationship real dynamical system might imagine, abstract dynamical system nevertheless. (take \\(\\mathbf{v}(t_0) = (0, 1)\\), way, function \\(F: \\mathbf{N}\\\\mathbf{Z}\\) defined rule  \\[\\begin{equation*}   \\mapsto \\pi_0(\\mathbf{v}(t_i)) \\end{equation*}\\]  defines Fibonacci sequence \\(0, 1, 1, 2, 3, 5, 8, 13, \\dots\\,\\).) Another class discrete-time abstract dynamical systems cellular automata. , however, may value modeling real-world phenomena. (See, example, Deutsch (2005).)","code":""},{"path":"/articles/dynamical_systems.html","id":"an-overview-of-some-abstract-dynamical-system-formulations","dir":"Articles","previous_headings":"","what":"An overview of some abstract dynamical system formulations","title":"BioCro as a Dynamical System","text":"section provide short survey formulations abstract dynamical systems; later sections, discuss formulations relate types systems represented BioCro. (insightful thoroughly abstract mathematical study theory general systems, dynamical otherwise, see Mesarović Takahara (1975).)","code":""},{"path":"/articles/dynamical_systems.html","id":"some-notational-preliminaries","dir":"Articles","previous_headings":"An overview of some abstract dynamical system formulations","what":"Some notational preliminaries","title":"BioCro as a Dynamical System","text":"common, take \\(f: C \\B\\) mean “\\(f\\) function domain \\(C\\) taking values set \\(B\\).” Usually, means \\(f(c)\\) defined every \\(c\\C\\), follows, won’t always entirely strict . Following Vaught (1985), write \\(B^C\\) denote set functions \\(f\\).2 use \\(\\mathbf{R}\\), \\(\\mathbf{Z}\\), \\(\\mathbf{N}\\) denote real numbers, integers, natural numbers (finite ordinals, including zero), respectively. \\(\\mathbf{Z}^+\\) denotes positive integers. Following von Neumann, sometimes convenient identify natural number \\(n\\) set predecessors. example, \\(5 = \\{0, 1, 2, 3, 4\\}\\). particularly useful speaking Euclidian spaces. example, \\(\\mathbf{R}^3\\), Euclidean 3-space, usually thought set 3-coordinate vectors \\((x, y, z)\\). can equally well consider set mappings \\(v: \\{0,1,2\\}\\\\mathbf{R}\\), , using set--functions notation given , can denoted \\(\\mathbf{R}^{\\{0,1,2\\}}\\). (, using von Neumann’s notion ordinals, , , denoted \\(\\mathbf{R}^3\\), since \\(3=\\{0,1,2\\}\\)!) Thus, can identify 3-tuple \\((x,y,z)\\) mapping \\(v: \\{0,1,2\\}\\\\mathbf{R}\\), \\(v(0) = x\\), \\(v(1) = y\\), \\(v(2) = z\\). often write \\(v_i\\) place \\(v()\\) identify mapping \\(v: \\{0, 1, 2, \\dots, n-1\\}\\\\mathbf{R}\\) n-tuple n-coordinate vector \\(\\mathbf{v}=(v_0, v_1, v_2, \\dots, v_{n-1})\\). Often, however, level indirection involved use notation \\(v_i\\) coordinate \\(\\mathbf{v}\\). example, \\(\\mathbf{U}\\) proper subspace \\(\\mathbf{R}^n\\) \\(\\mathbf{U} = \\mathbf{R}^U\\) proper subset \\(U\\) \\(n = \\{0,1,\\dots,n-1\\}\\), may regard \\(u_i\\) value taken \\(\\)th member \\(U\\) arbitrary fixed ordering members \\(U\\). even allow case function domain \\(U\\) isn’t set integers just finite collection objects. case, context considering vectors (qua mappings) \\(\\mathbf{v}\\\\mathbf{R}^U\\), \\(v_i\\) may denote alternately \\(^\\text{th}\\) member \\(U\\) fixed enumeration; name variable associated member; value \\(^\\text{th}\\) coordinate particular vector \\(\\mathbf{v}\\). later case, \\(v_i\\) doesn’t abbreviate \\(v()\\) function \\(v\\\\mathbf{R}^U\\). Rather, stands \\(v(u_i)\\), \\(u_i\\) denotes “\\(^\\text{th}\\) member \\(U\\).” function \\(f: C \\B\\) may identified set \\(\\{(c, f(c))\\,:\\,c\\C\\}\\). Thus, target set \\(B\\) intrinsic part function \\(f\\). , defining image set \\(f\\)  \\[\\begin{equation*}     \\operatorname{Im}f = \\{b\\,: \\text{exists $c\\C$ } (c, b) \\f\\}, \\end{equation*}\\]  can least say \\(\\operatorname{Im}f\\subseteq B\\). Given function \\(f: C \\B\\) subset \\(C_0\\subseteq C\\), can define \\(f|C_0\\), restriction \\(f\\) \\(C_0\\),  \\[\\begin{equation*}     f|C_0 := \\{(c, b) \\f\\,:\\,c\\C_0\\} \\end{equation*}\\]  shall particularly interested restrictions functions specifying points Euclidean space. Suppose \\(\\mathbf{x}\\\\mathbf{R}^n\\), let \\(W\\) arbitrary subset \\(n=\\{0,1,2,\\dots,n-1\\}\\). \\(\\mathbf{x}|W\\) member \\(\\mathbf{R}^W\\), set functions assign real number member \\(W\\). regard \\(\\mathbf{R}^W\\) subspace \\(\\mathbf{R}^n\\). Moreover, \\(W\\) \\(k\\) members, \\(\\mathbf{R}^W\\) isomorphic , necessarily equal , Euclidean space \\(\\mathbf{R}^k\\). (\\(\\mathbf{R}^W\\) \\(\\mathbf{R}^k\\) equal iff \\(W=k\\) (, iff \\(W = \\{0, 1, \\dots, k-1\\})\\).) define projection mapping \\(\\pi^{n\\W}: \\mathbf{R}^n\\\\mathbf{R}^W\\) rule  \\[\\begin{equation*}     v \\mapsto v|W. \\end{equation*}\\] generally, given two finite sets \\(W\\subseteq U\\) (necessarily sets integers), may define projection mapping \\(\\pi^{U\\W}: \\mathbf{R}^U\\\\mathbf{R}^W\\) rule  \\[\\begin{equation*}    v \\\\mathbf{R}^U \\mapsto v|W. \\end{equation*}\\] Just can restrict domain function, can expand well. Suppose two functions \\(f\\\\mathbf{R}^X\\) \\(g\\\\mathbf{R}^Y\\), either \\(X\\) \\(Y\\) disjoint, \\(f(z) = g(z)\\) \\(z\\X\\cap Y\\). define union \\(f\\cup g\\) \\(f\\) \\(g\\) rule  \\[\\begin{equation*}     (f\\cup g)(z) = \\begin{cases}            f(z) & \\text{$z\\X$,} \\\\            g(z) & \\text{$z\\Y\\smallsetminus X$.}        \\end{cases} \\end{equation*}\\]  Note exactly function get regarding functions sets ordered pairs taking literal (set) union \\(f\\) \\(g\\). Also, clearly,  \\[\\begin{align*}     f &= (f\\cup g)|X \\\\     \\intertext{}     g &= (f\\cup g)|Y. \\end{align*}\\] Lastly, given two sets \\(\\) \\(B\\), define Cartesian product \\(\\) \\(B\\) set ordered couples: \\[\\begin{equation*}     \\times B = \\{(, b): \\\\text{ } b\\B\\} \\end{equation*}\\]  \\(=\\mathbf{R}^X\\) \\(B=\\mathbf{R}^Y\\) \\(X\\cap Y=\\emptyset\\), natural isomorphism \\(\\mathbf{R}^X\\times\\mathbf{R}^Y\\) \\(\\mathbf{R}^{X\\cup Y}\\) given  \\[\\begin{equation*}     (\\mathbf{x}, \\mathbf{y}) \\mapsto \\mathbf{x}\\cup\\mathbf{y}. \\end{equation*}\\] (inverse mapping given \\(\\mathbf{v} \\mapsto (\\mathbf{v}|X, \\mathbf{v}|Y)\\) \\(\\mathbf{v}\\\\mathbf{R}^{X\\cup Y}\\).)  convenient warranted, consider \\(\\mathbf{R}^X\\times\\mathbf{R}^Y\\) \\(\\mathbf{R}^{X\\cup Y}\\) identical. notion Cartisean product can extended three sets. example, since natural isomophism \\((\\times B)\\times C\\) \\(\\times(B\\times C)\\), can just write product \\(\\times B\\times C\\) write members ordered triplets \\((,b,c)\\) (instead \\(((,b),c)\\) \\((,(b,c)\\)).","code":""},{"path":"/articles/dynamical_systems.html","id":"the-khalil-model","dir":"Articles","previous_headings":"An overview of some abstract dynamical system formulations","what":"The Khalil model","title":"BioCro as a Dynamical System","text":"first model consider described Khalil (Khalil 2002). model expressive flexible, believe intuitively natural way view sort systems BioCro deals systems level (Section \\(\\ref{sec:BioCro_systems}\\)). opening chapter, author introduces dynamical systems finite collection coupled first-order ordinary differential equations \\[\\begin{align*}   \\dot{x}_0 &= f_0(t, x_0, \\dots, x_{n-1}, u_0, \\dots, u_{p-1}) \\\\   \\dot{x}_1 &= f_1(t, x_0, \\dots, x_{n-1}, u_0, \\dots, u_{p-1}) \\\\   &\\; \\vdots \\\\   \\dot{x}_{n-1} &= f_{n-1}(t, x_0, \\dots, x_{n-1}, u_0, \\dots, u_{p-1}). \\end{align*}\\] somewhat general system considered Section \\(\\ref{opening_example}\\) derivatives depend upon state variables \\(x_0, x_1, \\dots, x_{n-1}\\), also upon time \\(t\\) Khalil refers input variables \\(u_0, u_1, \\dots, u_{p-1}\\). Defining  \\[\\begin{equation}   \\mathbf{x} = \\begin{bmatrix}                      x_0 \\\\                      x_1 \\\\                      \\vdots \\\\                      \\vdots \\\\                      x_{n-1}                \\end{bmatrix},\\quad   \\mathbf{u} = \\begin{bmatrix}                      u_0 \\\\                      u_1 \\\\                      \\vdots \\\\                      \\vdots \\\\                      u_{p-1}                \\end{bmatrix},\\quad   \\mathbf{f}(t, \\mathbf{x}, \\mathbf{u}) = \\begin{bmatrix}                      f_0(t, \\mathbf{x}, \\mathbf{u}) \\\\                      f_1(t, \\mathbf{x}, \\mathbf{u}) \\\\                      \\vdots \\\\                      \\vdots \\\\                      f_{n-1}(t, \\mathbf{x}, \\mathbf{u})                \\end{bmatrix}, \\label{eq:khalil_vectors} \\end{equation}\\]  state equation may written succinctly vector equation  \\[\\begin{equation}   \\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x}, \\mathbf{u}). \\label{eq:Khalil_state_equation} \\end{equation}\\]  (Note Khalil actually uses 1-based indexing vector coordinates exposition, vector \\(\\mathbf{x}\\), example, defined  \\[\\begin{equation*}   \\mathbf{x} = \\begin{bmatrix}                      x_1 \\\\                      x_2 \\\\                      \\vdots \\\\                      \\vdots \\\\                      x_n                \\end{bmatrix}. \\end{equation*}\\]  use 0-based indexing instead order consistent parts article.)","code":""},{"path":"/articles/dynamical_systems.html","id":"variants-of-khalils-model","dir":"Articles","previous_headings":"An overview of some abstract dynamical system formulations > The Khalil model","what":"Variants of Khalil’s model","title":"BioCro as a Dynamical System","text":"point, worth bringing two restricted versions Khalil model. first equation \\(\\eqref{eq:Khalil_state_equation}\\) can written  \\[\\begin{equation}   \\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x}). \\label{eq:unforced_state_equation} \\end{equation}\\]  Khalil refers unforced state equation: lacks explicit mention inputs. , points , input can specified explicit function time,  \\[\\begin{align}   \\mathbf{u} &= \\boldsymbol\\gamma(t), \\\\   \\intertext{explicit function state,}   \\mathbf{u} &= \\boldsymbol\\gamma(\\mathbf{x}), \\\\   \\intertext{explicit function ,}   \\mathbf{u} &= \\boldsymbol\\gamma(t, \\mathbf{x}), \\end{align}\\]  equation form \\(\\eqref{eq:Khalil_state_equation}\\) can always reduced equation form \\(\\eqref{eq:unforced_state_equation}\\). Khalil goes mention one particular special case class systems described equation \\(\\eqref{eq:unforced_state_equation}\\): namely, autonomous time-invariant. system autonomous function \\(f\\) depend explicitly \\(t\\), ,  \\[\\begin{equation}   \\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x}). \\label{eq:autonomous_state_equation} \\end{equation}\\]  behavior autonomous system invariant shifts time origin. (Formally, however, shall see later Section \\(\\ref{sec:biocro_time}\\), non-autonomous system can made automous one introducing time-related variable state.) falling body system considered autonomous: motion body follow pattern independent released. hand, realistic biological models tend non-autonomous time-varying. largely due influence weather environmental factors; example, matters whether seeds sown March May.","code":""},{"path":"/articles/dynamical_systems.html","id":"the-giunti-mazzola-model","dir":"Articles","previous_headings":"An overview of some abstract dynamical system formulations","what":"The Giunti-Mazzola model","title":"BioCro as a Dynamical System","text":"model due Giunti Mazzola generalization autonomous version Khalil model, though cast somewhat different form. autonomous, respects restrictive general model given \\(\\eqref{eq:Khalil_state_equation}\\); respects considerably general. highlight model two reasons: First, mentioned supplementary materials Lochocki et al. (2022). Second, generalizes concept time used dynamical systems real numbers (Khalil model assumes) monoid. particular, may consider time domains consisting non-negative integers, fixed multiple , non-negative even integers. one natural ways view time discrete-time systems, often arise practice continuous-time systems discretized applying numeric solution methods (Section \\(\\ref{sec:discrete_time}\\)). quote Giunti Mazzola’s definition dynamical system verbatim ( Giunti Mazzola (2012)): \\(DS_L\\) dynamical system \\(L\\) iff \\(DS_L\\) pair \\((M,(g^t)_{t \\T})\\) \\(L\\) pair \\((T, +)\\) \\(L = (T, +)\\) monoid. \\(t \\T\\) called duration system, \\(T\\) called time set, \\(L\\) time model; \\(M\\) non-empty set. \\(x \\M\\) called state system, \\(M\\) called state space; \\((g^t)_{t \\T}\\) family indexed \\(T\\) functions \\(M\\) \\(M\\). \\(t\\T\\), function \\(g^t\\) called state transition duration \\(t\\) (briefly, \\(t\\)-transition, \\(t\\)-advance) system; \\(v,t\\T\\), \\(x\\M\\), \\(g^0(x) = x\\), \\(0\\) unity \\(L\\); \\(g^{v+t}(x) = g^v(g^t(x))\\). Notice can time model now monoid, state space can now non-empty set: longer required subset Euclidean space. needn’t even continuum! fortiori, longer requirement state transitions differential equation based. Instead differential equations, condition (iv.b), sometimes called semi-group property, relates structure time model class state transitions. Just \\(T\\) monoid operation \\(+\\) additive identity \\(0\\), collection \\((g^t)_{t \\T}\\) state transitions, monoid operation function composition identity element identity function. Condition (iv) asserts mapping \\((T, +)\\) \\(((g^t)_{t \\T}, \\circ)\\) whereby \\(t \\mapsto g^t\\) monoid homomorphism. Condition (iv) fact crux definition dynamical system. Without , structure way system evolves: system may pass one state next willy-nilly without constraint relationship states time.","code":""},{"path":"/articles/dynamical_systems.html","id":"the-barreira-valls-model","dir":"Articles","previous_headings":"An overview of some abstract dynamical system formulations","what":"The Barreira-Valls model","title":"BioCro as a Dynamical System","text":"briefly mention one model discrete time case, mainly formulation epitome simplicity. Definition 1.1 Barreira (2019) states simply map \\(f: \\mathbf{X}\\\\mathbf{X}\\) called dynamical system discrete time. definition goes define higher-order mappings: define recursively \\[\\begin{equation*}     f^n = f\\circ f^{n-1} \\end{equation*}\\] \\(n\\\\mathbf{Z}^+\\), convention \\(f^0 = \\operatorname{id}\\). \\(f\\) invertible, also define \\(f^{-n} = (f^{-1})^n\\) \\(n\\\\mathbf{Z}^+\\). entirely homologous Giunti-Mazzola model case monoid chosen time model either \\(\\mathbf{Z}\\) \\(\\mathbf{N}\\). Note recursion equation \\(\\eqref{eq:falling_body_recursion}\\) derived applying Euler’s method falling body problem fits nicely model: take \\(\\mathbf{X}\\) Euclidean 2-space function \\(f\\) defined rule \\[\\begin{equation*}     (x, y) \\mapsto (x + \\delta y, y - \\delta g). \\end{equation*}\\] (Barreira Valls go define “dynamical system continuous time” (Barreira 2019, Definition 1.7) precisely way Giunti Mazzola (case time model \\(\\mathbf{R}\\) \\(\\mathbf{R}_{\\geq 0}\\))—, family mappings indexed time satisfying semi-group property.)","code":""},{"path":"/articles/dynamical_systems.html","id":"the-biocro-model","dir":"Articles","previous_headings":"","what":"The BioCro model","title":"BioCro as a Dynamical System","text":"BioCro system determined specification five entities: set initial values set (constant) parameter values set drivers set direct modules set differential modules five entities tell us everything dynamics system need order “solve” . (, precisely, solved determined specifying solver.)3 Aside differences concept state (Section \\(\\ref{sec:state}\\)), Khalil model fits well idealized version BioCro model time considered continuous.4 see section \\(\\ref{sec:BioCro_systems}\\), discuss two models side--side. first, must elaborate bit Khalil model.","code":""},{"path":"/articles/dynamical_systems.html","id":"elaboration-on-the-khalil-model","dir":"Articles","previous_headings":"The BioCro model","what":"Elaboration on the Khalil model","title":"BioCro as a Dynamical System","text":"Recall Khalil model expresses derivative \\(d\\mathbf{x}/dt\\) state function time \\(t\\), state \\(\\mathbf{x}\\), input \\(\\mathbf{u}\\):  \\[\\begin{equation*}   \\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x}, \\mathbf{u}). \\end{equation*}\\] Let us denote domains \\(\\mathbf{x}\\) \\(\\mathbf{u}\\) (vis-à-vis function \\(\\mathbf{f}\\)) \\(\\mathbf{X}\\) \\(\\mathbf{U}\\). \\(\\mathbf{X}\\) \\(\\mathbf{U}\\) vector spaces reals, following conventions set Section \\(\\ref{sec:notation}\\), may view sets mappings finite index sets reals. Thus  \\[\\begin{align}     \\mathbf{X} = \\mathbf{R}^X \\\\     \\intertext{}     \\mathbf{U} = \\mathbf{R}^U \\end{align}\\]  finite sets \\(X\\) \\(U\\), assume \\(X\\) \\(U\\) disjoint.5 Furthermore, recall Khalil model, value \\(\\mathbf{u}\\) may given function time /state:  \\[\\begin{align*}   \\mathbf{u} &= \\boldsymbol\\gamma(t), \\\\   \\mathbf{u} &= \\boldsymbol\\gamma(\\mathbf{x}), \\\\   \\intertext{}   \\mathbf{u} &= \\boldsymbol\\gamma(t, \\mathbf{x}). \\end{align*}\\]  Thinking terms individual components \\(\\mathbf{u}\\), component \\(u_i\\) \\(\\mathbf{u}\\) can expressed function \\(\\gamma_i\\) \\(t\\) \\(\\mathbf{x}\\) :  \\[\\begin{align*}   u_i &= \\gamma_i(t), \\\\   u_i &= \\gamma_i(\\mathbf{x}), \\\\   \\intertext{}   u_i &= \\gamma_i(t, \\mathbf{x}). \\end{align*}\\]  also possible \\(u_i\\) doesn’t actually depend either time state, fact constant:  \\[\\begin{equation}   u_i = k \\quad \\text{$k\\\\mathbf{R}$}. \\end{equation}\\]  can, fact, partition variables \\(u_0, u_1, \\dots, u_{p-1}\\) comprising varying input \\(\\mathbf{u}\\) three groups: Let \\(u_i\\) group \\(K\\) value \\(u_i\\) depends neither \\(t\\) \\(\\mathbf{x}\\); , always value, matter state time. Let \\(u_i\\) group \\(D\\) value \\(u_i\\) depends \\(t\\) alone. Let \\(u_i\\) group \\(W\\) otherwise, value \\(u_i\\) depends value \\(\\mathbf{x}\\) (possibly also \\(t\\)). Thus \\(U=K\\cup D\\cup W\\), \\(K\\), \\(D\\), \\(W\\) pairwise disjoint. allows us partition vector space \\(\\mathbf{U}\\) corresponding sub-vector spaces \\(\\mathbf{K}\\), \\(\\mathbf{D}\\), \\(\\mathbf{W}\\); ,  \\[\\begin{equation*}   \\mathbf{U} = \\mathbf{K}\\times\\mathbf{D}\\times\\mathbf{W}, \\end{equation*}\\]  \\(\\mathbf{K}=\\mathbf{R}^K\\), \\(\\mathbf{D}=\\mathbf{R}^D\\), \\(\\mathbf{W} = \\mathbf{R}^W\\). input \\(\\mathbf{u}\\) may now written triplet \\((\\mathbf{k}, \\mathbf{d}, \\mathbf{w})\\) \\(\\mathbf{k}\\\\mathbf{K}\\), \\(\\mathbf{d}\\\\mathbf{D}\\), \\(\\mathbf{w}\\\\mathbf{W}\\).6 Moreover, exist functions \\(\\gamma^\\mathbf{D}: T\\\\mathbf{D}\\) \\(\\gamma^\\mathbf{W}: T\\times\\mathbf{X}\\\\mathbf{W}\\) constant function \\(\\gamma^\\mathbf{K}\\) codomain \\(\\mathbf{K}\\)  \\[\\begin{align}   \\mathbf{k} &= \\gamma^\\mathbf{K}(),       \\label{eq:k} \\\\   \\mathbf{d} &= \\gamma^\\mathbf{D}(t),      \\label{eq:d} \\\\   \\intertext{}   \\mathbf{w} &= \\gamma^\\mathbf{W}(t, \\mathbf{x}) \\label{eq:s} \\end{align}\\]  moment life system. Since \\(\\mathbf{u} = (\\mathbf{k}, \\mathbf{d}, \\mathbf{w})\\), can rewrite state equation \\(\\eqref{eq:Khalil_state_equation}\\)  \\[\\begin{equation}   \\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x}, \\mathbf{k}, \\mathbf{d}, \\mathbf{w}). \\label{eq:BioCro_state_equation} \\end{equation}\\]  using equations \\(\\eqref{eq:k}\\), \\(\\eqref{eq:d}\\), \\(\\eqref{eq:s}\\), can eliminate \\(\\mathbf{k}\\), \\(\\mathbf{d}\\), \\(\\mathbf{w}\\) get \\(\\mathbf{f}\\) function \\(t\\) \\(\\mathbf{x}\\) alone:  \\[\\begin{equation}   \\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x}, \\gamma^\\mathbf{K}(), \\gamma^\\mathbf{D}(t), \\gamma^\\mathbf{W}(t, \\mathbf{x})). \\end{equation}\\]  words,  \\[\\begin{equation}   \\dot{\\mathbf{x}} = \\mathbf{f}^{\\,*}(t, \\mathbf{x}) \\end{equation}\\]  suitable function \\(\\mathbf{f}^{\\,*}\\), now unforced state equation equation \\(\\eqref{eq:unforced_state_equation}\\).","code":""},{"path":"/articles/dynamical_systems.html","id":"biocro-viewed-in-terms-of-the-khalil-model","dir":"Articles","previous_headings":"The BioCro model","what":"BioCro viewed in terms of the Khalil model","title":"BioCro as a Dynamical System","text":"BioCro, noted , system determined specify initial values, parameters, drivers, direct modules, differential modules. relate version Khalil model just discussed? initial values correspond state \\(\\mathbf{x}\\) initial time \\(t_0\\), convenience, always take 0. (Thus time always amount time elapsed since start simulation.) denote initial state \\(\\mathbf{x}_0 = (x_{0,0}, x_{1,0}, \\dots, x_{n-1,0})\\). BioCro, state variables referred differential quantities, since evolve according differential equations. initial values specification determines variables comprise state, dimension state space \\(\\mathbf{X}\\) equal number variables \\(\\mathbf{x}_0\\). now, shall consider initial values part definition system far determine set variables comprising state space system. specification values variables time \\(t_0\\) considered something associated particular run system something inherent system . make comparison Khalil Giunti models easier, since models don’t specify anything analogous initial state. follows, need make distinction, shall refer dynamical system together specified initial state run system. also noted, discussed Section \\(\\ref{sec:discrete_time}\\), actually running system (, allowing state evolve initial values) requires use numerical methods effectively discretize continous system differential equations Khalil system. Whether consider development new discrete dynamical system continuous one just matter practical convenience mostly matter perspective. parameters correspond sole value codomain constant function \\(\\gamma^\\mathbf{K}\\). \\(q\\)-tuple values \\(\\mathbf{k} = (k_0, k_1, \\dots, k_{q-1})\\), \\(q\\) number parameters, dimension vector subspace \\(\\mathbf{K}\\). drivers correspond function \\(\\gamma^\\mathbf{D}:T\\\\mathbf{R}^r\\), giving value \\(\\mathbf{d}\\) function time. Writing \\(\\mathbf{d}\\) \\((d_0, d_1, \\dots, d_{r-1})\\), \\(r\\) number driver variables (dimension \\(\\mathbf{D}\\)), can decompose \\(\\gamma^\\mathbf{D}(t)\\) scalar-valued functions \\(\\gamma^\\mathbf{D}_0(t)\\), \\(\\gamma^\\mathbf{D}_1(t)\\), , \\(\\gamma^\\mathbf{D}_{r-1}(t)\\). noted driver functions \\(\\gamma^\\mathbf{D}_i\\) rarely functions can easily specified computed formula. example shown Appendix 1 Lochocki et al. (2022), function giving value driver variable \\(Q\\) corresponding photosynthetic photon flux density based function  \\[\\begin{equation}   Q = \\sin(\\frac{t}{12\\cdot 3600} \\pi)\\cdot 2000 \\times 10^{-6}. \\end{equation}\\]  , \\(t\\) meant represent elapsed time seconds, example, actual values fed BioCro system constructor values \\(Q\\) set integral values \\(t\\), namely, \\(t = 0, 1, 2, \\dots, 43200\\). acknowledged appendix, highly artificial example. Usually, driver variable function can defined via equation7 form  \\[\\begin{equation}     \\gamma^\\mathbf{D}_i(t) = \\begin{cases}         0.046 & \\text{$t = t_0$}, \\\\         0.023 & \\text{$t = t_1$}, \\\\         \\dots \\\\         \\dots \\\\         1151.541 & \\text{$t = t_{4000}$}, \\\\         747.040 & \\text{$t = t_{4001}$}, \\\\         \\dots \\\\         \\dots \\\\         0.621 & \\text{$t = t_{8758}$}, \\\\         0.874 & \\text{$t = t_{8759}$}.     \\end{cases} \\end{equation}\\]  , \\(t_0, t_1, \\dots, t_{8759}\\) sequence times representing amount time elapsed since beginning simulation, \\(t_0 = 0\\), fixed positive value \\(\\Delta t\\), \\(t_{j+1} = t_j + \\Delta t\\) \\(0 \\leq j < 8759\\). practice, BioCro, equation usually specified implicitly via R data frame: \\(\\gamma^\\mathbf{D}_i\\) corresponds column data frame, value column row \\(j\\) value \\(\\gamma^\\mathbf{D}_i\\) time \\(t_{j-1}\\). (numerical methods, need know values \\(\\gamma^\\mathbf{D}_i(t)\\) values \\(t\\) time points given definition. principle, many approaches available type interpolation, cubic splines. moment, BioCro offers linear interpolation neighboring time points. words, additional case added rule:  \\[\\begin{equation}   \\gamma^\\mathbf{D}_i(t) = \\frac{t_{j + 1} - t}{\\Delta t}\\,\\gamma^\\mathbf{D}_i(t_j)                        + \\frac{t - t_j}{\\Delta t}\\,\\gamma^\\mathbf{D}_i(t_{j+1})                        \\quad\\text{$t_j < t < t_{j+1}$} \\end{equation}\\]  makes \\(\\gamma^\\mathbf{D}_i(t)\\) piecewise-linear continuous function.) Now modules. show later (Section \\(\\ref{sec:modularization}\\)), BioCro system equivalent BioCro system single module type, initial values, parameters, drivers.8 Thus, simplicity, consider case single module type.9 Later, consider single module may broken multiple modules (Section \\(\\ref{sec:modularization}\\)). direct module corresponds function \\(\\gamma^\\mathbf{W}: T\\times\\mathbf{X} \\\\mathbf{W}\\). point fact, usually think direct module corresponding function \\({}^*\\gamma^\\mathbf{W}: \\mathbf{X}\\times\\mathbf{K}\\times\\mathbf{D} \\\\mathbf{W}\\), using equations \\(\\eqref{eq:k}\\) \\(\\eqref{eq:d}\\) substituting, can derive function \\(\\gamma^\\mathbf{W}\\) gives value \\(\\mathbf{w}\\) function \\(t\\) \\(\\mathbf{x}\\) alone. Note particular number output variables direct module gives dimension \\(\\mathbf{W}\\) component \\(\\mathbf{U}\\). call variables direct quantities system (lack better term) since outputs direct module. Two observations made . First, general case, multiple direct modules \\(\\mathcal{M}_1, \\mathcal{M}_2, \\dots\\) used construction system, modules may depend outputs direct modules. case, module \\(\\mathcal{M}_i\\) corresponds function form  \\[\\begin{equation}   \\gamma^{\\mathbf{W}_i}: \\mathbf{X}\\times\\mathbf{K}\\times\\mathbf{D}\\times\\mathbf{\\overline{W}}_i \\\\mathbf{W}_i, \\end{equation}\\]  \\(\\mathbf{W}_i\\) subspace \\(\\mathbf{W}\\) generated variables output module \\(\\mathcal{M}_i\\) \\(\\mathbf{\\overline{W}}_i\\) subspace \\(\\mathbf{W}\\) generated inputs module \\(\\mathcal{M}_i\\) \\(X\\), \\(K\\), \\(D\\). (direct module’s inputs outputs required disjoint. Thus \\(\\mathbf{\\overline{W}}_i\\) complementary \\(\\mathbf{W}_i\\), \\(\\mathbf{W}_i \\times \\mathbf{\\overline{W}}_i\\) subspace \\(\\mathbf{W}\\).) discuss section modularization (Section \\(\\ref{sec:modularization}\\)). Second, mentioned Khalil model allows inclusion output function  \\[\\begin{equation}   \\mathbf{y} = \\mathbf{h}(t, \\mathbf{x}, \\mathbf{u}). \\end{equation}\\]  Khalil says output vector \\(\\mathbf{y}\\) “comprises variables particular interest analysis dynamical systems .” Khalil model, variables, unlike variables comprise \\(\\mathbf{u}\\), part state equation. informational purposes . closest analogue variables BioCro variables outputs direct module system inputs differential module. example variables BioCro library kinetic energy, spring energy, total energy outputs harmonic energy module (class harmonic_energy). exist give information system using module since (least writing) existing modules use inputs. differential module corresponds function \\(\\mathbf{f}\\) equation \\(\\eqref{eq:BioCro_state_equation}\\). Khalil state equation, \\(\\mathbf{u}\\) divided components \\(\\mathbf{k}\\), \\(\\mathbf{d}\\), \\(\\mathbf{w}\\). primary constraint differential module output variables must differential quantities (, equivalently, state variables), determined initial values specification discussed . (BioCro doesn’t require state variables included differential module outputs: state variable \\(x_i\\) , assumed \\(\\dot{x}_i = 0\\); , component state remains constant throughout life system.)","code":""},{"path":"/articles/dynamical_systems.html","id":"biocros-concept-of-time","dir":"Articles","previous_headings":"The BioCro model","what":"BioCro’s concept of time","title":"BioCro as a Dynamical System","text":"C++ interface BioCro library, one required user-facing time-related variable—namely, quantity timestep, must provided one (possibly ) parameters setting system.10 (R interface, always three additional quantities—doy, hour, time—always come play set run system. artifacts certain aspects R interface subject revision, mostly ignore .) timestep quantity, however, gives rise implicit quantity, elapsed time, corresponds well time variable used Khalil Giuli-Mazzola models.11 timestep, fact, denotes amount time elapses successive values driver variables.12 Time often shows explicitly BioCro system form specific date time, value driver variable date time; example, information drivers parameter may able make assertions  “3 p.m. April 15, 2005” sort time Giunti model deals. Times—durations—Giunti model members monoid, can add together get another time monoid. can add   meaningful way get date-time. can, however, add durations: can, example, look state system one hour initial state system, look state two hours later, second observation three hours time corresponding system’s initial state (since \\(2 + 1 = 3\\)). hinted , timestep quantity generates monoid: value timestep \\(\\delta\\), members monoid \\(0, \\delta, \\delta + \\delta, \\delta + \\delta + \\delta, \\delta + \\delta + \\delta + \\delta, \\dots\\), ad infinitum. course, BioCro, don’t let system simulations run forever, set times dealt given run system doesn’t really quite form monoid add \\(\\delta\\) final time point simulation, get time outside domain simulation. Conceptually, can deal problem (reconciling BioCro’s concept time Giunti model) imagining system simulations run forever let (knowledge infinitely far future driver variables happened using); imagine instead, choose look behavior system finite period time.","code":""},{"path":"/articles/dynamical_systems.html","id":"biocros-concept-of-state","dir":"Articles","previous_headings":"The BioCro model","what":"BioCro’s concept of state","title":"BioCro as a Dynamical System","text":"BioCro, level module, input quantities considered uniformly. good reasons , reasons go beyond mere programmatic convenience. example, input module might one system determined mechanistically output module; different system, might come data observations thereby one drivers. module using input doesn’t care comes . set system, however, quantity falls neatly one four categories: either parameter, driver, differential quantity, direct quantity. (correspond, respectively, subspaces \\(\\mathbf{K}\\), \\(\\mathbf{D}\\), \\(\\mathbf{X}\\), \\(\\mathbf{W}\\) discussed Sections \\(\\ref{sec:khalil_elaboration}\\) \\(\\ref{sec:BioCro_systems}\\) arguments \\(\\mathbf{k}\\), \\(\\mathbf{d}\\), \\(\\mathbf{x}\\), \\(\\mathbf{w}\\) state equation form given equation \\(\\eqref{eq:BioCro_state_equation}\\).) uniform treatment quantities module level reflected C++ code used implement BioCro simulations: quantity used given system incorporated C++ structure user-defined type called state_map, maps names quantities value quantities particular time. naturally leads referring aggregate values quantities system particular point time state system time. Thus, Khalil’s model distinguishes betwee state inputs, term state used BioCro refers parameters, drivers, differential quantities, direct quantities whole (equivalent Khalil’s state drivers). section attempts reconcile conception state commonly used dynamical systems theory, particular, formulations presented chapter \\(\\ref{sec:formulations}\\). Elsewhere document, use term state exclusively reference usual definition employed Khalil, Giuli-Mazzola, Barreira-Valls models. discussing BioCro, refer state variables differential quantities avoid misrepresenting BioCro’s idea state. section, however, must necessarily use state refer conceptions, try clarify definition meant whenever unclear context.","code":""},{"path":"/articles/dynamical_systems.html","id":"biocro-state-and-the-khalil-model","dir":"Articles","previous_headings":"The BioCro model > BioCro’s concept of state","what":"BioCro state and the Khalil model","title":"BioCro as a Dynamical System","text":"Khalil remarks state variables “represent memory dynamical system past.” Laplace (Dale 1995) remarks, “consider present state universe effect previous state cause follow.” inputs model, hand, general completely arbitrary. determined state past future values. help determine, determined , evolution state system. sense, like hand experimenter-god touching influencing otherwise mechanistically-determined system. BioCro, inputs considered part state, partly matter convenience; , convenience aside, also philosophical justification : many systems, inputs may clearly thought somehow external system. studying electrical circuit, example, experimenter may apply electrical inputs system see system responds. Even controlled plant-growth experiment conducted climate-controlled greenhouse, environmental inputs may applied somewhat arbitrarily. BioCro, contrast, inputs (drivers) usually related weather aspects environment—temperature, humidity, radiation, . Unlike controlled experiment, environmental variables evolve according laws; control experimenter. truly comprehensive model, laws evolution included right alongside laws determining plant growth. generally, overly complicate model, large, given inherently chaotic nature meteorological processes vast amounts additional data required, feasible . BioCro, regard part system—part state system—part taken given rather part derived general rules governing evolution natural systems. None say, course, BioCro can’t also used model controlled experiments, carried greenhouse; model “thought experiments” “” scenarios: happen used weather data 2005 assumed much higher \\(\\text{CO}_\\text{2}\\) concentration?","code":""},{"path":"/articles/dynamical_systems.html","id":"biocro-state-and-the-giunti-model","dir":"Articles","previous_headings":"The BioCro model > BioCro’s concept of state","what":"BioCro state and the Giunti model","title":"BioCro as a Dynamical System","text":"Giunti Mazzola’s model definition cited supplementary materials Lochocki et al. (2022) justification considering quantities involved system (except time) part state. Whatever merits argument, retrospect, possibly amounts sort cherry-picking Giunti-Mazzola definition altogether clear whether BioCro dynamical systems, envisioned paper, , general, collection well-defined transition functions \\((g^t)_{t \\T}\\). Whether turns question interpret stipulation, given supplement, “term state used refer quantities involved system, except time.” demonstrate , BioCro system drivers include time-like variable amongst drivers , general, conform Giunti model. see , let us consider typical BioCro system driver component consists values number weather-related variables course year, suppose variables happen values two different times; example, suppose weather 1 p.m. April 12, 2008 exactly weather 3 p.m. May 16, 2008 extent weather captured attributes model. Moreover, suppose system might typical array differential variables—namely, describe state growth plant subjected environment described driver variables system. Consider now two identical states—one, \\(s_1\\), corresponding seedling planted 1 p.m. April 12, 2008, one, \\(s_2\\), corresponding identical seedling planted 3 p.m. May 16, 2008. states identical attributes seedlings, described differential variables, identical, attributes weather, described driver variables, also identical; parameters (constant) identical, values “direct” variables, functions three components, also identical. (Recall specifically excluding date time notion state .) words, \\(s_1 = s_2\\). Now consider one transition functions \\(g^t\\)—say, example, function \\(g^u\\), \\(u\\) corresponds duration 30 days. \\(g^u(s_1)\\) state corresponding attributes seedling planted April 12 environment one month later, May 12, 2008. \\(g^u(s_2)\\) state corresponding attributes seedling planted May 16 environment approximately one month later, June 15. weather 1 p.m. May 12, 2008 identical 3 p.m. June 15, 2008? According Giunti model, , since \\(s_1 = s_2\\) implies state \\(g^u(s_1)\\) equals state \\(g^u(s_2)\\); two states equal, components state describe weather equal well. know something wrong , even weather occurs two different times, can’t expect weather patterns going forward develop way. Moreover, likelyhood identical seedlings planted April 12 May 16 longer identical 30 days later likely subjected different weather conditions. two ways (least) predicament. One ensure driver component state never repeats . monotonically-increasing driver variable trick, natural way ensuring repetitions probably include representation time, calendar date time, Julian date, reduced Julian date, Unix time part driver component state. (R interface BioCro fact requires either day--year hour day driver variables requires monotonically-increasing variable called time. C++ interface, however, requires neither .) second way, one makes system formally time-independent, modify driver component notion state. scheme, driver component state just array values driver variables happen particular time. Now, instead, encapsulation future driver variable values indefinitely far future. One way imagine , thinking drivers corresponding weather, think driver component state particular time weather prediction giving weather time every future time, .e., weather one day now, two days now, ; moreover, just prediction, 100% accurate one. state now, without include date time, encapsulates information need order know state \\(x\\) amount time future. bring show even presence drivers (inputs, Khalil’s terminology), notion autonomous system possible. can systems conform Giunti model without requiring states different dates distinct. example, imagine greenhouse experiment climate conditions greenhouse repeat exactly pattern one day next. system, driver state noon—“weather” prediction moment going forward (one hour later, 10 hours later, 10 days later)—exactly one day next. evolution generic seedling: evolution seedling planted noon one day evolution identical seedling planted noon twenty days later. practical terms, however, rather complicated model. state space longer Euclidean space, since \\(\\mathbf{D}\\), driver component state space, longer Euclidean space \\(\\mathbf{R}^r\\) instead set \\((\\mathbf{R}^r)^T\\) functions \\(\\gamma^\\mathbf{D}: T \\\\mathbf{R}^r\\). (Note state transition duration \\(u\\) restricted \\(\\mathbf{D}\\) component state least easily defined: \\(\\gamma\\) \\(\\mathbf{D}\\) component state \\(\\mathbf{s}\\), \\(g^u(\\gamma)\\) function defined rule \\(t \\mapsto \\gamma(u + t)\\).) upshot Giunti model naturally describe BioCro system drivers unless proxy time allowed component drivers. also noted BioCro make use two important generalizations Giunti model: BioCro, state space always subset (fact, connected subset) Euclidean space, state transitions (using state Khalil’s sense) always differential equation based. Thus, find Khalil’s model provides better description BioCro systems.","code":""},{"path":"/articles/dynamical_systems.html","id":"the-state-space-as-a-manifold","dir":"Articles","previous_headings":"The BioCro model > BioCro’s concept of state","what":"The state space as a manifold","title":"BioCro as a Dynamical System","text":"One arguments given supplementary materials Lochocki et al. (2022) considering variables state variables “division state auxiliary variables arbitrary.” Whether compelling argument considering “quantities equal”, statement , least formal level, largely true, least case variables mutually determine one another. stated conclusion Appendix II Mesarović Takahara (1975), starting point modeling observations assumption existence relationships . primary concept system definable just much data. Whether relationship can described transition state space point needs proven. Even possible, state space unique, indicates secondary nature concept state [emphasis mine]. , authors presumably using state less comprehensive sense, distinguished system inputs outputs, though conceivably simply mean attributes choose observe codify notion state unique; sake argument, ’ll assume mean least former. (authors, fact, hint altogether different view meant state system. view, everything can observed system encompassed system’s inputs outputs: system essentially black box, responds given inputs particular time always . unobservable aspects system come play. unobservables constitute state system, responds given time given inputs depends state happens . helpful analogy might notion person’s state mind determinant might react particular event.) However expansive choose make notion state, one thing clear: choose regard parameters, drivers, relationship quantities embodied direct modules constraints state space systems, given state lies state space, can fully specify state using values -called differential variables (plus time); values quantities can determined . Thus, total number quantites system (including time) \\(n\\), number differential variables \\(k\\), state space may viewed \\(k+1\\)-dimensional manifold embedded Euclidean \\(n\\)-space \\(\\mathbf{R}^n\\). Put another way, matter many variables use describe state system, still \\(k+1\\) degrees freedom: parameters can take one value, time variable determines values driver variables, values together values differential variables determine values remaining variables, direct variables. analogy may help make clearer: Say wish consider points earth. don’t limit points surface, specify points three coordinates—longitude, latitude, altitude. Large values altitude correspond points earth’s surface, negative values usually correspond points earth’s interior. considering arbitrary points three-dimensional space, makes sense need three coordinates fully specify point. suppose now say want consider points earth’s surface. Given constraint, understanding going try describe points surface earth, can get two coordinates: need specify longitude latitude. include third number, altitude, well (provided know ), now necessary, understood point lies earth’s surface. consider system whose state comprises location given object surface earth, state space surface, two-dimensional space embedded Euclidean 3-space. Note example, matters two coordinates choose describing states. Generally, , example, suffice know altitude longitude, since, given choice altitude longitude, may many points various latitudes match. (exceptional cases, course: specify altitude 8848.86 (meters), even without specified longitude latitude (let alone ), know object top Mount Everest.13)","code":""},{"path":"/articles/dynamical_systems.html","id":"modularization-in-biocro","dir":"Articles","previous_headings":"The BioCro model","what":"Modularization in BioCro","title":"BioCro as a Dynamical System","text":"mentioned Section \\(\\ref{sec:BioCro_systems}\\), BioCro system can replaced equivalent system using single module type. merely write one direct module one differential module, (respectively) combines effects individual direct differential modules used original system. use “merely” advisedly , one main strengths BioCro ability modularize, wide repertoire modules choose , can choose combine whatever way useful, without write new module time want tweak aspect system whole. section, look combining modules formal level, delineating requirements using two modules place one effects . start differential module case since simpler two.","code":""},{"path":"/articles/dynamical_systems.html","id":"modularization-of-the-derivative-function","dir":"Articles","previous_headings":"The BioCro model > Modularization in BioCro","what":"Modularization of the derivative function","title":"BioCro as a Dynamical System","text":"mentioned Section \\(\\ref{sec:BioCro_systems}\\), BioCro system uses single differential module, module corresponds function \\(\\mathbf{f}\\) Khalil state equation \\(\\eqref{eq:BioCro_state_equation}\\). shall henceforth refer \\(\\mathbf{f}\\) derivative function system. turns , BioCro, derivative function never depends \\(t\\) directly; temporal dependence function \\(\\mathbf{f}\\), always via driver variable differential variable. (Recall \\(t\\) represents elapsed time BioCro system; although calculations may depend time year time day, depend elapsed time.) Therefore, can rewrite equation \\(\\eqref{eq:BioCro_state_equation}\\)  \\[\\begin{equation}   \\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x}, \\mathbf{k}, \\mathbf{d}, \\mathbf{w}). \\end{equation}\\]  Thus, \\(\\mathbf{f}: \\mathbf{X}\\times\\mathbf{K}\\times\\mathbf{D}\\times\\mathbf{W}\\\\mathbf{X}\\). , shall adopt BioCro’s notion state space denote \\(\\mathbf{S}\\),  \\[\\begin{equation*}     \\mathbf{S} = \\mathbf{X}\\times\\mathbf{K}\\times\\mathbf{D}\\times\\mathbf{W}. \\end{equation*}\\]  \\(\\mathbf{f}\\) function \\(\\mathbf{f}: \\mathbf{S} \\\\mathbf{X}\\), state equation, shall now refer derivative equation, just  \\[\\begin{equation}   \\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{s}), \\end{equation}\\]  \\(\\mathbf{s}\\) denotes state state space \\(\\mathbf{S}\\). general, can write state \\(\\mathbf{s}\\) terms coordinate variables describing component spaces; ,  \\[\\begin{equation*}     \\mathbf{s} = (x_0, x_1, \\dots, x_{n-1}, k_0, k_1, \\dots,                k_{q-1}, d_0, d_1, \\dots, d_{r-1}, w_0, w_1, \\dots, w_{s-1}) \\end{equation*}\\]  \\(n\\), \\(q\\), \\(r\\), \\(s\\) dimensions component spaces \\(\\mathbf{X}\\), \\(\\mathbf{K}\\), \\(\\mathbf{D}\\), \\(\\mathbf{W}\\), respectively. talk decomposing derivative function system, first describe mean valid differential module BioCro system. Let \\(X = \\{x_0, x_1, \\dots, x_{n-1}\\}\\) set differential variables system, let  \\[\\begin{equation*}     S = \\{x_0, x_1, \\dots, x_{n-1}, k_0, k_1, \\dots, k_{q-1},           d_0, d_1, \\dots, d_{r-1}, w_0, w_1, \\dots, w_{s-1}\\} \\end{equation*}\\]  set coordinate variables needed specify state state space system. \\(\\mathcal{M}\\) valid differential module system input variables contained \\(S\\) output variables contained \\(X\\). Let \\(\\mathbf{M}_\\text{}\\) vector subspace \\(\\mathbf{S}\\) generated input variables \\(\\mathcal{M}\\) let \\(\\mathbf{M}_\\text{}\\) vector subspace \\(\\mathbf{X}\\) generated output variables \\(\\mathcal{M}\\). derivative function \\(\\mathcal{M}\\) function  \\[\\begin{equation*}     \\hat{\\mathbf{f}}_\\mathbf{M}: \\mathbf{M}_\\text{} \\\\mathbf{M}_\\text{}. \\end{equation*}\\]  function, may associate unique function \\(\\mathbf{f}_\\mathbf{M}: \\mathbf{S} \\\\mathbf{X}\\) follows: Let \\(\\pmb{\\pi}\\) projection \\(\\mathbf{S}\\) onto \\(\\mathbf{M}_\\text{}\\), let \\(\\pmb{\\iota}\\) injective function \\(\\mathbf{M}_\\text{}\\) \\(\\mathbf{X}\\) assigns coordinate \\(X\\) output variable \\(\\mathcal{M}\\) value zero. define  \\[\\begin{equation*}     \\mathbf{f}_\\mathbf{M} = \\pmb{\\iota} \\circ \\hat{\\mathbf{f}}_\\mathbf{M} \\circ \\pmb{\\pi}:         \\mathbf{S} \\stackrel{\\pmb{\\pi}}{\\} \\mathbf{M}_\\text{}                \\stackrel{\\hat{\\mathbf{f}}_\\mathbf{M}}{\\longrightarrow} \\mathbf{M}_\\text{}                \\stackrel{\\pmb{\\iota}}{\\} \\mathbf{X}. \\end{equation*}\\]  shall call function \\(\\mathbf{f}_\\mathbf{M}\\) system-complete derivative function \\(\\mathcal{M}\\). Now suppose collection \\(\\{\\mathcal{M}_1, \\mathcal{M}_2, \\dots, \\mathcal{M}_m\\}\\) differential modules assumed consistent (rest ) system, let \\(\\{\\mathbf{f}_\\mathbf{M_1}, \\mathbf{f}_\\mathbf{M_1}, \\dots, \\mathbf{f}_\\mathbf{M_m}\\}\\) corresponding system-complete derivative functions. combined derivative function \\(\\{\\mathcal{M}_1, \\mathcal{M}_2, \\dots, \\mathcal{M}_m\\}\\) function  \\[\\begin{equation*}     \\mathbf{f} = \\sum_{\\\\{1, 2, \\dots, m\\}} \\mathbf{f}_\\mathbf{M_i}, \\end{equation*}\\]  defined rule \\[\\begin{equation*}     \\mathbf{s} \\mapsto \\sum_{\\\\{1, 2, \\dots, m\\}} \\mathbf{f}_\\mathbf{M_i}(\\mathbf{s}). \\end{equation*}\\]  \\(\\{\\mathcal{M}_1, \\mathcal{M}_2, \\dots, \\mathcal{M}_m\\}\\) comprise differential modules system, \\(\\mathbf{f}\\) system’s derivative function. words, outputs individual differential module treated terms must added together form full derivative. module, system-complete derivative function defined calculates values elements \\(X\\), setting rest 0. , output system-complete derivative function can added together form full derivative. operation performed combined derivative function. always write single differential module \\(\\mathcal{M}\\) \\(\\mathbf{f}\\) system-complete derivative function use place collection modules \\(\\{\\mathcal{M}_1, \\mathcal{M}_2, \\dots, \\mathcal{M}_m\\}\\) system uses . module likely combine several mechanistic bio-systems concepts, one strengths BioCro ability tweak one mechanistic model without rewrite multiple modules might use .","code":""},{"path":"/articles/dynamical_systems.html","id":"decomposing-the-direct-module-function","dir":"Articles","previous_headings":"The BioCro model > Modularization in BioCro","what":"Decomposing the direct module function","title":"BioCro as a Dynamical System","text":"Let \\(\\mathcal{S}\\) BioCro system, let \\(\\mathbf{S} = \\mathbf{X}\\times\\mathbf{K}\\times\\mathbf{D} \\times \\mathbf{W}\\) state space \\(\\mathcal{S}\\). mentioned Section \\(\\ref{sec:BioCro_systems}\\), direct module component BioCro system \\(\\mathcal{S}\\) corresponds function  \\[\\begin{equation}     \\gamma^\\mathbf{W}: \\mathbf{X}\\times\\mathbf{K}\\times\\mathbf{D} \\\\mathbf{W} \\label{eq:dir_mod_component_fn} \\end{equation}\\]  determines value “direct variable” component state value components. convenience follows, shall write \\(\\mathbf{H}\\) abbreviate cross product \\(\\mathbf{X}\\times\\mathbf{K}\\times\\mathbf{D}\\). Thus may write \\(\\eqref{eq:dir_mod_component_fn}\\)  \\[\\begin{equation*}     \\gamma^\\mathbf{W}: \\mathbf{H} \\\\mathbf{W}. \\end{equation*}\\] general, however, direct module component system subdivided two submodules. section, show ordered sum two modules (notion defined ) module; key understanding modularize direct module function. mentioned Section \\(\\ref{sec:BioCro_systems}\\), system one direct module, constituent module \\(\\mathcal{M}_i\\) corresponds function  \\[\\begin{equation}   \\gamma^{\\mathbf{W}_i}: \\mathbf{X}\\times\\mathbf{K}\\times\\mathbf{D}\\times\\mathbf{\\overline{W}}_i \\\\mathbf{W}_i, \\end{equation}\\]  , using abbreviation used ,  \\[\\begin{equation}   \\gamma^{\\mathbf{W}_i}: \\mathbf{H}\\times\\mathbf{\\overline{W}}_i \\\\mathbf{W}_i. \\label{eq:dir_mod_fn} \\end{equation}\\] Letting \\(H\\) denote set variables corresponding \\(\\mathbf{H}\\) denoting input output variables module \\(\\mathcal{M}_i\\) \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\) \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\) respectively, can write  \\[\\begin{align*}     \\mathbf{W}_i &= \\mathbf{R}^{\\operatorname{\\mathbf{}}\\mathcal{M}_i} \\\\     \\intertext{}     \\mathbf{\\overline{W}}_i &= \\mathbf{R}^{\\operatorname{\\mathbf{}}\\mathcal{M}_i\\smallsetminus H}, \\end{align*}\\]  \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\) \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\) disjoint, since direct modules never share inputs outputs.14 Note may case \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\subseteq H\\); case \\(\\mathbf{\\overline{W}}_i\\) 0-dimensional \\(\\ref{eq:dir_mod_fn}\\) reduces  \\[\\begin{equation*}     \\gamma^{\\mathbf{W}_i}: \\mathbf{H} \\\\mathbf{W}_i. \\end{equation*}\\] \\(H\\) corresponds union differential variables, parameters, driver variables system. Usually, case given direct module system use variables \\(H\\): variables \\(H\\) affect value output, even listed list returned module’s get_inputs() function. always potentially available use direct module, follows, convenient assume direct module inputs include variables \\(H\\); , \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\supseteq H\\), direct modules \\(\\mathcal{M}_i\\). way, thing changes domain module function various direct modules \\(\\mathbf{\\overline{W}}_i\\) component \\(\\mathbf{H}\\times\\mathbf{\\overline{W}}_i\\). simplify exposition follows. (take simple example formal dependence versus actual dependence, consider two-variable function \\(f(x,y)\\) defined rule \\((x,y)\\mapsto x^2\\). Formally, function two variables \\(x\\) \\(y\\). value function never actually depends value \\(y\\).)","code":""},{"path":"/articles/dynamical_systems.html","id":"the-ordered-sum-of-two-direct-modules","dir":"Articles","previous_headings":"The BioCro model > Modularization in BioCro > Decomposing the direct module function","what":"The ordered sum of two direct modules","title":"BioCro as a Dynamical System","text":"Suppose \\(\\mathcal{M}_i\\) \\(\\mathcal{M}_j\\) two direct modules disjoint sets output variables (, \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\cap\\operatorname{\\mathbf{}}\\mathcal{M}_j=\\emptyset\\)), suppose also none outputs \\(\\mathcal{M}_j\\) inputs \\(\\mathcal{M}_i\\); , \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\cap\\operatorname{\\mathbf{}}\\mathcal{M}_j=\\emptyset\\). Let \\(f\\) \\(g\\) corresponding functions. convenience, put  \\[\\begin{align*}     &=\\operatorname{\\mathbf{}}\\mathcal{M}_i \\\\     B &=\\operatorname{\\mathbf{}}\\mathcal{M}_i \\\\     C &=\\operatorname{\\mathbf{}}\\mathcal{M}_j \\\\     \\intertext{}     D &=\\operatorname{\\mathbf{}}\\mathcal{M}_j, \\end{align*}\\]   \\[\\begin{align*}     f&: \\mathbf{R}^\\\\mathbf{R}^B \\\\     \\intertext{}     g&: \\mathbf{R}^C \\\\mathbf{R}^D, \\end{align*}\\]  \\(\\cap B=C\\cap D=\\cap D=B\\cap D=\\emptyset\\). point, possible see might combine two direct modules come something module; key think terms module inputs outputs: Given mappings values \\(\\) values \\(C\\) aren’t \\(B\\), can obtain mappings values \\(B\\) \\(D\\) follows: Since know inputs \\(\\) module \\(\\mathcal{M}_i\\), can use module obtain outputs \\(B\\). Now know inputs \\(C\\) module \\(\\mathcal{M}_j\\)—aren’t \\(B\\) (given outset), \\(B\\) (obtained applying module \\(\\mathcal{M}_i\\)). yields outputs \\(D\\) module \\(\\mathcal{M}_j\\). can also describe formally, now proceed . define \\(\\mathcal{M}_i + \\mathcal{M}_j\\), ordered sum \\(\\mathcal{M}_i\\) \\(\\mathcal{M}_j\\), direct module whose corresponding function  \\[\\begin{equation}     f\\ast g: \\mathbf{R}^{ \\cup (C\\smallsetminus B)}\\\\mathbf{R}^{ B\\cup D} \\label{eq:ordered_sum_function} \\end{equation}\\]  defined  \\[\\begin{equation}     f\\ast g = (f\\circ\\pi^{ \\cup (C\\smallsetminus B)\\})               \\cup               (g\\circ(                 \\pi^{ \\cup (C\\smallsetminus B)                      \\C\\smallsetminus B}                   \\cup                 (\\pi^{ B\\C\\cap B}\\circ                 f\\circ                 \\pi^{ \\cup (C\\smallsetminus B)\\}))). \\label{eq:ordered_sum} \\end{equation}\\]  (Note \\(B\\cap C=\\emptyset\\), \\(C\\smallsetminus B=C\\), \\(\\ref{eq:ordered_sum}\\) reduces  \\[\\begin{equation}     f\\ast g = (f\\circ\\pi^{ \\cup C\\})               \\cup               (g\\circ\\pi^{ \\cup C \\C}). \\end{equation}\\]  case, ordering immaterial, \\(\\mathcal{M}_j+\\mathcal{M}_i=\\mathcal{M}_i+\\mathcal{M}_j\\), \\(g\\ast f=f\\ast g\\).) Recalling inputs outputs direct module function must disjoint, can check indeed case sum. First note whenever can take ordered sum two modules \\(\\mathcal{M}_i\\) \\(\\mathcal{M}_j\\),  \\[\\begin{align}     \\operatorname{\\mathbf{}}(\\mathcal{M}_i+\\mathcal{M}_j) &= \\operatorname{\\mathbf{}}\\mathcal{M}_i \\cup (\\operatorname{\\mathbf{}}M_j\\smallsetminus \\operatorname{\\mathbf{}}\\mathcal{M}_i) \\label{eq:input_of_sum} \\\\     \\intertext{}     \\operatorname{\\mathbf{}}(\\mathcal{M}_i+\\mathcal{M}_j) &= \\operatorname{\\mathbf{}}\\mathcal{M}_i\\cup\\operatorname{\\mathbf{}}\\mathcal{M}_j. \\label{eq:output_of_sum} \\end{align}\\]  (fact set inputs ordered sum \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i \\cup (\\operatorname{\\mathbf{}}M_j\\smallsetminus \\operatorname{\\mathbf{}}\\mathcal{M}_i)\\) readily apparent \\(\\ref{eq:ordered_sum_function}\\): domain \\(f\\ast g\\) \\(\\mathbf{R}^{ \\cup (C\\smallsetminus B)}\\) corresponds inputs corresponding module \\(\\cup (C\\smallsetminus B)\\), just \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i \\cup (\\operatorname{\\mathbf{}}M_j\\smallsetminus \\operatorname{\\mathbf{}}\\mathcal{M}_i)\\). Similarly outputs.) Using ,  \\[\\begin{alignat*}{2}     \\operatorname{\\mathbf{}}(\\mathcal{M}_i+\\mathcal{M}_j) \\cap \\operatorname{\\mathbf{}}(\\mathcal{M}_i+\\mathcal{M}_j) &=\\;&&         (\\operatorname{\\mathbf{}}\\mathcal{M}_i \\cup (\\operatorname{\\mathbf{}}M_j \\smallsetminus \\operatorname{\\mathbf{}}\\mathcal{M}_i)) \\cap         (\\operatorname{\\mathbf{}}\\mathcal{M}_i \\cup \\operatorname{\\mathbf{}}\\mathcal{M}_j)             \\quad \\text{\\ref{eq:input_of_sum} \\ref{eq:output_of_sum}} \\\\         &= &&(\\operatorname{\\mathbf{}}\\mathcal{M}_i \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_i) \\\\            &&&        \\cup               (\\operatorname{\\mathbf{}}\\mathcal{M}_i \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_j) \\\\            &&&        \\cup               ((\\operatorname{\\mathbf{}}M_j \\smallsetminus \\operatorname{\\mathbf{}}\\mathcal{M}_i) \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_i) \\\\            &&&        \\cup               ((\\operatorname{\\mathbf{}}M_j \\smallsetminus \\operatorname{\\mathbf{}}\\mathcal{M}_i) \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_j)                  \\qquad \\text{distributivity $\\cap$ $\\cup$} \\\\         &= &&\\emptyset \\cup \\emptyset \\cup \\emptyset \\cup \\emptyset \\\\         &= &&\\emptyset \\end{alignat*}\\]  intersections distributive expansion empty easily verified: \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_i\\) \\((\\operatorname{\\mathbf{}}M_j \\smallsetminus \\operatorname{\\mathbf{}}\\mathcal{M}_i) \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_j)\\) empty consequence direct modules non-overlapping inputs outputs. \\((\\operatorname{\\mathbf{}}M_j \\smallsetminus \\operatorname{\\mathbf{}}\\mathcal{M}_i) \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_i\\) must empty since member \\(\\operatorname{\\mathbf{}}M_J\\) \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\) can’t also \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\). Finally, \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\cap\\operatorname{\\mathbf{}}\\mathcal{M}_j=\\emptyset\\) stipulation made defining ordered sum \\(\\mathcal{M}_i\\) \\(\\mathcal{M}_j\\). Equation \\(\\ref{eq:ordered_sum}\\) perhaps requires little explication order comprehended. Suppose given value \\(\\mathbf{x}\\) \\(\\mathbf{R}^{ \\cup (C\\smallsetminus B)}\\), domain \\(f\\ast g\\). can describe \\((f\\ast g)(\\mathbf{x})\\\\mathbf{R}^{ B\\cup D}\\) describing way compute \\((f\\ast g)(\\mathbf{x})\\) maps \\(y\\B\\cup D\\) \\(\\mathbf{R}\\). First suppose \\(y\\B\\). need look first component union right-hand side \\(\\ref{eq:ordered_sum}\\)—namely, \\(f\\circ\\pi^{ \\cup (C\\smallsetminus B)\\}\\). projection \\(\\pi^{ \\cup (C\\smallsetminus B)\\}(\\mathbf{x}) = \\mathbf{x}|\\) \\(\\mathbf{x}\\) \\(\\mathbf{R}^\\) tells us need consider coordinates \\(\\mathbf{x}\\) correspond members \\(\\). vector \\(\\mathbf{R}^\\), can apply function \\(f\\) obtain value \\(\\mathbf{R}^B\\). need, since \\(y\\) \\(B\\). Now suppose \\(y\\D\\). need look somewhat complicated second component right-hand side \\(\\ref{eq:ordered_sum}\\), , \\(g\\circ(\\pi^{ \\cup (C\\smallsetminus B) \\C\\smallsetminus B} \\cup (\\pi^{ B\\C\\cap B}\\circ f\\circ \\pi^{ \\cup (C\\smallsetminus B)\\}))\\). Since \\(g: \\mathbf{R}^C\\\\mathbf{R}^D\\), need feed \\(g\\) value \\(\\mathbf{R}^C\\) obtain mapping \\(\\mathbf{R}\\) values (\\(y\\)) \\(D\\). \\(\\mathbf{x}\\) \\(\\mathbf{R}^{\\cup(C\\smallsetminus B)}\\), \\(\\mathbf{x}\\) tells values \\(C\\) aren’t also \\(B\\) mapped. mapping values corresponds projection \\(\\pi^{ \\cup (C\\smallsetminus B) \\C\\smallsetminus B}(\\mathbf{x}) = \\mathbf{x}|(C\\smallsetminus B)\\), value \\(\\mathbf{R}^{C\\smallsetminus B}\\). find portion mapping need belongs \\(\\mathbf{R}^{C\\cap B}\\), look \\(\\pi^{ B\\C\\cap B}\\circ f\\circ \\pi^{ \\cup (C\\smallsetminus B)\\}\\). just seen, \\(f\\circ \\pi^{ \\cup (C\\smallsetminus B)\\}\\) maps \\(\\mathbf{x}\\) member \\(\\mathbf{R}^B\\). can apply projection \\(\\pi^{ B\\C\\cap B}\\) obtain member \\(\\mathbf{R}^{C\\cap B}\\). Taking union components \\(\\mathbf{R}^{C\\smallsetminus B}\\) \\(\\mathbf{R}^{C\\cap B}\\) gives us value \\(\\mathbf{R}^C\\), can apply function \\(g\\). result function \\(\\mathbf{R}^D\\) telling values (\\(y\\)) \\(D\\) mapped.","code":""},{"path":"/articles/dynamical_systems.html","id":"general-ordered-sum","dir":"Articles","previous_headings":"The BioCro model > Modularization in BioCro > Decomposing the direct module function","what":"General ordered sum","title":"BioCro as a Dynamical System","text":"now generalize notion ordered sum two direct modules ordered sum finite number direct modules. Suppose ordered collection \\((\\mathcal{M}_1, \\mathcal{M}_2, \\dots, \\mathcal{M}_n)\\) direct modules. case direct modules, \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\cap\\operatorname{\\mathbf{}}\\mathcal{M}_i=\\emptyset\\) \\(\\). , assume \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\cup\\operatorname{\\mathbf{}}\\mathcal{M}_j=\\emptyset\\) \\(\\neq j\\), \\(\\operatorname{\\mathbf{}}\\mathcal{M}_i\\cap\\operatorname{\\mathbf{}}\\mathcal{M}_j=\\emptyset\\) whenever \\(<j\\). define ordered sum \\(\\sum_{=1}^n\\mathcal{M}_i\\) recursively follows:  \\[\\begin{alignat}{2}     \\sum_{=1}^k\\mathcal{M}_i &= M_1 && \\qquad\\text{$k=1$} \\notag \\\\     \\sum_{=1}^k\\mathcal{M}_i &= \\sum_{=1}^{k-1}\\mathcal{M}_i                         + \\mathcal{M}_k && \\qquad                         \\text{$1<k\\leq n$}\\label{eq:recursive_module_sum} \\end{alignat}\\] Things quite simple , however, since must show ordered sum given right-hand side \\(\\ref{eq:recursive_module_sum}\\) always defined. Specifically, must show  \\[\\begin{align}     \\operatorname{\\mathbf{}}\\sum_{=1}^{k-1}\\mathcal{M}_i \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_k &= \\emptyset         \\label{eq:general_sum_disjoint_outputs} \\\\ \\intertext{}     \\operatorname{\\mathbf{}}\\sum_{=1}^{k-1}\\mathcal{M}_i \\cap \\operatorname{\\mathbf{}}\\mathcal{M}_k &= \\emptyset. \\label{eq:general_sum_general_condition} \\end{align}\\] easily follows induction equation \\(\\ref{eq:output_of_sum}\\)  \\[\\begin{equation*}     \\operatorname{\\mathbf{}}\\sum_{=1}^{k-1}\\mathcal{M}_i = \\bigcup_{=1}^{k-1}\\operatorname{\\mathbf{}}\\mathcal{M}_i, \\end{equation*}\\]  \\(\\ref{eq:general_sum_disjoint_outputs}\\) easily follows , distributivity \\(\\cap\\) \\(\\cup\\), assumption outputs modules pairwise disjoint. prove \\(\\ref{eq:general_sum_general_condition}\\), first observe follows immediately \\(\\ref{eq:input_of_sum}\\) \\(\\operatorname{\\mathbf{}}(\\mathcal{M}_i+\\mathcal{M}_j) \\subseteq \\operatorname{\\mathbf{}}\\mathcal{M}_i \\cup \\operatorname{\\mathbf{}}M_j\\), easy show induction  \\[\\begin{equation}     \\operatorname{\\mathbf{}}\\sum_{=1}^{k-1}\\mathcal{M}_i \\subseteq \\bigcup_{=1}^{k-1}\\operatorname{\\mathbf{}}\\mathcal{M}_i. \\end{equation}\\]  Since stipulation defining ordered sum modules output module ordered collection disjoint inputs module occuring earlier ordering, light distributivity \\(\\cap\\) \\(\\cup\\), desired result \\(\\ref{eq:general_sum_general_condition}\\) immediately follows.","code":""},{"path":"/articles/dynamical_systems.html","id":"appendix-degenerate-biocro-systems","dir":"Articles","previous_headings":"","what":"Appendix: Degenerate BioCro systems","title":"BioCro as a Dynamical System","text":"appendix meant demonstrate certain edge cases “-label” uses BioCro systems. systems set using R interface. similar set systems use C++ library directly written C++.","code":""},{"path":"/articles/dynamical_systems.html","id":"a-minimal-system","dir":"Articles","previous_headings":"Appendix: Degenerate BioCro systems","what":"A minimal system","title":"BioCro as a Dynamical System","text":"system contains absolute minimum number quantities. Since single time point, timestep present satisfy formal requirement validity checker; otherwise meaningless. formal requirement R interface (C++ interface) set driver variables either contains time contains doy hour. three variables show output. Note ncalls always shows output data frame, even though constant even though system variable. Note also time driver, dominates: doy hour (present) overwritten. time present, doy hour must ; one , get obscure error:","code":"library(BioCro) run_biocro(parameters = list(timestep=1), drivers = data.frame(time=45.625)) ##   doy hour ncalls   time ## 1  45   15      1 45.625 run_biocro(parameters = list(timestep=1), drivers = data.frame(doy=80, hour=14.25)) ##   doy  hour ncalls     time ## 1  80 14.25      1 80.59375 Error in floor(result$time) :     non-numeric argument to mathematical function"},{"path":"/articles/dynamical_systems.html","id":"a-system-having-a-differential-variable-but-no-differential-module","dir":"Articles","previous_headings":"Appendix: Degenerate BioCro systems","what":"A system having a differential variable but no differential module","title":"BioCro as a Dynamical System","text":"noted Section \\(\\ref{sec:BioCro_systems}\\), initial_values parameter determines variables differential variables. Usually, differential variable output one differential modules, required. Differential variables output differential module assumed derivative zero; , constant. system exhibits case.","code":"run_biocro(initial_values = list(x = 52),            parameters = list(timestep=1),            drivers = data.frame(time=0:4)) ##   doy hour ncalls time  x ## 1   0    0      5    0 52 ## 2   1    0      5    1 52 ## 3   2    0      5    2 52 ## 4   3    0      5    3 52 ## 5   4    0      5    4 52"},{"path":"/articles/dynamical_systems.html","id":"an-off-label-use-of-run_biocro","dir":"Articles","previous_headings":"Appendix: Degenerate BioCro systems","what":"An off-label use of run_biocro","title":"BioCro as a Dynamical System","text":"example might called “-label” use BioCro system. system really doesn’t deserve called dynamical system . Although drivers parameter contains five rows temporal spacial data (row specifies time place), rows inherent relationship one another: represent sort evolution system time. times specified rows aren’t even chronological order: although timestep variable supposed indicate temporal relationship successive rows drivers parameter value, convention , enforced. Nevertheless, system useful: uses BioCro:solar_position_michalsky module compute cosine zenith angle sun noon various terrestrial locations various days year. gotten information using five calls run_biocro drivers single row, one call convenient.","code":"result <- run_biocro(parameters = list(timestep=1),                      drivers = data.frame(doy = c(355, 172, 80, 80, 80),                                           hour = 12,                                           time_zone_offset = -6,                                           year = 2022,                                           lat = c(40, 40, 40, 0, 89),                                           longitude = -88),                      direct_module_names = 'BioCro:solar_position_michalsky') result[c('lat', 'longitude', 'doy', 'hour', 'cosine_zenith_angle')] ##   lat longitude doy hour cosine_zenith_angle ## 1  40       -88 355   12          0.44655908 ## 2  40       -88 172   12          0.95824629 ## 3  40       -88  80   12          0.77093280 ## 4   0       -88  80   12          0.99996308 ## 5  89       -88  80   12          0.02509952"},{"path":"/articles/dynamical_systems.html","id":"a-system-having-only-drivers-and-the-obligatory-timestep-parameter","dir":"Articles","previous_headings":"Appendix: Degenerate BioCro systems","what":"A system having only drivers (and the obligatory timestep parameter)","title":"BioCro as a Dynamical System","text":"Like minimal system shown first example, system differential variables modules. drivers include driver variables aren’t time related. Like systems modules, doesn’t really anything. weather information run displays just easily displayed using","code":"result <- run_biocro(parameters = list(timestep=1),                      drivers = weather$`2005`[1000:1010,]) result[c('year', 'doy', 'hour', 'precip', 'rh', 'solar', 'temp', 'windspeed')] ##    year doy hour     precip      rh   solar  temp windspeed ## 1  2005  42   15 0.01058333 0.73690 755.964 4.530     7.475 ## 2  2005  42   16 0.01058333 0.70095 421.429 5.085     7.445 ## 3  2005  42   17 0.01058333 0.73080 101.775 4.375     5.935 ## 4  2005  42   18 0.01058333 0.80135   1.081 2.465     4.785 ## 5  2005  42   19 0.01058333 0.83150   0.345 1.650     4.115 ## 6  2005  42   20 0.01058333 0.84020   0.299 1.210     3.565 ## 7  2005  42   21 0.01058333 0.87250   0.115 0.635     3.255 ## 8  2005  42   22 0.01058333 0.86045   0.184 0.550     3.760 ## 9  2005  42   23 0.01058333 0.84600   0.138 0.890     4.815 ## 10 2005  43    0 0.00000000 0.82435   0.138 1.250     4.955 ## 11 2005  43    1 0.00000000 0.83260   0.414 1.025     5.675 weather$`2005`[1000:1010,                c('year', 'doy', 'hour', 'precip', 'rh', 'solar', 'temp', 'windspeed')]"},{"path":[]},{"path":"/articles/pdf_vignette_index.html","id":"a-practical-guide-to-biocro","dir":"Articles","previous_headings":"","what":"A Practical Guide to BioCro","title":"PDF Vignettes","text":"R code Practical Guide BioCro","code":""},{"path":"/articles/pdf_vignette_index.html","id":"quantitative-comparison-between-two-photosynthesis-models","dir":"Articles","previous_headings":"","what":"Quantitative Comparison Between Two Photosynthesis Models","title":"PDF Vignettes","text":"R code Quantitative Comparison Two Photosynthesis Models","code":""},{"path":[]},{"path":"/articles/thick_layer_absorption.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Light Absorption by a Thick Layer","text":"vignette explains understanding formula used thick_layer_absorption function found C++ source code file src/module_library/sunML.cpp. Although used BioCro, equation seems rarely discussed plant biology literature. far can tell, ultimately based Equation (1) Saeki (1960). However, description paper short sparse regarding details. tried add explanatory comments fill math steps skipped. tried follow “spirit” paper, although made notational changes. See Section 4 information tracking equation various references.","code":""},{"path":"/articles/thick_layer_absorption.html","id":"absorption-by-a-generic-material","dir":"Articles","previous_headings":"","what":"Absorption by a Generic Material","title":"Light Absorption by a Thick Layer","text":"Suppose light intensity \\(I_0\\) (representing flux density photons energy, expressed units photons per area per time, energy per area per time) incident perfectly flat surface infinitely thick piece material reflects, absorbs, transmits light. Assume optical properties density material constant along plane parallel material’s surface, although may vary depth within material. situation, light intensity point within material depend distance material’s surface, can reduce number relevant dimensions three one, important simplification. light passes material, intensity gradually diminish eventually reaches zero. can express mathematically via one-dimensional expression \\[\\begin{equation}     (x) = I_0 \\cdot f(x), \\end{equation}\\] \\(x\\) coordinate represents amount material light passed , \\(f(x)\\) fraction original light received material \\(x\\). Note material uniform density, \\(x\\) spatial coordinate, instead non-linear dependence distance. Although know particular form \\(f(x)\\), can safely assume : \\(f\\) monotonic. \\(f(0) = 1\\) (incident light material’s surface \\(I_0\\)). \\(f(x)\\) approaches 0 \\(x\\) approaches infinity (light intensity fully diminished deep within material). Now consider two points \\(x\\) \\(x + \\Delta x\\) within material, separated amount material \\(\\Delta x\\). change light intensity per unit material two points, \\(\\Delta /\\Delta x\\), can expressed \\[\\begin{equation}     \\frac{\\Delta }{\\Delta x} = \\frac{(x + \\Delta x) - (x)}{\\Delta x}. \\end{equation}\\] Rewriting using \\(f(x)\\), \\[\\begin{equation}     \\frac{\\Delta }{\\Delta x} = I_0 \\cdot \\frac{f(x + \\Delta x) - f(x)}{\\Delta x}. \\end{equation}\\] assume change intensity due absorption reflection light pass point \\(x\\) point \\(x + \\Delta x\\), can also write \\[\\begin{equation}     \\frac{\\Delta }{\\Delta x} \\approx - (x) \\cdot \\left( (x) + R(x) \\right), \\end{equation}\\] \\((x)\\) \\(R(x)\\) fractions incident light absorbed reflected thin layer material \\(x\\) negative sign indicates overall light intensity decreases due absorption reflection. Thus, can equate two expressions \\(\\Delta / \\Delta x\\) find \\[\\begin{equation}     I_0 \\cdot \\frac{f(x + \\Delta x) - f(x)}{\\Delta x} \\approx         - I_0 \\cdot f(x) \\cdot \\left( (x) + R(x) \\right) \\end{equation}\\] , equivalently, \\[\\begin{equation}     \\frac{f(x + \\Delta x) - f(x)}{\\Delta x} \\approx         - f(x) \\cdot \\left( (x) + R(x) \\right) \\end{equation}\\] \\(\\Delta x\\) approaches 0, approximation becomes exact can recognize left-hand side equation derivative \\(f(x)\\) respect \\(x\\): \\[\\begin{equation}     \\frac{df}{dx}(x) = - f(x) \\cdot \\left( (x) + R(x) \\right). \\end{equation}\\] Rearranging, can express \\(f(x)\\) terms derivative material’s optical properties: \\[\\begin{equation}     f(x) = - \\frac{\\frac{df}{dx}(x)}{(x) + R(x)}. \\end{equation}\\] Noting light received thin layer material must reflected, absorbed, transmitted, can use \\((x) + R(x) + T(x) = 1\\) rewrite equation terms fraction transmitted light \\(T(x)\\): \\[\\begin{equation}     f(x) = - \\frac{\\frac{df}{dx}(x)}{1 - T(x)} \\tag{2.1} \\end{equation}\\]","code":""},{"path":"/articles/thick_layer_absorption.html","id":"additional-considerations-especially-for-plant-biology","dir":"Articles","previous_headings":"2 Absorption by a Generic Material","what":"Additional Considerations (Especially for Plant Biology)","title":"Light Absorption by a Thick Layer","text":"simple model calculating light intensities within material first applied context plant biology Monsi Saeki (1953), used calculate light levels within plant canopy. application main reason describe \\(x\\) amount material rather depth; plant canopies, leaves uniformly distributed depth, cumulative leaf area index better independent variable light absorption. Monsi Saeki (1953) difficult find written German, parts reproduced English easier access (Saeki 1960, 1963; Hirose 2004). Saeki (1960) notes following equation: must noted equations \\(m\\) includes fraction resulting light transmitted leaf blades also fraction reflected downward inclined leaves. \\(m\\) constant increases depth foliage, light particular wavelengths liable reflected transmitted, increases proportion deeper positions. (original notation, \\(m\\) used place \\(T(x)\\) use .) Thus, \\(T\\), \\(R\\), \\(\\) exactly corresponding optical properties isolated layer material (leaf).","code":""},{"path":"/articles/thick_layer_absorption.html","id":"total-absorption","dir":"Articles","previous_headings":"","what":"Total Absorption","title":"Light Absorption by a Thick Layer","text":"consider light sufficiently narrow wavelength band, may reasonable suppose \\(T\\), \\(R\\), \\(\\) constant throughout material. case, possible estimate total amount light absorbed material. , first calculate absorbed light depth \\(x\\) per unit material (\\(d I_\\text{abs}(x) / dx\\)), using \\(d I_\\text{abs}(x) / dx = (x) \\cdot \\). Substituting Equation (2.1) recalling \\(= 1 - T - R\\), \\[\\begin{equation}     \\frac{d I_\\text{abs}}{dx}(x) =         - I_0 \\cdot \\frac{1 - R - T}{1 - T} \\cdot \\frac{df}{dx}(x). \\end{equation}\\] Now can integrate across entire range \\(x\\) (0 \\(\\infty\\)) find total amount light absorbed material (\\(I_\\text{abs (total)}\\)): \\[\\begin{equation}         I_\\text{abs (total)} = I_0 \\cdot \\frac{1 - R - T}{1 - T} \\cdot (f(0) - f(\\infty)). \\end{equation}\\] assumption, \\(f(0) = 1\\) \\(f(\\infty) = 0\\), evaluates \\[\\begin{equation}         I_\\text{abs (total)} = I_0 \\cdot \\frac{1 - R - T}{1 - T} \\tag{3.1} \\end{equation}\\] Note Equation (3.1) agrees intuition two extreme situations: material reflect light (\\(R = 0\\)), Equation (3.1) reduces \\(I_\\text{abs (total)} = I_0\\). makes sense even thin layers material transmit light, way light avoid absorbed infinitely thick layer reflection. situation material transmit light (\\(T = 0\\)). case, Equation (3.1) reduces \\(I_\\text{abs (total)} = I_0 \\cdot (1 - R)\\). makes sense optical properties material transmission determined surface; surface optical properties thin layer, reflecting fraction \\(R\\) light absorbing rest.","code":""},{"path":"/articles/thick_layer_absorption.html","id":"additional-considerations-especially-for-plant-biology-1","dir":"Articles","previous_headings":"3 Total Absorption","what":"Additional Considerations (Especially for Plant Biology)","title":"Light Absorption by a Thick Layer","text":"Although Equation (2.1) originally developed plant canopies, rely specific properties canopies can principle apply material. (fact, written derivation material-agnostic way emphasize .) Thus, Equation (3.1) can also apply wide variety materials. absorption reflection light soil another situation Equation (3.1) may useful, assumption thick layer transmit light certainly justified scenario. assumes thick layer homogeneous light-absorbing material, Equation (3.1) appropriate use layered canopy model one makes distinctions different leaf classes (sunlit shaded). best used situations estimating whole-canopy transpiration soil evaporation, useful know total solar energy absorbed thick layer leaves soil. Care must taken even case, however, since equation still appropriate small canopies young plants, certainly transmit significant fraction incident light.","code":""},{"path":"/articles/thick_layer_absorption.html","id":"sec:caveat","dir":"Articles","previous_headings":"","what":"Caveats From the Author","title":"Light Absorption by a Thick Layer","text":"Although Equation (2.1) can found Monsi Saeki (1953), Saeki (1960), Saeki (1963), Equation (3.1) included references. , although derivation makes sense , still chance might correct. Equation (3.1) can found Humphries (2002), WIMOVAC code, BioCro code. places, variously attributed John H. M. Thornley Johnson (1990) Monteith Unsworth (1990). Unfortunately, textbooks available electronic form. looked library copy Monteith Unsworth (1990) electronic versions newer editions, able find equation. attempted find explanation Equation (3.1) elsewhere successful far. J. H. M. Thornley (2002) discusses Equation (2.1), ultimately just references (currently inaccessible) textbook John H. M. Thornley Johnson (1990).","code":""},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Justin M. McGrath. Maintainer, author. Edward B. Lochocki. Author. Scott Rohde. Author. Deepak Jaiswal. Author. Megan L. Matthews. Author. Fernando E. Miguez. Author. Stephen P. Long. Author. Dan Wang. Contributor. David LeBauer. Contributor. BioCro authors. Copyright holder. Boost Organization. Copyright holder.            Author included Boost library","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"McGrath J, Lochocki E, Rohde S, Jaiswal D, Matthews M, Miguez F, Long S (2023). BioCro: Modular Crop Growth Simulations. R package version 3.0.0, https://github.com/ebimodeling/biocro.","code":"@Manual{,   title = {BioCro: Modular Crop Growth Simulations},   author = {Justin M. McGrath and Edward B. Lochocki and Scott Rohde and Deepak Jaiswal and Megan L. Matthews and Fernando E. Miguez and Stephen P. Long},   year = {2023},   note = {R package version 3.0.0},   url = {https://github.com/ebimodeling/biocro}, }"},{"path":"/index.html","id":"biocro","dir":"","previous_headings":"","what":"BioCro","title":"Modular Crop Growth Simulations","text":"BioCro model predicts plant growth time given crop-specific parameters environmental data input. uses models key physiological biophysical processes underlying plant growth (Humphries Long, 1995), previously used predicting biomass yield leaf area index switchgrass miscanthus (Miguez et al., 2009). BioCro also integrated suite tools link model directly crop trait yield data (LeBauer et al., 2014). Predictive Ecosystem Analyzer (PEcAn) couples BioCro Biofuel Ecophysiological Traits Yields database.","code":""},{"path":"/index.html","id":"an-example","dir":"","previous_headings":"BioCro","what":"An example","title":"Modular Crop Growth Simulations","text":"run_biocro() function accepts initial values, parameters, climate variables, sets modules run. returns results data frame. parameters modules soybean (Glycine max), miscanthus (Miscanthus x giganteus), willow (Saliceae salix).","code":"library(BioCro) library(lattice)  result <- with(soybean, {run_biocro(   initial_values,   parameters,   soybean_weather$'2002',   direct_modules,   differential_modules,   ode_solver )})  xyplot(Stem + Leaf ~ TTc, data = result, type='l', auto = TRUE)"},{"path":[]},{"path":"/index.html","id":"requirements","dir":"","previous_headings":"BioCro > Installation","what":"Requirements","title":"Modular Crop Growth Simulations","text":"R environment version 3.5.0 greater. Windows, version Rtools appropriate version R. Linux, gcc g++ version 4.9.3 greater (consult documentation distribution installation instructions). MacOS, Xcode.","code":""},{"path":"/index.html","id":"installation-steps","dir":"","previous_headings":"BioCro > Installation","what":"Installation steps","title":"Modular Crop Growth Simulations","text":"new Git, easiest way get local copy install GitHub Desktop use “Open GitHub Desktop” option “Code” dropdown GitHub page repository. Alternatively, clone repository using Git command line usual fashion running git clone <https://github.com/ebimodeling/biocro> repository contains Git submodule, need take additional step running git submodule update --init obtain . install command line: install within R:","code":"cd path_to_source_code_parent_directory R CMD INSTALL biocro setwd('path_to_source_code_parent_directory') install.packages('biocro', repos=NULL, type='SOURCE')"},{"path":"/index.html","id":"making-contributions","dir":"","previous_headings":"BioCro","what":"Making contributions","title":"Modular Crop Growth Simulations","text":"Please see contribution guidelines submitting changes.","code":""},{"path":"/index.html","id":"software-documentation","dir":"","previous_headings":"BioCro","what":"Software Documentation","title":"Modular Crop Growth Simulations","text":"See BioCro Documentation Web Site. found standard package documentation, also documentation C++ code, including notes biological models used BioCro implementation. Also included documentation BioCro package developers maintainers. also separate page documents quantities used Standard BioCro Module Library.","code":""},{"path":"/index.html","id":"license","dir":"","previous_headings":"BioCro","what":"License","title":"Modular Crop Growth Simulations","text":"BioCro R package licensed MIT license, BioCro C++ framework licensed version 3 greater GNU Lesser General Public License (LGPL). scheme allows people freely develop models use (public private) MIT license, changes framework assembles solves models must make source code changes available users LGPL. See LICENSE.note details.","code":""},{"path":"/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Modular Crop Growth Simulations","text":"Humphries S Long SP (1995) WIMOVAC - software package modeling dynamics plant leaf canopy photosynthesis. Computer Applications Bioscience 11(4):361-371. Miguez FE, Zhu XG, Humphries S, Bollero GA, Long SP (2009) semimechanistic model predicting growth production bioenergy crop Miscanthus × giganteus: description, parameterization validation. Global Change Biology Bioenergy 1: 282-296. LeBauer D, Wang D, Richter K, Davidson C, Dietze M (2014) Facilitating feedbacks field measurements ecosystem models. Ecological Monographs 83(2): 133-154. Wang D, Jaiswal D, Lebauer DS, Wertin TM, Bollero GA, Leakey ADB, Long SP (2015) physiological biophysical model coppice willow (Salix spp.) production yields contiguous USA current future climate scenarios. Plant, Cell & Environment 38(9), 1850-1865.","code":""},{"path":"/reference/add_time_to_weather_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a time component to input — add_time_to_weather_data","title":"Add a time component to input — add_time_to_weather_data","text":"Ensure, possible, input data varies time \"time\" component.","code":""},{"path":"/reference/add_time_to_weather_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a time component to input — add_time_to_weather_data","text":"","code":"add_time_to_weather_data(drivers)"},{"path":"/reference/add_time_to_weather_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a time component to input — add_time_to_weather_data","text":"drivers list dataframe representing known system parameters vary     time, weather data.","code":""},{"path":"/reference/add_time_to_weather_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a time component to input — add_time_to_weather_data","text":"drivers time component, one added, provided components doy hour. (time values equal doy values plus fractional portion day represented hour values.) Otherwise drivers returned .","code":""},{"path":"/reference/add_time_to_weather_data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Add a time component to input — add_time_to_weather_data","text":"Preconditions: drivers list, values vectors equal length.  Moreover, already contains time component, contain either doy hour component unless contains values mutually consistent.  Furthermore, time represented (doy, hour), given, time, given, increase vector row index increases.","code":""},{"path":"/reference/annualDB.html","id":null,"dir":"Reference","previous_headings":"","what":"Miscanthus dry biomass data. — annualDB","title":"Miscanthus dry biomass data. — annualDB","text":"first column thermal time. second, third, fourth, fifth     columns miscanthus stem, leaf, root, rhizome dry biomass Mg     ha-1 (root missing). sixth column leaf area index.     annualDB.c version altered root biomass     missing LAI smaller. purpose last modification     testing functions.","code":""},{"path":"/reference/annualDB.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Miscanthus dry biomass data. — annualDB","text":"Data frame dimensions 5 6.","code":""},{"path":"/reference/annualDB.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Miscanthus dry biomass data. — annualDB","text":"Clive Beale Stephen Long. 1997. Seasonal dynamics nutrient     accumulation partitioning perennial C4 grasses Miscanthus x     giganteus Spartina cynosuroides. Biomass Bioenergy 12 (6): 419--428.","code":""},{"path":"/reference/catm_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Global annual mean atmopspheric CO2 levels — catm_data","title":"Global annual mean atmopspheric CO2 levels — catm_data","text":"Multiple years globally averaged annual mean atmospheric CO2 levels   uncertainties. data included BioCro package users can reproduce   calculations Lochocki et al. (2022)   [doi:10.1093/insilicoplants/diac003 ] exploratory purposes;   likely BioCro studies require different data sets,   attempt made exhaustive.","code":""},{"path":"/reference/catm_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Global annual mean atmopspheric CO2 levels — catm_data","text":"","code":"catm_data"},{"path":"/reference/catm_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Global annual mean atmopspheric CO2 levels — catm_data","text":"Data frame 3 columns 41 rows: year: year Catm: CO2 concentration (micromol / mol) unc: uncertainty associated CO2 concentration           (micromol / mol)","code":""},{"path":"/reference/catm_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Global annual mean atmopspheric CO2 levels — catm_data","text":"Data obtained National Oceanic Atmospheric Administration's   Global Monitoring Laboratory (https://gml.noaa.gov/ccgg/trends/data.html)   04-13-2021. exact link used   https://gml.noaa.gov/webdata/ccgg/trends/co2/co2_annmean_gl.txt. Alternatively, data can accessed   https://gml.noaa.gov/ccgg/trends/gl_data.html clicking link   Globally averaged marine surface annual mean data (CSV). data provided convenience BioCro users; please visit   NOAA GML webpage guidelines regarding use data   intending include publication.","code":""},{"path":"/reference/cmi_soybean_weather_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Champaign, IL weather data for Soybean-BioCro — cmi_soybean_weather_data","title":"Champaign, IL weather data for Soybean-BioCro — cmi_soybean_weather_data","text":"Champaign, IL weather data specified hourly intervals CST time zone   years 2002, 2004, 2005, 2006. data includes typical inputs   required BioCro simulations, addition day_length,   specifically required soybean simulations. Although quantity can   calculated modules course simulation, included   weather data speed simulations. time range restricted   SoyFACE growing season used year. weather data included BioCro package users can reproduce   calculations Matthews et al. (2022)   [doi:10.1093/insilicoplants/diab032 ] exploratory purposes;   likely BioCro studies require different data sets,   attempt made exhaustive.","code":""},{"path":"/reference/cmi_soybean_weather_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Champaign, IL weather data for Soybean-BioCro — cmi_soybean_weather_data","text":"","code":"soybean_weather"},{"path":"/reference/cmi_soybean_weather_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Champaign, IL weather data for Soybean-BioCro — cmi_soybean_weather_data","text":"list 4 named elements, element data frame corresponding   one year weather data name element year,   example '2004'. data frame 2952 - 3384 observations   (representing hourly time points) 14 variables: year: year doy: day year hour: hour time_zone_offset: time zone offset relative UTC (hr) precip: preciptation rate (mm / hr) rh: ambient relative humidity (dimensionless) dw_solar: downwelling global solar radiation (J / m^2 / s) up_solar: upwelling global solar radiation (J / m^2 / s) netsolar: net global solar radiation (downwelling - upwelling)           (J / m^2 /s) solar: incoming photosynthetically active photon flux           density (PPFD) measured ground area basis including direct           diffuse sunlight light just outside crop canopy           (micromol / m^2 / s) temp: ambient air temperature (degrees Celsius) windspeed: wind speed ambient air just outside           canopy (m / s) zen: solar zenith angle (degrees) day_length: length daily photoperiod (hours)","code":""},{"path":"/reference/cmi_soybean_weather_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Champaign, IL weather data for Soybean-BioCro — cmi_soybean_weather_data","text":"Weather data obtained public SURFRAD WARM databases   processed according method described Matthews et al. (2022)   [doi:10.1093/insilicoplants/diab032 ]. See paper full description   data processing. brief, columns data frames determined SURFRAD WARM   variables follows: precip: precip variable WARM data set rh: rh variable SURFRAD data set dw_solar: dw_solar variable SURFRAD data           set up_solar: uw_solar variable SURFRAD data           set netsolar: netsolar variable SURFRAD data           set solar: par variable SURFRAD data set;           values available, netsolar           up_solar variables used make estimate;           values also available, dw_solar variable used           make estimate temp: temp variable SURFRAD data set windspeed: windspd variable SURFRAD data           set zen: zen variable SURFRAD data set day_length: calculated solar using           oscillator-based circadian clock WARM data set includes daily values. Hourly values precipitation   derived daily totals assuming constant rate precipitation   throughout day. SURFRAD data set includes values 1 3 minute intervals. Hourly values   determined averaging hourly intervals, value hour   h average hour. values missing; missing   entries filled interpolating neighboring hours. create data frame, hourly values columns except   day_length extracted WARM SURFRAD data. , BioCro   used run circadian clock model determines photoperiod length.   (See page additional information clock model:   soybean_clock.) result calculation   appended weather data frame new column. time_zone_offset set constant value -6 since data   specified CST time zone (.e., UTC-6). Since value   quantity change, principle considered parameter   rather driver; however, included weather data   convenience.","code":""},{"path":"/reference/cmi_weather_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Champaign, IL weather data — cmi_weather_data","title":"Champaign, IL weather data — cmi_weather_data","text":"Champaign, IL weather data specified hourly intervals CST time zone   years 1995--2020. data includes typical inputs required BioCro   imulations. Note: values missing near start 1995 since   time points available SURFRAD. weather data included BioCro package users can reproduce   calculations Lochocki et al. (2022)   [doi:10.1093/insilicoplants/diac003 ] exploratory purposes;   likely BioCro studies require different data sets,   attempt made exhaustive.","code":""},{"path":"/reference/cmi_weather_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Champaign, IL weather data — cmi_weather_data","text":"","code":"weather"},{"path":"/reference/cmi_weather_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Champaign, IL weather data — cmi_weather_data","text":"list 26 named elements, element data frame corresponding   one year weather data name element year,   example '2004'. data frame 8760 8784 observations   (representing hourly time points) 9 variables: year: year doy: day year hour: hour time_zone_offset: time zone offset relative UTC (hr) precip: preciptation rate (mm / hr) rh: ambient relative humidity (dimensionless) solar: incoming photosynthetically active photon flux           density (PPFD) measured ground area basis including direct           diffuse sunlight light just outside crop canopy           (micromol / m^2 / s) temp: ambient air temperature (degrees Celsius) windspeed: wind speed ambient air just outside           canopy (m / s)","code":""},{"path":"/reference/cmi_weather_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Champaign, IL weather data — cmi_weather_data","text":"Weather data obtained public SURFRAD WARM databases   processed according method described Lochocki et al. (2022)   [doi:10.1093/insilicoplants/diac003 ]. See paper full description   data processing. brief, columns data frames determined SURFRAD WARM   variables follows: precip: precip variable WARM data set rh: rh variable SURFRAD data set solar: par variable SURFRAD data set;           values available, direct_n,           diffuse, zen variables used make estimate temp: temp variable SURFRAD data set windspeed: windspd variable SURFRAD data           set WARM data set includes daily values. Hourly values precipitation   derived daily totals assuming constant rate precipitation   throughout day. SURFRAD data set includes values 1 3 minute intervals. Hourly values   determined averaging hourly intervals, value hour   h average hour-long interval centered h.   values missing; missing entries filled via interpolation   procedure based assumption values hour sequential   days similar. time_zone_offset set constant value -6 since data   specified CST time zone (.e., UTC-6). Since value   quantity change, principle considered parameter   rather driver; however, included weather data   convenience.","code":""},{"path":"/reference/crop_model_definitions.html","id":null,"dir":"Reference","previous_headings":"","what":"Crop model definitions — crop_model_definitions","title":"Crop model definitions — crop_model_definitions","text":"BioCro, crop model defined sets direct modules, differential   modules, initial values, parameters, along ordinary differential   equation (ODE) solver. run model, values, along set   weather data, passed run_biocro function.   convenience, several crop model definitions included BioCro R   package. full list can obtained typing ??crop_models R   terminal.","code":""},{"path":"/reference/crop_model_definitions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Crop model definitions — crop_model_definitions","text":"crop model definition stored list following named   elements: direct_modules: list direct module names; can passed     run_biocro direct_module_names argument. differential_modules: list differential module names; can     passed run_biocro     differential_module_names argument. ode_solver: list specifying details numerical ODE     solver; can passed run_biocro ode_solver     argument. initial_values: list named quantity values; can passed     run_biocro initial_values argument. parameters: list named quantity values; can passed     run_biocro parameters argument, also can     passed evaluate_module     module_response_curve investigating behavior one     crop's modules. model definitions sufficient running simulation   run_biocro also requires drivers; crop growth models,   drivers sets weather data. soybean model   intended used along specialized soybean weather data   (see cmi_soybean_weather_data). crops used   weather data (see cmi_weather_data). quantities crop model definitions, values   photosynthetic parameters, remain location; others,   latitude longitude, need change simulating crop growth   different locations. Care must taken understand input quantity   attempting run simulations places cultivars. Typically, modules crop model definition defined lists   named elements; names facilitate --fly module swapping via   within function. example, change soybean canopy   photosynthesis module BioCro:ten_layer_rue_canopy module, one   pass within(soybean$direct_modules, {canopy_photosynthesis =   \"BioCro:ten_layer_rue_canopy\"}) direct_module_names argument   calling run_biocro instead   soybean$direct_modules. crop model definition stored list named elements,   possible use function save typing   calling run_biocro related functions   partial_run_biocro   validate_dynamical_system_inputs. example, compare   Example 1 Example 2 . Besides shortening code,   using also makes easy modify command simulate   growth different crop; two models can use drivers,   switch can accomplished one small change (Example 3).","code":""},{"path":[]},{"path":"/reference/crop_model_definitions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crop model definitions — crop_model_definitions","text":"","code":"# Example 1: Simulating Miscanthus growth using its model definition list result1 <- run_biocro(   miscanthus_x_giganteus$initial_values,   miscanthus_x_giganteus$parameters,   get_growing_season_climate(weather$'2002'),   miscanthus_x_giganteus$direct_modules,   miscanthus_x_giganteus$differential_modules,   miscanthus_x_giganteus$ode_solver )  # Example 2: Performing the same simulation as in Example 1, but making use of # the `with` command to reduce repeated references to the model definition list result2 <- with(miscanthus_x_giganteus, {run_biocro(   initial_values,   parameters,   get_growing_season_climate(weather$'2002'),   direct_modules,   differential_modules,   ode_solver )})  # Example 3: Simulating willow growth using the same weather data as Examples 1 # and 2, which just requires one change relative to Example 2 result3 <- with(willow, {run_biocro(   initial_values,   parameters,   get_growing_season_climate(weather$'2002'),   direct_modules,   differential_modules,   ode_solver )})"},{"path":"/reference/dynamical_system.html","id":null,"dir":"Reference","previous_headings":"","what":"Validating dynamical system inputs — dynamical_system","title":"Validating dynamical system inputs — dynamical_system","text":"Utility function checking inputs run_biocro without running ","code":""},{"path":"/reference/dynamical_system.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validating dynamical system inputs — dynamical_system","text":"","code":"validate_dynamical_system_inputs(     initial_values = list(),     parameters = list(),     drivers,     direct_module_names = list(),     differential_module_names = list(),     verbose = TRUE )"},{"path":"/reference/dynamical_system.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validating dynamical system inputs — dynamical_system","text":"initial_values Identical corresponding argument run_biocro. parameters Identical corresponding argument run_biocro. drivers Identical corresponding argument run_biocro. direct_module_names Identical corresponding argument run_biocro. differential_module_names Identical corresponding argument run_biocro. verbose Identical corresponding argument run_biocro.","code":""},{"path":"/reference/dynamical_system.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validating dynamical system inputs — dynamical_system","text":"validate_dynamical_system_inputs accepts input arguments   run_biocro exception ode_solver (  required check validity dynamical system). validate_dynamical_system_inputs checks set parameters, drivers,   modules, initial values see can properly define dynamical   system can therefore used inputs run_biocro.   Although run_biocro function performs validity   checks, validate_dynamical_system_inputs includes additional   information, list parameters whose values used inputs   modules, since principle parameters removed   clarity. using one pre-defined crop growth models, may helpful   use command pass arguments   validate_dynamical_system_inputs; see documentation   crop_model_definitions information.","code":""},{"path":"/reference/dynamical_system.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validating dynamical system inputs — dynamical_system","text":"boolean indicating whether inputs valid.","code":""},{"path":[]},{"path":"/reference/dynamical_system.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validating dynamical system inputs — dynamical_system","text":"","code":"# Example 1: missing a parameter and an initial value validate_dynamical_system_inputs(   within(soybean$initial_values, rm(Leaf)),         # remove the initial `Leaf` value   within(soybean$parameters, rm(leaf_reflectance)), # remove `leaf_reflectance`   soybean_weather$'2002',   soybean$direct_modules,   soybean$differential_modules ) #>  #> Checking the validity of the system inputs: #>  #> [pass] No quantities were defined multiple times in the inputs #>  #> [fail] The following module inputs were not defined: #>  Leaf from the 'parameter_calculator' module #>  leaf_reflectance from the 'ten_layer_canopy_properties' module #>  Leaf from the 'senescence_logistic' module #>  Leaf from the 'partitioning_growth' module #>  #> [fail] The following differential module outputs were not part of the initial values: #>  Leaf from the 'senescence_logistic' module #>  Leaf from the 'partitioning_growth' module #>  #> [pass] There are no cyclic dependencies among the direct modules. #>  #> System inputs are not valid #>  #> Printing additional information about the system inputs: #>  #> The direct modules are in a suitable order for evaluation. #>  #> The following quantities were each required by at least one module: #>  Catm #>  DVI #>  Gs_min #>  Leaf #>  LeafN #>  LeafN_0 #>  LeafWS #>  O2 #>  Rd #>  Rhizome #>  Rmax_emrV0 #>  Root #>  Sp_thermal_time_decay #>  Stem #>  StomataWS #>  TTc #>  TTemr_threshold #>  Tbase_emr #>  Tmax_R0R1 #>  Tmax_R1R7 #>  Tmax_emrV0 #>  Tmin_R0R1 #>  Tmin_R1R7 #>  Tmin_emrV0 #>  Topt_R0R1 #>  Topt_R1R7 #>  Topt_emrV0 #>  absorptivity_par #>  alpha1 #>  alphaLeaf #>  alphaRoot #>  alphaSeneLeaf #>  alphaSeneRhizome #>  alphaSeneRoot #>  alphaSeneStem #>  alphaShell #>  alphaStem #>  alphab1 #>  atmospheric_pressure #>  atmospheric_scattering #>  atmospheric_transmittance #>  average_absorbed_shortwave_layer_0 #>  average_absorbed_shortwave_layer_1 #>  average_absorbed_shortwave_layer_2 #>  average_absorbed_shortwave_layer_3 #>  average_absorbed_shortwave_layer_4 #>  average_absorbed_shortwave_layer_5 #>  average_absorbed_shortwave_layer_6 #>  average_absorbed_shortwave_layer_7 #>  average_absorbed_shortwave_layer_8 #>  average_absorbed_shortwave_layer_9 #>  b0 #>  b1 #>  betaLeaf #>  betaRoot #>  betaSeneLeaf #>  betaSeneRhizome #>  betaSeneRoot #>  betaSeneStem #>  betaShell #>  betaStem #>  beta_PSII #>  canopy_assimilation_rate #>  canopy_transpiration_rate #>  chil #>  cosine_zenith_angle #>  cws1 #>  cws2 #>  day_length #>  development_rate_per_hour #>  electrons_per_carboxylation #>  electrons_per_oxygenation #>  growth_respiration_fraction #>  height_layer_0 #>  height_layer_1 #>  height_layer_2 #>  height_layer_3 #>  height_layer_4 #>  height_layer_5 #>  height_layer_6 #>  height_layer_7 #>  height_layer_8 #>  height_layer_9 #>  heightf #>  hydrDist #>  iSp #>  irradiance_diffuse_fraction #>  irradiance_direct_fraction #>  jmax #>  kGrain #>  kLeaf #>  kRhizome #>  kRhizome_emr #>  kRoot #>  kSeneLeaf #>  kSeneRhizome #>  kSeneRoot #>  kSeneStem #>  kShell #>  kStem #>  kd #>  kpLN #>  lai #>  lat #>  leaf_reflectance #>  leaf_transmittance #>  lnfun #>  longitude #>  maturity_group #>  minimum_gbw #>  mrc1 #>  mrc2 #>  net_assimilation_rate_grain #>  net_assimilation_rate_leaf #>  net_assimilation_rate_rhizome #>  net_assimilation_rate_root #>  net_assimilation_rate_shell #>  net_assimilation_rate_stem #>  par_energy_content #>  par_energy_fraction #>  par_incident_diffuse #>  par_incident_direct #>  phi1 #>  phi2 #>  precip #>  rateSeneLeaf #>  rateSeneRhizome #>  rateSeneRoot #>  rateSeneStem #>  remobilization_fraction #>  retrans #>  retrans_rhizome #>  rfl #>  rh #>  rsdf #>  rsec #>  shaded_Assim_layer_0 #>  shaded_Assim_layer_1 #>  shaded_Assim_layer_2 #>  shaded_Assim_layer_3 #>  shaded_Assim_layer_4 #>  shaded_Assim_layer_5 #>  shaded_Assim_layer_6 #>  shaded_Assim_layer_7 #>  shaded_Assim_layer_8 #>  shaded_Assim_layer_9 #>  shaded_GrossAssim_layer_0 #>  shaded_GrossAssim_layer_1 #>  shaded_GrossAssim_layer_2 #>  shaded_GrossAssim_layer_3 #>  shaded_GrossAssim_layer_4 #>  shaded_GrossAssim_layer_5 #>  shaded_GrossAssim_layer_6 #>  shaded_GrossAssim_layer_7 #>  shaded_GrossAssim_layer_8 #>  shaded_GrossAssim_layer_9 #>  shaded_Gs_layer_0 #>  shaded_Gs_layer_1 #>  shaded_Gs_layer_2 #>  shaded_Gs_layer_3 #>  shaded_Gs_layer_4 #>  shaded_Gs_layer_5 #>  shaded_Gs_layer_6 #>  shaded_Gs_layer_7 #>  shaded_Gs_layer_8 #>  shaded_Gs_layer_9 #>  shaded_Rp_layer_0 #>  shaded_Rp_layer_1 #>  shaded_Rp_layer_2 #>  shaded_Rp_layer_3 #>  shaded_Rp_layer_4 #>  shaded_Rp_layer_5 #>  shaded_Rp_layer_6 #>  shaded_Rp_layer_7 #>  shaded_Rp_layer_8 #>  shaded_Rp_layer_9 #>  shaded_TransR_layer_0 #>  shaded_TransR_layer_1 #>  shaded_TransR_layer_2 #>  shaded_TransR_layer_3 #>  shaded_TransR_layer_4 #>  shaded_TransR_layer_5 #>  shaded_TransR_layer_6 #>  shaded_TransR_layer_7 #>  shaded_TransR_layer_8 #>  shaded_TransR_layer_9 #>  shaded_absorbed_ppfd_layer_0 #>  shaded_absorbed_ppfd_layer_1 #>  shaded_absorbed_ppfd_layer_2 #>  shaded_absorbed_ppfd_layer_3 #>  shaded_absorbed_ppfd_layer_4 #>  shaded_absorbed_ppfd_layer_5 #>  shaded_absorbed_ppfd_layer_6 #>  shaded_absorbed_ppfd_layer_7 #>  shaded_absorbed_ppfd_layer_8 #>  shaded_absorbed_ppfd_layer_9 #>  shaded_fraction_layer_0 #>  shaded_fraction_layer_1 #>  shaded_fraction_layer_2 #>  shaded_fraction_layer_3 #>  shaded_fraction_layer_4 #>  shaded_fraction_layer_5 #>  shaded_fraction_layer_6 #>  shaded_fraction_layer_7 #>  shaded_fraction_layer_8 #>  shaded_fraction_layer_9 #>  soil_air_entry #>  soil_b_coefficient #>  soil_clod_size #>  soil_depth1 #>  soil_depth2 #>  soil_depth3 #>  soil_field_capacity #>  soil_reflectance #>  soil_sand_content #>  soil_saturated_conductivity #>  soil_saturation_capacity #>  soil_transmission #>  soil_water_content #>  soil_wilting_point #>  solar #>  sowing_time #>  specific_heat_of_air #>  sunlit_Assim_layer_0 #>  sunlit_Assim_layer_1 #>  sunlit_Assim_layer_2 #>  sunlit_Assim_layer_3 #>  sunlit_Assim_layer_4 #>  sunlit_Assim_layer_5 #>  sunlit_Assim_layer_6 #>  sunlit_Assim_layer_7 #>  sunlit_Assim_layer_8 #>  sunlit_Assim_layer_9 #>  sunlit_GrossAssim_layer_0 #>  sunlit_GrossAssim_layer_1 #>  sunlit_GrossAssim_layer_2 #>  sunlit_GrossAssim_layer_3 #>  sunlit_GrossAssim_layer_4 #>  sunlit_GrossAssim_layer_5 #>  sunlit_GrossAssim_layer_6 #>  sunlit_GrossAssim_layer_7 #>  sunlit_GrossAssim_layer_8 #>  sunlit_GrossAssim_layer_9 #>  sunlit_Gs_layer_0 #>  sunlit_Gs_layer_1 #>  sunlit_Gs_layer_2 #>  sunlit_Gs_layer_3 #>  sunlit_Gs_layer_4 #>  sunlit_Gs_layer_5 #>  sunlit_Gs_layer_6 #>  sunlit_Gs_layer_7 #>  sunlit_Gs_layer_8 #>  sunlit_Gs_layer_9 #>  sunlit_Rp_layer_0 #>  sunlit_Rp_layer_1 #>  sunlit_Rp_layer_2 #>  sunlit_Rp_layer_3 #>  sunlit_Rp_layer_4 #>  sunlit_Rp_layer_5 #>  sunlit_Rp_layer_6 #>  sunlit_Rp_layer_7 #>  sunlit_Rp_layer_8 #>  sunlit_Rp_layer_9 #>  sunlit_TransR_layer_0 #>  sunlit_TransR_layer_1 #>  sunlit_TransR_layer_2 #>  sunlit_TransR_layer_3 #>  sunlit_TransR_layer_4 #>  sunlit_TransR_layer_5 #>  sunlit_TransR_layer_6 #>  sunlit_TransR_layer_7 #>  sunlit_TransR_layer_8 #>  sunlit_TransR_layer_9 #>  sunlit_absorbed_ppfd_layer_0 #>  sunlit_absorbed_ppfd_layer_1 #>  sunlit_absorbed_ppfd_layer_2 #>  sunlit_absorbed_ppfd_layer_3 #>  sunlit_absorbed_ppfd_layer_4 #>  sunlit_absorbed_ppfd_layer_5 #>  sunlit_absorbed_ppfd_layer_6 #>  sunlit_absorbed_ppfd_layer_7 #>  sunlit_absorbed_ppfd_layer_8 #>  sunlit_absorbed_ppfd_layer_9 #>  sunlit_fraction_layer_0 #>  sunlit_fraction_layer_1 #>  sunlit_fraction_layer_2 #>  sunlit_fraction_layer_3 #>  sunlit_fraction_layer_4 #>  sunlit_fraction_layer_5 #>  sunlit_fraction_layer_6 #>  sunlit_fraction_layer_7 #>  sunlit_fraction_layer_8 #>  sunlit_fraction_layer_9 #>  tbase #>  temp #>  theta #>  time #>  time_zone_offset #>  tpu_rate_max #>  vmax1 #>  vmax_n_intercept #>  windspeed #>  windspeed_height #>  windspeed_layer_0 #>  windspeed_layer_1 #>  windspeed_layer_2 #>  windspeed_layer_3 #>  windspeed_layer_4 #>  windspeed_layer_5 #>  windspeed_layer_6 #>  windspeed_layer_7 #>  windspeed_layer_8 #>  windspeed_layer_9 #>  wsFun #>  year #>  #> The following parameters were not used as inputs to any module: #>  jmax_mature #>  km_leaf_litter #>  sf_jmax #>  soil_bulk_density #>  soil_clay_content #>  soil_silt_content #> You may want to consider removing them for clarity #>  #> The following drivers were not used as inputs to any module: #>  dw_solar #>  netsolar #>  up_solar #>  zen #> You may want to consider removing them for clarity #>  #> All quantities in the initial values have associated derivatives #>  #> Derivatives for the following quantities are each determined by more than one module: #>  Grain #>  Leaf #>  Rhizome #>  Root #>  Shell #>  Stem #>  #> No direct modules require a fixed step size Euler ode_solver #>  #> No differential modules require a fixed step size Euler ode_solver #>  #> All modules in the direct module list are direct modules #>  #> All modules in the differential module list are differential modules #>  #> [1] FALSE  # Example 2: a valid set of input arguments validate_dynamical_system_inputs(   soybean$initial_values,   soybean$parameters,   soybean_weather$'2002',   soybean$direct_modules,   soybean$differential_modules ) #>  #> Checking the validity of the system inputs: #>  #> [pass] No quantities were defined multiple times in the inputs #>  #> [pass] All module inputs were properly defined #>  #> [pass] All differential module outputs were included in the initial values #>  #> [pass] There are no cyclic dependencies among the direct modules. #>  #> System inputs are valid #>  #> Printing additional information about the system inputs: #>  #> The direct modules are in a suitable order for evaluation. #>  #> The following quantities were each required by at least one module: #>  Catm #>  DVI #>  Gs_min #>  Leaf #>  LeafN #>  LeafN_0 #>  LeafWS #>  O2 #>  Rd #>  Rhizome #>  Rmax_emrV0 #>  Root #>  Sp_thermal_time_decay #>  Stem #>  StomataWS #>  TTc #>  TTemr_threshold #>  Tbase_emr #>  Tmax_R0R1 #>  Tmax_R1R7 #>  Tmax_emrV0 #>  Tmin_R0R1 #>  Tmin_R1R7 #>  Tmin_emrV0 #>  Topt_R0R1 #>  Topt_R1R7 #>  Topt_emrV0 #>  absorptivity_par #>  alpha1 #>  alphaLeaf #>  alphaRoot #>  alphaSeneLeaf #>  alphaSeneRhizome #>  alphaSeneRoot #>  alphaSeneStem #>  alphaShell #>  alphaStem #>  alphab1 #>  atmospheric_pressure #>  atmospheric_scattering #>  atmospheric_transmittance #>  average_absorbed_shortwave_layer_0 #>  average_absorbed_shortwave_layer_1 #>  average_absorbed_shortwave_layer_2 #>  average_absorbed_shortwave_layer_3 #>  average_absorbed_shortwave_layer_4 #>  average_absorbed_shortwave_layer_5 #>  average_absorbed_shortwave_layer_6 #>  average_absorbed_shortwave_layer_7 #>  average_absorbed_shortwave_layer_8 #>  average_absorbed_shortwave_layer_9 #>  b0 #>  b1 #>  betaLeaf #>  betaRoot #>  betaSeneLeaf #>  betaSeneRhizome #>  betaSeneRoot #>  betaSeneStem #>  betaShell #>  betaStem #>  beta_PSII #>  canopy_assimilation_rate #>  canopy_transpiration_rate #>  chil #>  cosine_zenith_angle #>  cws1 #>  cws2 #>  day_length #>  development_rate_per_hour #>  electrons_per_carboxylation #>  electrons_per_oxygenation #>  growth_respiration_fraction #>  height_layer_0 #>  height_layer_1 #>  height_layer_2 #>  height_layer_3 #>  height_layer_4 #>  height_layer_5 #>  height_layer_6 #>  height_layer_7 #>  height_layer_8 #>  height_layer_9 #>  heightf #>  hydrDist #>  iSp #>  irradiance_diffuse_fraction #>  irradiance_direct_fraction #>  jmax #>  kGrain #>  kLeaf #>  kRhizome #>  kRhizome_emr #>  kRoot #>  kSeneLeaf #>  kSeneRhizome #>  kSeneRoot #>  kSeneStem #>  kShell #>  kStem #>  kd #>  kpLN #>  lai #>  lat #>  leaf_reflectance #>  leaf_transmittance #>  lnfun #>  longitude #>  maturity_group #>  minimum_gbw #>  mrc1 #>  mrc2 #>  net_assimilation_rate_grain #>  net_assimilation_rate_leaf #>  net_assimilation_rate_rhizome #>  net_assimilation_rate_root #>  net_assimilation_rate_shell #>  net_assimilation_rate_stem #>  par_energy_content #>  par_energy_fraction #>  par_incident_diffuse #>  par_incident_direct #>  phi1 #>  phi2 #>  precip #>  rateSeneLeaf #>  rateSeneRhizome #>  rateSeneRoot #>  rateSeneStem #>  remobilization_fraction #>  retrans #>  retrans_rhizome #>  rfl #>  rh #>  rsdf #>  rsec #>  shaded_Assim_layer_0 #>  shaded_Assim_layer_1 #>  shaded_Assim_layer_2 #>  shaded_Assim_layer_3 #>  shaded_Assim_layer_4 #>  shaded_Assim_layer_5 #>  shaded_Assim_layer_6 #>  shaded_Assim_layer_7 #>  shaded_Assim_layer_8 #>  shaded_Assim_layer_9 #>  shaded_GrossAssim_layer_0 #>  shaded_GrossAssim_layer_1 #>  shaded_GrossAssim_layer_2 #>  shaded_GrossAssim_layer_3 #>  shaded_GrossAssim_layer_4 #>  shaded_GrossAssim_layer_5 #>  shaded_GrossAssim_layer_6 #>  shaded_GrossAssim_layer_7 #>  shaded_GrossAssim_layer_8 #>  shaded_GrossAssim_layer_9 #>  shaded_Gs_layer_0 #>  shaded_Gs_layer_1 #>  shaded_Gs_layer_2 #>  shaded_Gs_layer_3 #>  shaded_Gs_layer_4 #>  shaded_Gs_layer_5 #>  shaded_Gs_layer_6 #>  shaded_Gs_layer_7 #>  shaded_Gs_layer_8 #>  shaded_Gs_layer_9 #>  shaded_Rp_layer_0 #>  shaded_Rp_layer_1 #>  shaded_Rp_layer_2 #>  shaded_Rp_layer_3 #>  shaded_Rp_layer_4 #>  shaded_Rp_layer_5 #>  shaded_Rp_layer_6 #>  shaded_Rp_layer_7 #>  shaded_Rp_layer_8 #>  shaded_Rp_layer_9 #>  shaded_TransR_layer_0 #>  shaded_TransR_layer_1 #>  shaded_TransR_layer_2 #>  shaded_TransR_layer_3 #>  shaded_TransR_layer_4 #>  shaded_TransR_layer_5 #>  shaded_TransR_layer_6 #>  shaded_TransR_layer_7 #>  shaded_TransR_layer_8 #>  shaded_TransR_layer_9 #>  shaded_absorbed_ppfd_layer_0 #>  shaded_absorbed_ppfd_layer_1 #>  shaded_absorbed_ppfd_layer_2 #>  shaded_absorbed_ppfd_layer_3 #>  shaded_absorbed_ppfd_layer_4 #>  shaded_absorbed_ppfd_layer_5 #>  shaded_absorbed_ppfd_layer_6 #>  shaded_absorbed_ppfd_layer_7 #>  shaded_absorbed_ppfd_layer_8 #>  shaded_absorbed_ppfd_layer_9 #>  shaded_fraction_layer_0 #>  shaded_fraction_layer_1 #>  shaded_fraction_layer_2 #>  shaded_fraction_layer_3 #>  shaded_fraction_layer_4 #>  shaded_fraction_layer_5 #>  shaded_fraction_layer_6 #>  shaded_fraction_layer_7 #>  shaded_fraction_layer_8 #>  shaded_fraction_layer_9 #>  soil_air_entry #>  soil_b_coefficient #>  soil_clod_size #>  soil_depth1 #>  soil_depth2 #>  soil_depth3 #>  soil_field_capacity #>  soil_reflectance #>  soil_sand_content #>  soil_saturated_conductivity #>  soil_saturation_capacity #>  soil_transmission #>  soil_water_content #>  soil_wilting_point #>  solar #>  sowing_time #>  specific_heat_of_air #>  sunlit_Assim_layer_0 #>  sunlit_Assim_layer_1 #>  sunlit_Assim_layer_2 #>  sunlit_Assim_layer_3 #>  sunlit_Assim_layer_4 #>  sunlit_Assim_layer_5 #>  sunlit_Assim_layer_6 #>  sunlit_Assim_layer_7 #>  sunlit_Assim_layer_8 #>  sunlit_Assim_layer_9 #>  sunlit_GrossAssim_layer_0 #>  sunlit_GrossAssim_layer_1 #>  sunlit_GrossAssim_layer_2 #>  sunlit_GrossAssim_layer_3 #>  sunlit_GrossAssim_layer_4 #>  sunlit_GrossAssim_layer_5 #>  sunlit_GrossAssim_layer_6 #>  sunlit_GrossAssim_layer_7 #>  sunlit_GrossAssim_layer_8 #>  sunlit_GrossAssim_layer_9 #>  sunlit_Gs_layer_0 #>  sunlit_Gs_layer_1 #>  sunlit_Gs_layer_2 #>  sunlit_Gs_layer_3 #>  sunlit_Gs_layer_4 #>  sunlit_Gs_layer_5 #>  sunlit_Gs_layer_6 #>  sunlit_Gs_layer_7 #>  sunlit_Gs_layer_8 #>  sunlit_Gs_layer_9 #>  sunlit_Rp_layer_0 #>  sunlit_Rp_layer_1 #>  sunlit_Rp_layer_2 #>  sunlit_Rp_layer_3 #>  sunlit_Rp_layer_4 #>  sunlit_Rp_layer_5 #>  sunlit_Rp_layer_6 #>  sunlit_Rp_layer_7 #>  sunlit_Rp_layer_8 #>  sunlit_Rp_layer_9 #>  sunlit_TransR_layer_0 #>  sunlit_TransR_layer_1 #>  sunlit_TransR_layer_2 #>  sunlit_TransR_layer_3 #>  sunlit_TransR_layer_4 #>  sunlit_TransR_layer_5 #>  sunlit_TransR_layer_6 #>  sunlit_TransR_layer_7 #>  sunlit_TransR_layer_8 #>  sunlit_TransR_layer_9 #>  sunlit_absorbed_ppfd_layer_0 #>  sunlit_absorbed_ppfd_layer_1 #>  sunlit_absorbed_ppfd_layer_2 #>  sunlit_absorbed_ppfd_layer_3 #>  sunlit_absorbed_ppfd_layer_4 #>  sunlit_absorbed_ppfd_layer_5 #>  sunlit_absorbed_ppfd_layer_6 #>  sunlit_absorbed_ppfd_layer_7 #>  sunlit_absorbed_ppfd_layer_8 #>  sunlit_absorbed_ppfd_layer_9 #>  sunlit_fraction_layer_0 #>  sunlit_fraction_layer_1 #>  sunlit_fraction_layer_2 #>  sunlit_fraction_layer_3 #>  sunlit_fraction_layer_4 #>  sunlit_fraction_layer_5 #>  sunlit_fraction_layer_6 #>  sunlit_fraction_layer_7 #>  sunlit_fraction_layer_8 #>  sunlit_fraction_layer_9 #>  tbase #>  temp #>  theta #>  time #>  time_zone_offset #>  tpu_rate_max #>  vmax1 #>  vmax_n_intercept #>  windspeed #>  windspeed_height #>  windspeed_layer_0 #>  windspeed_layer_1 #>  windspeed_layer_2 #>  windspeed_layer_3 #>  windspeed_layer_4 #>  windspeed_layer_5 #>  windspeed_layer_6 #>  windspeed_layer_7 #>  windspeed_layer_8 #>  windspeed_layer_9 #>  wsFun #>  year #>  #> The following parameters were not used as inputs to any module: #>  jmax_mature #>  km_leaf_litter #>  sf_jmax #>  soil_bulk_density #>  soil_clay_content #>  soil_silt_content #> You may want to consider removing them for clarity #>  #> The following drivers were not used as inputs to any module: #>  dw_solar #>  netsolar #>  up_solar #>  zen #> You may want to consider removing them for clarity #>  #> All quantities in the initial values have associated derivatives #>  #> Derivatives for the following quantities are each determined by more than one module: #>  Grain #>  Leaf #>  Rhizome #>  Root #>  Shell #>  Stem #>  #> No direct modules require a fixed step size Euler ode_solver #>  #> No differential modules require a fixed step size Euler ode_solver #>  #> All modules in the direct module list are direct modules #>  #> All modules in the differential module list are differential modules #>  #> [1] TRUE"},{"path":"/reference/get_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Get lists of modules, quantities, and solvers — get_all","title":"Get lists of modules, quantities, and solvers — get_all","text":"get_all_modules returns fully-qualified names (form   library_name:local_module_name) modules available BioCro   module library package. get_all_quantities returns information quantities used   inputs outputs modules available BioCro module library package. get_all_ode_solvers returns names ordinary differential   equation (ODE) solvers available BioCro framework.","code":""},{"path":"/reference/get_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get lists of modules, quantities, and solvers — get_all","text":"","code":"get_all_modules(library_name)    get_all_quantities(library_name)    get_all_ode_solvers()"},{"path":"/reference/get_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get lists of modules, quantities, and solvers — get_all","text":"library_name name BioCro module library","code":""},{"path":"/reference/get_all.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get lists of modules, quantities, and solvers — get_all","text":"\"get_all\" functions return modules, quantities, ODE solvers   available within BioCro framework BioCro module library package. Developer details: get_all_modules   get_all_quantities expect module library package include   unexported functions called get_all_modules_internal   get_all_quantities_internal, respectively. functions   input arguments, return values follow   requirements described get_all_modules   get_all_quantities. module library package created forking   skeleton library automatically include functions without   modifications package's R code.","code":""},{"path":"/reference/get_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get lists of modules, quantities, and solvers — get_all","text":"get_all_modules character vector fully-qualified module names get_all_quantities data frame three columns:     quantity_type (input output), quantity_name,     module_name. quantity appear multiple times use     input output, used multiple modules. get_all_ode_solvers character vector ODE solver names","code":""},{"path":[]},{"path":"/reference/get_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get lists of modules, quantities, and solvers — get_all","text":"","code":"# Example 1: Getting a sorted list of distinct quantities defined by modules in # the `BioCro` module library. Doing this can be useful when writing a new # module that is intended to work along with pre-existing modules. all_quantities <- get_all_quantities('BioCro') all_quantity_names <- all_quantities$quantity_name distinct_quantities <- sort(unique(all_quantity_names))  # Example 2: Getting a list of all modules in the `BioCro` module library that # have \"ci\" as an input or output, using `tolower()` to account for any possible # variations in capitalization. all_quantities <- get_all_quantities('BioCro') ci_modules <- subset(all_quantities, tolower(quantity_name) == \"ci\")"},{"path":"/reference/get_growing_season_climate.html","id":null,"dir":"Reference","previous_headings":"","what":"Truncate weather data to one growing season — get_growing_season_climate","title":"Truncate weather data to one growing season — get_growing_season_climate","text":"Attempt restrict year weather data growing season; intended   general-use function (see detailed discussion   shortcomings).","code":""},{"path":"/reference/get_growing_season_climate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Truncate weather data to one growing season — get_growing_season_climate","text":"","code":"get_growing_season_climate(climate, threshold_temperature = 0)"},{"path":"/reference/get_growing_season_climate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Truncate weather data to one growing season — get_growing_season_climate","text":"climate data frame representing one year weather data, typically intended     passed run_biocro drivers argument. data     frame must columns day year (doy) air     temperature degrees C (temp). threshold_temperature value air temperature degrees C use locating beginning     end growing season.","code":""},{"path":"/reference/get_growing_season_climate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Truncate weather data to one growing season — get_growing_season_climate","text":"DISCLAIMER: function included primarily reproduce   output older BioCro calculations, used hard-coded   every simulation. several severe limitations discussed ,   intended general-use function subsetting weather data. determine growing season, function locates beginning end   based air temperature data. start growing season set   last day first half year air temperature   (equal ) threshold temperature, day 90, whichever later.   end growing season set first day second half   year air temperature (equal ) threshold   temperature, day 330, whichever earlier. sophisticated function attempt made ensure   output reasonable. example, air temperature never exceeds   threshold value, growing season beginning day 183 (last day   first half year) ending day 184 (first day second   half year) returned. air temperature always exceeds   threshold value, growing season go day 90 day 330. function also assumes air temperature generally increases early   year generally decreases later year, applicable   locations case. therefore unlikely work   properly Southern Hemisphere tropics. general, appropriate threshold temperature depend species   modeled. perennial grass, growth season might said   begin last freeze, requiring threshold temperature 0 degrees   C. course, oversimplification complicated biological   process, plant way knowing experienced last   freezing day year. hand, annual crops like maize soybean typically sown   conditions warmer might require higher threshold. ,   oversimplification complicated process. Farmers typically take   trends temperature, historical data, soil conditions, weather   predictions account deciding sow, may also   constrained external factors like availability machinery, seeds,   labor. also noted threshold temperature increases,   likelihood air temperature occurring night, even middle   summer, also increases. Consequently, threshold set high,   unrealistically short growing season may predicted. example, calling   get_growing_season_climate(weather$'2005', 15) returns two-day   growing season (days 183--184) temperatures late night   day 183 early morning day 184 dip 15 degrees C. Thus, logic encoded oversimplification several ways.   likely appropriate many situations, tailored approaches   required.","code":""},{"path":"/reference/get_growing_season_climate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Truncate weather data to one growing season — get_growing_season_climate","text":"copy climate data frame truncated growing season.","code":""},{"path":"/reference/lightME.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulates the light macro environment — lightME","title":"Simulates the light macro environment — lightME","text":"Simulates light macro environment based latitude, day year.     coefficients can adjusted. Note: type special-purpose     function now deprecated, lightME included BioCro     namespace. reason, must accessed via BioCro:::lightME.","code":""},{"path":"/reference/lightME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulates the light macro environment — lightME","text":"","code":"lightME(lat = 40, DOY = 190, t.d = 12, t.sn = 12, atm.P = 1e+05, alpha = 0.85)"},{"path":"/reference/lightME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulates the light macro environment — lightME","text":"lat latitude, default 40 (Urbana, IL, U.S.). DOY day year ([1, 365]), default 190. t.d time day hours ([0, 23]), default 12. t.sn time solar noon, default 12. atm.P atmospheric pressure, default 1e5 (kPa). alpha atmospheric transmittance, default 0.85.","code":""},{"path":"/reference/lightME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulates the light macro environment — lightME","text":"list structure components:  \".dir\"Direct radiation (micromoles m^-2 s-1) \".diff\"Indirect (diffuse) radiation (micromoles m^-2 s-1) \"cos.th\"cosine \\(\\theta\\), solar zenith angle. \"propIdir\"proportion direct radiation. \"propIdiff\"proportion indirect (diffuse) radiation.","code":""},{"path":"/reference/lightME.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulates the light macro environment — lightME","text":"equations used can found     http://www.life.illinois.edu/plantbio/wimovac/newpage9.htm     original source Monteith, 1991.","code":""},{"path":"/reference/lightME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulates the light macro environment — lightME","text":"","code":"## Direct and diffuse radiation for DOY 190 and hours 0 to 23  res <- BioCro:::lightME(t.d=0:23)  lattice::xyplot(   I.dir + I.diff ~ 0:23,   data = res,   type = 'o',   xlab = 'hour',   ylab = 'Irradiance' )   lattice::xyplot(   propIdir + propIdiff ~ 0:23,   data = res,   type='o',   xlab='hour',   ylab='Irradiance proportion' )   plot(acos(BioCro:::lightME(lat = 42, t.d = 0:23)$cos.th) * 180 / pi)"},{"path":"/reference/miscanthus_x_giganteus.html","id":null,"dir":"Reference","previous_headings":"","what":"Miscanthus model definition — miscanthus_x_giganteus","title":"Miscanthus model definition — miscanthus_x_giganteus","text":"Initial values, parameters, direct modules, differential modules,   differential equation solver can used run   Miscanthus x giganteus growth simulations Champaign, Illinois   locations. represent Miscanthus growth Champaign, IL, values must   paired Champaign weather data (cmi_weather_data).   parameters already include clay_loam values   soil_parameters dataset, appropriate soil type   Champaign. specifications, values photosynthetic parameters,   remain location; others, latitude longitude,   need change simulating crop growth different locations. Care   must taken understand input quantity attempting run   simulations places cultivars.","code":""},{"path":"/reference/miscanthus_x_giganteus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Miscanthus model definition — miscanthus_x_giganteus","text":"","code":"miscanthus_x_giganteus"},{"path":"/reference/miscanthus_x_giganteus.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Miscanthus model definition — miscanthus_x_giganteus","text":"list 5 named elements suitable passing   run_biocro, described help page   crop_model_definitions.","code":""},{"path":"/reference/miscanthus_x_giganteus.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Miscanthus model definition — miscanthus_x_giganteus","text":"model originally described Miguez et al. (2009)   [doi:10.1111/j.1757-1707.2009.01019.x ] Miguez et al. (2012)   [doi:10.1111/j.1757-1707.2011.01150.x ]. Since original parameterization,   behavior several core modules changed bugs   identified fixed, model likely needs reparameterized   can used realistic simulations.","code":""},{"path":[]},{"path":"/reference/module_case_files.html","id":null,"dir":"Reference","previous_headings":"","what":"Define and modify BioCro module test case files — module_case_files","title":"Define and modify BioCro module test case files — module_case_files","text":"Test cases testing modules can stored files. functions   provide ways create update files. initialize_csv helps define test cases module testing   initializing csv file one module based either set   default input values user-supplied ones. add_csv_row helps define test cases module testing adding one   test case module's csv file based user-supplied inputs   description. update_csv_cases helps define cases module testing updating   expected output values case stored module's csv file.","code":""},{"path":"/reference/module_case_files.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define and modify BioCro module test case files — module_case_files","text":"","code":"initialize_csv(     module_name,     directory,     nonstandard_inputs = list(),     description = \"automatically-generated test case\",     overwrite = FALSE   )    add_csv_row(module_name, directory, inputs, description)    update_csv_cases(module_name, directory)"},{"path":"/reference/module_case_files.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define and modify BioCro module test case files — module_case_files","text":"module_name string specifying one BioCro module, formatted like     library_name:local_module_name, library_name name     library contains module local name     local_module_name; fully-qualified module names can formed     manually module_paste. directory directory module test case files stored, e.g.     file.path('tests', 'module_test_cases'). inputs list module inputs, .e., list named numeric elements     corresponding module's input quantities. description string describing test case, e.g. \"temp tbase\".     description succinct contain newline characters. nonstandard_inputs optional list input quantities whose values override default     value 1.0; see inputs entry . overwrite logical value indicating whether existing file overwritten.","code":""},{"path":"/reference/module_case_files.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define and modify BioCro module test case files — module_case_files","text":"Module test case files form critical component BioCro's regression   testing system. details, see help page   module_testing. initialize_csv function evaluate module set input   quantities store results test case csv file. Typically,   optional arguments can omitted. However, modules produce   errors inputs set 1.0. case, necessary   supply nonstandard inputs (possibly) alternate case description. add_csv_row function evaluate module set input   quantities, define test case resulting outputs description,   add module's corresponding csv file. csv   file exists, one initialized new case. update_csv_cases function evaluate module input   values specified csv case file update stored values   corresponding outputs. output columns present file   added automatically filled correct values. Although output   columns optional, description column must exist csv   file. module test fails update_csv_cases used update test,   care taken ensure new outputs sensible.   function used blindly ensure tests pass, since test   failure may indicate real problem module. Note update_csv_cases can used batch-initialize test cases.   , manually create test case csv file proper name   includes columns inputs description; now, calling   update_csv_cases automatically fill outputs case.   method, care must taken manually specifying values   description column; descriptions must double quoted,   contain internal double quotes, quotes must doubled. Generally   safest simply avoid double quotes descriptions. (See qmethod   help file write.csv details quoting.)","code":""},{"path":"/reference/module_case_files.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define and modify BioCro module test case files — module_case_files","text":"message indicating whether file created, overwritten, written.","code":""},{"path":[]},{"path":"/reference/module_case_files.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define and modify BioCro module test case files — module_case_files","text":"","code":"# First, we will initialize a test case file for the 'BioCro' library's # 'thermal_time_linear' module, which will be saved in the current directory as # 'BioCro_thermal_time_linear.csv'. Then, we will add a new case to the file. # Finally, we will update the file. Note that the call to `update_csv_cases` # will not actually modify the file unless it is manually edited beforehand to # change an input or output value.  if (FALSE) {  initialize_csv(   'BioCro:thermal_time_linear',   '.',   nonstandard_inputs = list(temp = -1),   overwrite = TRUE )  add_csv_row(   'BioCro:thermal_time_linear',   '.',   list(time = 101, sowing_time = 100, tbase = 20, temp = 44),   'temp above tbase' )  update_csv_cases('BioCro:thermal_time_linear', '.') }"},{"path":"/reference/module_creators.html","id":null,"dir":"Reference","previous_headings":"","what":"Create instances of modules — module_creators","title":"Create instances of modules — module_creators","text":"Creates pointers module wrapper objects","code":""},{"path":"/reference/module_creators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create instances of modules — module_creators","text":"","code":"module_creators(module_names)"},{"path":"/reference/module_creators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create instances of modules — module_creators","text":"module_names vector module names","code":""},{"path":"/reference/module_creators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create instances of modules — module_creators","text":"function used internally several BioCro functions,   purpose create instances module wrapper pointers using BioCro's   module library return pointers wrappers. turn, module wrappers   can used obtain information module's inputs, outputs,   properties, can also used create module instance. See   Also section contains list functions directly rely   module_creators. Although description externalptr objects sparse,   briefly mentioned R documentation: externalptr-class. function used directly, module library package   must version. reasons, function exported   package namespace can accessed using package name via   ::: operator.","code":""},{"path":"/reference/module_creators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create instances of modules — module_creators","text":"vector R externalptr objects point  module_creator C++ object","code":""},{"path":[]},{"path":"/reference/module_creators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create instances of modules — module_creators","text":"","code":"# Example: creating a vector of pointers to several module wrappers representing # three options for thermal time calculations module_pointers <- BioCro:::module_creators(c(   'thermal_time_linear',   'thermal_time_bilinear',   'thermal_time_trilinear' ))"},{"path":"/reference/module_paste.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepend library name to module names — module_paste","title":"Prepend library name to module names — module_paste","text":"Prepends library name set module names create   suitably-formatted set fully-qualified module names can passed   run_biocro BioCro functions.","code":""},{"path":"/reference/module_paste.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepend library name to module names — module_paste","text":"","code":"module_paste(lib_name, local_module_names)"},{"path":"/reference/module_paste.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepend library name to module names — module_paste","text":"lib_name string specifying module library name. local_module_names vector list module name strings.","code":""},{"path":"/reference/module_paste.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepend library name to module names — module_paste","text":"module_paste convenience function specifying multiple modules   library; prepends library name module name,   preserving names class local_module_names. Note simple call paste0(lib_name, ':', local_module_names)   produce similar output two important differences: (1)   paste0 preserve names local_module_names   named elements (2) paste0 always return character   vector, even local_module_names list.","code":""},{"path":"/reference/module_paste.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepend library name to module names — module_paste","text":"vector list fully-qualified module name strings formatted like  lib_name:local_module_name.","code":""},{"path":[]},{"path":"/reference/module_paste.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepend library name to module names — module_paste","text":"","code":"# Example: Specifying several modules from the `BioCro` module library. modules <- module_paste(   'BioCro',   list('total_biomass', canopy_photosynthesis = 'c3_canopy') )  # Compare to the output from `paste0` modules2 <- paste0(   'BioCro',   ':',   list('total_biomass', canopy_photosynthesis = 'c3_canopy') )  str(modules) #> List of 2 #>  $                      : chr \"BioCro:total_biomass\" #>  $ canopy_photosynthesis: chr \"BioCro:c3_canopy\" str(modules2) #>  chr [1:2] \"BioCro:total_biomass\" \"BioCro:c3_canopy\""},{"path":"/reference/module_testing.html","id":null,"dir":"Reference","previous_headings":"","what":"The BioCro module testing system — module_testing","title":"The BioCro module testing system — module_testing","text":"BioCro provides several functions defining, modifying, running module   test cases. functions together allow module developers easily create   regression tests ensure modules continue function correctly.","code":""},{"path":"/reference/module_testing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The BioCro module testing system — module_testing","text":"Together, test_module_library, test_module,   case, cases_from_csv,   initialize_csv, add_csv_row,   update_csv_cases form simple convenient system   defining running module test cases. tests form critical component   BioCro's regression testing system, test cases defined   BioCro modules BioCro module libraries. functions   required order use BioCro package, critical   understand creating modifying modules. module test case consists set module inputs, set module   outputs, short description case. run test, inputs   passed module, calculated outputs compared   expected ones. outputs match, test passed; otherwise, fails.   operation handled test_module function. simple --fly testing, possible define test case using   case function run using test_module.   However, robust method available facilitate regression testing,   module test cases stored suitably-formatted csv files,   allowing multiple test cases defined module easily checked   afterwards. test case files module module library stored   single directory, test cases can checked one call   test_module_library. system, test cases module fully-qualified name   module_name must stored module_name.csv,   colon module name replaced underscore;   example, module named BioCro:total_biomass associated   BioCro_total_biomass.csv. first row test case file must   quantity types (input output), second row must   quantity names, remaining rows must specify input quantity values   along expected output values produce. must also   description column (description first row)   containing short descriptions test cases. formatting requirements   automatically satisfied test case file produced   initialize_csv modified add_csv_row   update_csv_cases. files can read R using   cases_from_csv, resulting case objects can passed   test_module. Although possible, directly editing case files recommended   since initialize_csv, add_csv_row,   update_csv_cases easier use. several exceptions   suggestion: (1) case must deleted, (2) module input   must added removed, (3) initialization test file,   user may wish batch-initialize using update_csv_cases   (see documentation explanation batch-initialization). Case files can easily viewed using Excel spreadsheet viewers,   also nicely formatted viewed GitHub website   repository. Examples module test case files can found   tests/module_test_cases directory, code uses   testthat package automatically run defined   test cases standard BioCro module library via   test_module_library can found   tests/testthat/test.Modules.R file.","code":""},{"path":[]},{"path":"/reference/modules.html","id":null,"dir":"Reference","previous_headings":"","what":"BioCro module functions — modules","title":"BioCro module functions — modules","text":"BioCro modules named sets equations, module available   BioCro module library. module identified   fully-qualified name   includes name library local name within library.   functions provide ways access information modules   calculate output values sets input values. module_info returns essential information BioCro module. quantity_list_from_names initializes list named numeric elements   set names. evaluate_module runs BioCro module using list input quantity   values. module_response_curve runs BioCro module repeatedly different   input quantity values produce response curve.","code":""},{"path":"/reference/modules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BioCro module functions — modules","text":"","code":"module_info(module_name, verbose = TRUE)    quantity_list_from_names(quantity_names)    evaluate_module(module_name, input_quantities)    module_response_curve(module_name, fixed_quantities, varying_quantities)"},{"path":"/reference/modules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BioCro module functions — modules","text":"module_name string specifying one BioCro module, formatted like     library_name:local_module_name, library_name name     library contains module local name     local_module_name; fully-qualified module names can formed     manually module_paste. verbose boolean indicating whether print information R console. input_quantities list named numeric elements representing input quantities required     module; extraneous quantities ignored module. quantity_names vector strings. fixed_quantities list named numeric elements representing input quantities required     module whose values considered constant;     extraneous quantities ignored module. varying_quantities data frame column represents input quantity required     module whose value varies across response curve.","code":""},{"path":"/reference/modules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BioCro module functions — modules","text":"providing avenues retrieving information module evaluating   module's equations, module_info evaluate_module   functions form main interface individual BioCro modules within R.   quantity_list_from_names function convenience function   preparing suitable quantity lists pass evaluate_module. module_response_curve function provides convenient way   calculate module response curve. , user must specify module   use, values fixed input quantities (input_quantities),   sequence values quantities vary across response curve   (varying_quantities). returned data frame includes   information required reproduce curve: full-qualified   module name, inputs (including ones constant values),   outputs. Note: one quantity q input output   module, input value stored q column returned   data frame output value stored q.1 column;   renaming performed automatically make.unique function.","code":""},{"path":"/reference/modules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BioCro module functions — modules","text":"module_info invisible list several named elements containing     essential information module: module_name: module's (-fully-qualified) name inputs: character vector module's inputs outputs: character vector module's outputs type: module's type represented string (either             'differential' 'direct') euler_requirement: Indicates whether module requires             fixed-step Euler ODE solver used BioCro simulation creation_error_message: Describes errors occurred             creating instance module  quantity_list_from_names list named numeric elements, names set     quantity_names value set 1. evaluate_module list named numeric elements representing values module's     outputs calculated input_quantities according     module's equations. module_response_curve data frame first column fully-qualified name     module produced response curve remaining columns     module's input output quantities. row corresponds row     varying_quantities.","code":""},{"path":[]},{"path":"/reference/modules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BioCro module functions — modules","text":"","code":"# Example 1: printing information about the 'BioCro' module library's # 'c3_assimilation' module to the R console module_info('BioCro:c3_assimilation') #>  #>  #> Module name: #>   c3_assimilation #>  #> Module input quantities: #>   Qabs #>   Tleaf #>   temp #>   rh #>   vmax1 #>   jmax #>   tpu_rate_max #>   Rd #>   b0 #>   b1 #>   Gs_min #>   Catm #>   atmospheric_pressure #>   O2 #>   theta #>   StomataWS #>   electrons_per_carboxylation #>   electrons_per_oxygenation #>   beta_PSII #>   gbw #>  #> Module output quantities: #>   Assim #>   Gs #>   Cs #>   RHs #>   Ci #>   GrossAssim #>   Assim_conductance #>   Rp #>   iterations #>  #> Module type (differential or direct): #>   direct #>  #> Requires a fixed step size Euler ode_solver: #>   no #>   # Example 2: getting the inputs to the 'BioCro' module library's # 'thermal_time_linear' module, generating a default input list, and using it to # run the module info <- module_info('BioCro:thermal_time_linear', verbose = FALSE) inputs <- quantity_list_from_names(info$inputs) # All inputs will be set to 1 outputs <- evaluate_module('BioCro:thermal_time_linear', inputs)  # Example 3: calculating the temperature response of light saturated net # assimilation at several values of relative humidity in the absence of water # stress using the 'BioCro' module library's 'c3_assimilation' module and # the default soybean parameters. Here, the leaf temperature and humidity values # are independent of each other, so we use the `expand.grid` function to form a # data frame of all possible combinations of their values. Then we set the # ambient temperature equal to the leaf temperature. rc <- module_response_curve(   'BioCro:c3_assimilation',   within(soybean$parameters, {Qabs = 2000; StomataWS = 1; gbw = 1.2}),   within(     expand.grid(       Tleaf = seq(from = 0, to = 40, length.out = 201),       rh = c(0.2, 0.5, 0.8)     ),     {temp = Tleaf}   ) )  caption <- paste(   \"Response curves calculated with several RH\\nvalues and Q =\",   unique(rc$Qp),   \"micromol / m^2 / s\\nusing the\",   unique(rc$module_name),   \"module\" )  lattice::xyplot(   Assim ~ Tleaf,   group = rh,   data = rc,   auto = TRUE,   type = 'l',   main = caption )"},{"path":"/reference/obsBea.html","id":null,"dir":"Reference","previous_headings":"","what":"Miscanthus assimilation field data — obsBea","title":"Miscanthus assimilation field data — obsBea","text":"Assimilation Miscanthus measured Beale, Bint, Long 1996.      first column observed net assimilation rate (micromoles m^-2 s^-1).     second column observed quantum flux (micromoles m^-2 s^-1).     third column temperature (degrees Celsius). Relative humidity     reported thus assumed 0.7.","code":""},{"path":"/reference/obsBea.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Miscanthus assimilation field data — obsBea","text":"Data frame dimensions 27 4.","code":""},{"path":"/reference/obsBea.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Miscanthus assimilation field data — obsBea","text":"C. V. Beale, D. . Bint, S. P. Long. 1996. Leaf photosynthesis     C4-grass Miscanthus x giganteus, growing cool temperate climate     southern England. J. Exp. Bot. 47 (2): 267--273.","code":""},{"path":"/reference/obsBeaC.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete Miscanthus assimilation field data — obsBeaC","title":"Complete Miscanthus assimilation field data — obsBeaC","text":"Assimilation stomatal conductance Miscanthus measured Beale, Bint, Long     1996.  (Missing data also included.)  first column     date, second hour. Columns 3 4 assimilation     stomatal conductance respectively.","code":""},{"path":"/reference/obsBeaC.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Complete Miscanthus assimilation field data — obsBeaC","text":"Data frame dimensions 35 6.","code":""},{"path":"/reference/obsBeaC.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Complete Miscanthus assimilation field data — obsBeaC","text":"C. V. Beale, D. . Bint, S. P. Long. 1996. Leaf photosynthesis     C4-grass Miscanthus x giganteus, growing cool temperate climate     southern England. J. Exp. Bot. 47 (2): 267--273.","code":""},{"path":"/reference/obsBeaC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Complete Miscanthus assimilation field data — obsBeaC","text":"third column observed net assimilation rate (micromoles m^-2 s^-1). fifth column observed quantum flux (micromoles m^-2 s^-1). sixth column temperature (degrees Celsius).","code":""},{"path":"/reference/obsNaid.html","id":null,"dir":"Reference","previous_headings":"","what":"Miscanthus assimilation data — obsNaid","title":"Miscanthus assimilation data — obsNaid","text":"Assimilation Miscanthus measured Naidu et al. (2003). first     column observed net assimilation rate (micromoles m^-2 s^-1).     second column observed quantum flux (micromoles m^-2 s^-1).     third column temperature (degrees Celsius).     fourth column observed relative humidity proportion (e.g. 0.7).","code":""},{"path":"/reference/obsNaid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Miscanthus assimilation data — obsNaid","text":"Data frame dimensions 16 4.","code":""},{"path":"/reference/obsNaid.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Miscanthus assimilation data — obsNaid","text":"S. L. Naidu, S. P. Moose, . K. AL-Shoaibi, C. . Raines, S. P.     Long.  2003. Cold Tolerance C4 photosynthesis Miscanthus x giganteus:     Adaptation Amounts Sequence C4 Photosynthetic Enzymes.     Plant Physiol. 132 (3): 1688--1697.","code":""},{"path":"/reference/partial_application.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience Functions for Partial Application — partial_application","title":"Convenience Functions for Partial Application — partial_application","text":"Convenience functions using partial application BioCro","code":""},{"path":"/reference/partial_application.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience Functions for Partial Application — partial_application","text":"","code":"partial_run_biocro(     initial_values = list(),     parameters = list(),     drivers,     direct_module_names = list(),     differential_module_names = list(),     ode_solver = BioCro:::default_ode_solver,     arg_names,     verbose = FALSE )  partial_evaluate_module(module_name, input_quantities, arg_names)"},{"path":"/reference/partial_application.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convenience Functions for Partial Application — partial_application","text":"arg_names vector strings specifying input quantities whose values     fixed using partial application. initial_values Identical corresponding argument run_biocro. parameters Identical corresponding argument run_biocro. drivers Identical corresponding argument run_biocro. direct_module_names Identical corresponding argument run_biocro. differential_module_names Identical corresponding argument run_biocro. ode_solver Identical corresponding argument run_biocro. verbose Identical corresponding argument run_biocro. module_name Identical corresponding argument evaluate_module. input_quantities list named numeric elements representing input quantities required     module included arg_names; extraneous     quantities ignored module.","code":""},{"path":"/reference/partial_application.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convenience Functions for Partial Application — partial_application","text":"Partial application technique fixing input   arguments function, producing new function fewer inputs.   context BioCro, partial application can often useful varying   parameters, initial values, drivers performing optimization   sensitivity analysis. Optimizers (optim)   typically require function single input argument, partial   application tools provided help create functions. partial_run_biocro partial_evaluate_module accept   arguments \"regular\" counterparts (run_biocro   evaluate_module) addition arg_names,   specifies input quantities fixed. partial_run_biocro, element arg_names must   name quantity one initial_values,   parameters, drivers. partial_evaluate_module,   element arg_names must name one module's input   quantities. using one pre-defined crop growth models, may helpful   use command pass arguments partial_run_biocro;   see documentation crop_model_definitions   information.","code":""},{"path":"/reference/partial_application.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convenience Functions for Partial Application — partial_application","text":"partial_run_biocro function calls run_biocro inputs     (except specified arg_names) set values specified     original call partial_run_biocro. new function one     input (x), can vector list specifying values     quantities arg_names. x names, elements must     supplied order original arg_names.     x names, must identical elements     arg_names can order. Elements x corresponding     drivers must vectors length drivers;     can specified named element list sequential elements     vector without names. return value new function data frame     produced run_biocro. partial_evaluate_module function calls evaluate_module input     quantities (except specified arg_names) set values     specified original call partial_evaluate_module. new     function one input (x), can vector list specifying     values quantities arg_names. x names,     elements must supplied order original     arg_names. x names, must identical     elements arg_names can order. return value     new function list two elements (inputs     outputs), list named numeric elements     representing module's input output values. (Note differs     output evaluate_module, returns outputs.)","code":""},{"path":[]},{"path":"/reference/partial_application.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convenience Functions for Partial Application — partial_application","text":"","code":"# Specify weather data to use in these examples ex_weather <- get_growing_season_climate(weather$'2005')  # Example 1: varying the thermal time values at which senescence starts for # different organs in a simulation; here we set them to the following values # instead of the defaults: #  - seneLeaf: 2000 degrees C * day #  - seneStem: 2100 degrees C * day #  - seneRoot: 2200 degrees C * day #  - seneRhizome: 2300 degrees C * day senescence_simulation <- partial_run_biocro(   miscanthus_x_giganteus$initial_values,   miscanthus_x_giganteus$parameters,   ex_weather,   miscanthus_x_giganteus$direct_modules,   miscanthus_x_giganteus$differential_modules,   miscanthus_x_giganteus$ode_solver,   c('seneLeaf', 'seneStem', 'seneRoot', 'seneRhizome') ) senescence_result <- senescence_simulation(c(2000, 2100, 2200, 2300))  # Example 2: a crude method for simulating the effects of climate change; here # we increase the atmospheric CO2 concentration to 500 ppm and the temperature # by 2 degrees C relative to 2005 temperatures. The commands below that call # `temperature_simulation` all produce the same result. temperature_simulation <- partial_run_biocro(   miscanthus_x_giganteus$initial_values,   miscanthus_x_giganteus$parameters,   ex_weather,   miscanthus_x_giganteus$direct_modules,   miscanthus_x_giganteus$differential_modules,   miscanthus_x_giganteus$ode_solver,   c(\"Catm\", \"temp\") ) hot_result_1 <- temperature_simulation(c(500, ex_weather$temp + 2.0)) hot_result_2 <- temperature_simulation(list(Catm = 500, temp = ex_weather$temp + 2.0)) hot_result_3 <- temperature_simulation(list(temp = ex_weather$temp + 2.0, Catm = 500))  # Note that these commands will both produce errors: # hot_result_4 <- temperature_simulation(c(Catm = 500, temp = ex_weather$temp + 2.0)) # hot_result_5 <- temperature_simulation(stats::setNames( #   c(500, ex_weather$temp + 2.0), #   c(\"Catm\", rep(\"temp\", length(ex_weather$temp))) # ))  # Note that this command will produce a strange result where the first # temperature value will be incorrectly interpreted as a `Catm` value, and the # `Catm` value will be interpreted as the final temperature value. # hot_result_6 <- temperature_simulation(c(ex_weather$temp + 2.0, 500))  # Example 3: varying the base and air temperature inputs to the # 'thermal_time_linear' module from the 'BioCro' module library. The commands # below that call `thermal_time_rate` all produce the same result. thermal_time_rate <- partial_evaluate_module(   'BioCro:thermal_time_linear',   within(miscanthus_x_giganteus$parameters, {time = 1}),   c(\"temp\", \"tbase\") ) rate_result_1 <- thermal_time_rate(c(25, 10)) rate_result_2 <- thermal_time_rate(c(temp = 25, tbase = 10)) rate_result_3 <- thermal_time_rate(c(tbase = 10, temp = 25)) rate_result_4 <- thermal_time_rate(list(temp = 25, tbase = 10)) rate_result_5 <- thermal_time_rate(list(tbase = 10, temp = 25))"},{"path":"/reference/run_biocro.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Crop Growth with BioCro — run_biocro","title":"Simulate Crop Growth with BioCro — run_biocro","text":"Runs full crop growth simulation using BioCro framework","code":""},{"path":"/reference/run_biocro.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Crop Growth with BioCro — run_biocro","text":"","code":"run_biocro(     initial_values = list(),     parameters = list(),     drivers,     direct_module_names = list(),     differential_module_names = list(),     ode_solver = BioCro:::default_ode_solver,     verbose = FALSE )"},{"path":"/reference/run_biocro.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Crop Growth with BioCro — run_biocro","text":"initial_values list named quantities representing initial values     differential quantities, .e., quantities whose derivatives     calculated differential modules parameters list named quantities change time; must include     'timestep' parameter (see `drivers` info) drivers data frame quantities defined equally spaced time intervals.     time interval specified `parameters` quantity called     'timestep' units hours. drivers must include columns     either (1) 'time' (units days) (2) 'doy' 'hour'. direct_module_names character vector list fully-qualified names direct     modules use system; lists available modules can obtained via     get_all_modules function. differential_module_names character vector list fully-qualified names differential     modules use system; lists available modules can obtained via     get_all_modules function. ode_solver list specifying details numerical ODE solver. required     elements : type: string specifying name algorithm use;             list available options can obtained using             get_all_ode_solvers function. output_step_size: output step size. smaller 1,             equal 1.0 / N integer N. larger 1,             integer. adaptive_rel_error_tol: used set relative error             tolerance adaptive step size methods adaptive_abs_error_tol: used set absolute error             tolerance adaptive step size methods adaptive_max_steps: determines many times adaptive             step size method attempt find new step size             indicating failure  verbose logical variable indicating whether print dynamical system     validation information. (detailed startup information can obtained     validate_dynamical_system_inputs function.)","code":""},{"path":"/reference/run_biocro.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Crop Growth with BioCro — run_biocro","text":"run_biocro important function BioCro package.   input arguments function used define dynamical system   solve time evolution desired time period. details   function operates, see Lochocki et al. (2022)   [doi:10.1093/insilicoplants/diac003 ]. using one pre-defined crop growth models, may helpful   use command pass arguments run_biocro; see   documentation crop_model_definitions information.","code":""},{"path":"/reference/run_biocro.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Crop Growth with BioCro — run_biocro","text":"data frame column represents one quantities included   simulation (exception parameters, since values   guaranteed change time) row represents time point","code":""},{"path":[]},{"path":"/reference/run_biocro.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Crop Growth with BioCro — run_biocro","text":"","code":"# Example: running a miscanthus simulation using weather data from 2005 result <- run_biocro(   miscanthus_x_giganteus$initial_values,   miscanthus_x_giganteus$parameters,   get_growing_season_climate(weather$'2005'),   miscanthus_x_giganteus$direct_modules,   miscanthus_x_giganteus$differential_modules,   miscanthus_x_giganteus$ode_solver )  lattice::xyplot(   Leaf + Stem + Root + Grain ~ TTc,   data=result,   type='l',   auto=TRUE )"},{"path":"/reference/soil_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Soil properties — soil_parameters","title":"Soil properties — soil_parameters","text":"collection soil property data.","code":""},{"path":"/reference/soil_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Soil properties — soil_parameters","text":"","code":"soil_parameters"},{"path":"/reference/soil_parameters.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Soil properties — soil_parameters","text":"list named elements, element represents hydraulic   properties one type soil. soil types defined following   USDA soil texture classification   scheme, 11 12 possible types included (\"silt\"   available). following names used indicate various soil types: sand loamy_sand sandy_loam loam silt_loam sandy_clay_loam clay_loam silty_clay_loam sandy_clay silty_clay clay soil type, following parameter values provided: soil_silt_content (dimensionless) soil_clay_content (dimensionless) soil_sand_content (dimensionless) soil_air_entry (J / kg) soil_b_coefficient (dimensionless) soil_saturated_conductivity (J * s / m^3) soil_saturation_capacity (dimensionless) soil_field_capacity (dimensionless) soil_wilting_point (dimensionless) soil_bulk_density (Mg / m^3)","code":""},{"path":"/reference/soil_parameters.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Soil properties — soil_parameters","text":"soil property values based Table 9.1 Campbell Norman's   textbook Introduction Environmental Biophysics (1998). Bulk   density values taken function getsoilprop.c Melanie   (Colorado). bulk density sand getsoilprop.c 0,   sensible, value 1.60 Mg / m^3 used instead. wilting point value 0.21 (corrected 0.32) silty clay loam   based list book corrections available   Brian Hornbuckle's teaching website   using Wayback Machine, since seem available   current site.","code":""},{"path":"/reference/soybean.html","id":null,"dir":"Reference","previous_headings":"","what":"Soybean-BioCro model definition — soybean","title":"Soybean-BioCro model definition — soybean","text":"Initial values, parameters, direct modules, differential modules,   differential equation solver can used run soybean growth   simulations Champaign, Illinois locations. Along soybean   circadian clock specifications (soybean_clock), values   define soybean growth model Matthews et al. (2022)   [doi:10.1093/insilicoplants/diab032 ], commonly referred   Soybean-BioCro. represent soybean growth Champaign, IL, values must paired   Champaign weather data (cmi_soybean_weather_data).   weather data includes output soybean circadian clock model   (soybean_clock), clock components need   included running soybean growth simulation using weather data.   parameters already include clay_loam values   soil_parameters dataset, appropriate soil type   Champaign. specifications, values photosynthetic parameters,   remain location; others, latitude longitude,   need change simulating crop growth different locations. Care   must taken understand input quantity attempting run   simulations places cultivars.","code":""},{"path":"/reference/soybean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Soybean-BioCro model definition — soybean","text":"","code":"soybean"},{"path":"/reference/soybean.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Soybean-BioCro model definition — soybean","text":"list 5 named elements suitable passing   run_biocro, described help page   crop_model_definitions.","code":""},{"path":"/reference/soybean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Soybean-BioCro model definition — soybean","text":"improvements made BioCro modules, behavior changes,   soybean model parameters must updated. Following significant module   updates, reparameterization performed using method data   used Matthews et al. (2022). following summary   reparameterizations occurred since original publication   Soybean-BioCro model: 2023-06-18: Several modules updated, value     atmospheric transmittance changed 0.85 0.6 based     Campbell Norman, Introduction Environmental Biophysics,     2nd Edition, Pg 173. Due changes, reparameterization     following required: alphaLeaf, alphaRoot,     alphaStem, alphaShell, betaLeaf, betaRoot,     betaStem, betaShell, rateSeneLeaf, rateSeneStem,     alphaSeneLeaf, betaSeneLeaf, alphaSeneStem,     betaSeneStem. 2023-03-15: Several modules updated.     significant changes (1)     BioCro:no_leaf_resp_neg_assim_partitioning_growth_calculator now     reduces leaf growth rate response water stress (2)     partitioning modules now include new tissue type (shell). new     component allows us distinguish components soybean pod,     shell represents pericarp grain represents     seed. distinction found important accurately     predicting seed biomass, important agricultural settings     entire pod mass, since pericarp included typical     yield measurements. Due changes, reparameterization     following required: alphaLeaf, alphaRoot,     alphaStem, alphaShell, betaLeaf, betaRoot,     betaStem, betaShell, rateSeneLeaf, rateSeneStem,     alphaSeneLeaf, betaSeneLeaf, alphaSeneStem,     betaSeneStem. also necessary add new direct module     model definition: BioCro:leaf_water_stress_exponential. module     calculates fractional reduction leaf growth rate due water stress. Whenever reparameterization made, list updated,   vignettes using soybean model checked see axis limits,   etc., need change.","code":""},{"path":"/reference/soybean.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Soybean-BioCro model definition — soybean","text":"model described detail Matthews et al. (2022)   [doi:10.1093/insilicoplants/diab032 ]. make notes   components: model, ODE solver type     boost_rosenbrock auto (defaults     boost_rosenbrock fixed step size Euler ODE solver     required, case) since integration fail unless     tolerances stringent (e.g., output_step_size = 0.01,     adaptive_rel_error_tol = 1e-9, adaptive_abs_error_tol = 1e-9). initial total seed mass per land area, use following     equation: Number seeds per meter * weight per seed / row spacing.     number seeds per meter 20 row spacing 0.38 m,     reported Morgan et al. (2004) [doi:10.1104/pp.104.043968 ].     weight per seed based average .12 .18 grams, reported     Feedipedia. Thus,     initial biomass     (20 seeds / m) * (0.15 g / seed) / (0.38 m) = 7.89 g / m^2,     equivalent 0.0789 Mg / ha typical BioCro units. Since     model seed component, value used determine     initial Leaf, Stem, Root biomass, assuming 80%     leaf, 10% stem, 10% root. historical reasons, seed tissue model called     Grain. entire pod biomass can calculated adding     Grain Shell biomass. historical reasons, model includes Rhizome tissue.     Soybean rhizome, rhizome model grow     senesce. achieve , kRhizome_emr     rateSeneRhizome parameters must set 0. also necessary     specify values several quantities alphaSeneRhizome,     betaSeneRhizome, initial rhizome mass, although actual     values quantities effect simulation output. historical reasons, modules define Soybean-BioCro     require input quantities actually used calculations;     \"extraneous\" parameters identified data/soybean.R. sowing_time input     soybean_development_rate_calculator module set 0     Soybean-BioCro uses weather data set sowing time. words,     weather data truncated begins sowing date.","code":""},{"path":[]},{"path":"/reference/soybean_clock.html","id":null,"dir":"Reference","previous_headings":"","what":"Soybean-BioCro circadian clock model definition — soybean_clock","title":"Soybean-BioCro circadian clock model definition — soybean_clock","text":"Initial values, parameters, direct modules, differential modules,   differential equation solver can used run soybean circadian clock   simulations Champaign, Illinois locations. Along soybean   growth specifications (soybean), values define soybean   growth model Matthews et al. (2022)   [doi:10.1093/insilicoplants/diab032 ], commonly referred   Soybean-BioCro. represent soybean circadian clock Champaign, Illinois, values   must paired weather data cmi_weather_data.","code":""},{"path":"/reference/soybean_clock.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Soybean-BioCro circadian clock model definition — soybean_clock","text":"","code":"soybean_clock"},{"path":"/reference/soybean_clock.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Soybean-BioCro circadian clock model definition — soybean_clock","text":"list 5 named elements suitable passing   run_biocro, described help page   crop_model_definitions.","code":""},{"path":"/reference/soybean_clock.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Soybean-BioCro circadian clock model definition — soybean_clock","text":"model described detail Matthews et al. (2022)   [doi:10.1093/insilicoplants/diab032 ] Lochocki & McGrath (2021)   [doi:10.1093/insilicoplants/diab016 ]. , use initial phases dawn dusk oscillators 200.0   80.0 radians, respectively. values optimized   simulations beginning midnight January 1, require minimal   time transient signals die . values determined   running simulation one year starting January 1, recording   oscillator states end December 31.","code":""},{"path":[]},{"path":"/reference/system_derivatives.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Derivatives for Differential Quantities — system_derivatives","title":"Calculate Derivatives for Differential Quantities — system_derivatives","text":"Solving BioCro model using one R's available differential equation   solvers","code":""},{"path":"/reference/system_derivatives.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Derivatives for Differential Quantities — system_derivatives","text":"","code":"system_derivatives(   parameters = list(),   drivers,   direct_module_names = list(),   differential_module_names = list() )"},{"path":"/reference/system_derivatives.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Derivatives for Differential Quantities — system_derivatives","text":"parameters Identical corresponding argument run_biocro. drivers Identical corresponding argument run_biocro. direct_module_names Identical corresponding argument run_biocro. differential_module_names Identical corresponding argument run_biocro.","code":""},{"path":"/reference/system_derivatives.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Derivatives for Differential Quantities — system_derivatives","text":"system_derivatives accepts input arguments  run_biocro exceptions ode_solver  initial_values; function intended passed ODE solver   R, solve system's time dependence diffferential   quantities evolve initial values, ode_solver  initial_values required . return value system_derivatives function three inputs   (t, differential_quantities, parms) returns   derivatives differential quantities dynamical system   determined original inputs (parameters, drivers,  direct_module_names,  differential_module_names). function signature requirements inputs set  LSODES function deSolve package. t input   single time value differential_quantities input   vector names differential quantities defined   modules. parms required LSODES, use   anything. function can passed LSODES alternative integration   method, rather using one BioCro's built-solvers. using one pre-defined crop growth models, may helpful   use command pass arguments system_derivatives;   see documentation crop_model_definitions   information.","code":""},{"path":[]},{"path":"/reference/system_derivatives.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Derivatives for Differential Quantities — system_derivatives","text":"","code":"# Example 1: calculating a single derivative using a soybean model  soybean_system <- system_derivatives(   soybean$parameters,   soybean_weather$'2002',   soybean$direct_modules,   soybean$differential_modules )  derivs <- soybean_system(0, unlist(soybean$initial_values), NULL)  # Example 2: a simple oscillator with only one module (requires deSolve)  if (FALSE) {  times = seq(0, 5, length=100)  oscillator_system_derivatives <- system_derivatives(   list(     timestep = 1,     mass = 1,     spring_constant = 1   ),   data.frame(time=times),   c(),   'BioCro:harmonic_oscillator' )  result <- as.data.frame(deSolve::lsodes(   c(position=0, velocity=1),   times,   oscillator_system_derivatives ))  lattice::xyplot(   position + velocity ~ time,   type='l',   auto=TRUE,   data=result ) }  # Example 3: solving 500 hours of a soybean simulation. This requires the # deSolve package and will run very slow compared to a regular call to # `run_biocro`.  if (FALSE) {  soybean_system <- system_derivatives(   soybean$parameters,   soybean_weather$'2002',   soybean$direct_modules,   soybean$differential_modules )  times = seq(from=0, to=500, by=1)  result <- as.data.frame(deSolve::lsodes(unlist(soybean$initial_values), times, soybean_system))  lattice::xyplot(Leaf + Stem ~ time, type='l', auto=TRUE, data=result) }"},{"path":"/reference/test_module.html","id":null,"dir":"Reference","previous_headings":"","what":"Run BioCro module test cases — test_module","title":"Run BioCro module test cases — test_module","text":"Modules can tested using test cases, sets known outputs   correspond particular inputs. functions provide ways create   test cases test modules. test_module runs one test case module, returning error message   output match expected value. case helps define test cases module testing combining   required elements list correct names required   test_module. cases_from_csv helps define test cases module testing creating   list test cases csv file.","code":""},{"path":"/reference/test_module.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run BioCro module test cases — test_module","text":"","code":"test_module(module_name, case_to_test)    case(inputs, expected_outputs, description)    cases_from_csv(module_name, directory)"},{"path":"/reference/test_module.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run BioCro module test cases — test_module","text":"module_name string specifying one BioCro module, formatted like     library_name:local_module_name, library_name name     library contains module local name     local_module_name; fully-qualified module names can formed     manually module_paste. case_to_test list three named elements describe module test case: inputs: list module inputs, .e., list named             numeric elements corresponding module's input quantities. expected_outputs: list expected module outputs, .e.,             list named numeric elements corresponding expected values             module's output quantities. description: string describing test case, e.g.             \"temp tbase\". description succinct             contain newline characters.  inputs See corresponding entry test_case . expected_outputs See corresponding entry test_case . description See corresponding entry test_case . directory directory module test case files stored, e.g.     file.path('tests', 'module_test_cases')","code":""},{"path":"/reference/test_module.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run BioCro module test cases — test_module","text":"test_module function forms basis BioCro module testing   system. (See module_testing information.) functions   case cases_from_csv complementary test_module   help pass suitably-formatted test cases test_module.","code":""},{"path":"/reference/test_module.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run BioCro module test cases — test_module","text":"test_module test passes, empty string; otherwise, informative message     went wrong. case list three named elements (inputs, expected_outputs,     description) formed input arguments. cases_from_csv list test cases created case function     suitable passing test_module function.","code":""},{"path":[]},{"path":"/reference/test_module.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run BioCro module test cases — test_module","text":"","code":"# Example 1: Defining an individual test case for the 'BioCro' module library's # 'thermal_time_linear' module and running the test. This test will pass, so the # return value will be an empty string: `character(0)` test_module(   'BioCro:thermal_time_linear',   case(     list(time = 101, sowing_time = 100, tbase = 20, temp = 44),     list(TTc = 1.0),     'temp above tbase'   ) ) #> character(0)  # Example 2: Defining an individual test case for the 'BioCro' module library's # 'thermal_time_linear' module and running the test. This test will fail, so the # return value will be a message indicating the failure. test_module(   'BioCro:thermal_time_linear',   case(     list(time = 101, sowing_time = 100, tbase = 20, temp = 44),     list(TTc = 2.0),     'temp above tbase'   ) ) #> [1] \"Module `BioCro:thermal_time_linear` test case `temp above tbase`: calculated outputs do not match expected outputs\"  # Example 3: Loading a set of test cases from a file and running one of them. # Note: here we use the `initialize_csv` function first to ensure that there is # a properly defined test file in the current directory.  if (FALSE) {  module_name <- 'BioCro:thermal_time_linear' initialize_csv(module_name, '.') cases <- cases_from_csv(module_name, '.') test_module(module_name, cases[[1]]) }"},{"path":"/reference/test_module_library.html","id":null,"dir":"Reference","previous_headings":"","what":"Run module test cases for an entire BioCro module library — test_module_library","title":"Run module test cases for an entire BioCro module library — test_module_library","text":"Modules can tested using test cases, sets known outputs   correspond particular inputs. test_module_library function   provides way run test cases modules BioCro module   library.","code":""},{"path":"/reference/test_module_library.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run module test cases for an entire BioCro module library — test_module_library","text":"","code":"test_module_library(library_name, directory, modules_to_skip = c())"},{"path":"/reference/test_module_library.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run module test cases for an entire BioCro module library — test_module_library","text":"library_name name BioCro module library. directory directory module test case files stored, e.g.     file.path('tests', 'module_test_cases') modules_to_skip vector local module name strings indicating modules     library tested. feature used sparingly,     since legitimate reasons skip module test.","code":""},{"path":"/reference/test_module_library.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run module test cases for an entire BioCro module library — test_module_library","text":"module specified library, test_module_library loads   stored test cases specified directory runs test case,   storing information test failures issues may occur.   problems detected, test_module_library throws error   message describing issues. example function can used along   testthat package, see   tests/testthat/test.Modules.R.","code":""},{"path":[]},{"path":"/reference/willow.html","id":null,"dir":"Reference","previous_headings":"","what":"Willow model definition — willow","title":"Willow model definition — willow","text":"Initial values, parameters, direct modules, differential modules,   differential equation solver can used run willow growth   simulations Champaign, Illinois locations. represent willow growth Champaign, IL, values must paired   Champaign weather data (cmi_weather_data). parameters   already include clay_loam values   soil_parameters dataset, appropriate soil type   Champaign. specifications, values photosynthetic parameters,   remain location; others, latitude longitude,   need change simulating crop growth different locations. Care   must taken understand input quantity attempting run   simulations places cultivars.","code":""},{"path":"/reference/willow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Willow model definition — willow","text":"","code":"willow"},{"path":"/reference/willow.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Willow model definition — willow","text":"list 5 named elements suitable passing   run_biocro, described help page   crop_model_definitions.","code":""},{"path":"/reference/willow.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Willow model definition — willow","text":"model originally described Wang et al. (2015)   [doi:10.1111/pce.12556 ]. Since original parameterization, behavior   several core modules changed bugs identified   fixed, model likely needs reparameterized can used   realistic simulations.","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"major-changes-3-0-0","dir":"Changelog","previous_headings":"","what":"MAJOR CHANGES","title":"CHANGES IN BioCro VERSION 3.0.0","text":"version introduces concept distinct module libraries, allowing users develop modules private create collections related modules. associated syntax change, modules must now specified using fully-qualified names include module library name local name module within library; example, module previously known thermal_time_linear must now referred BioCro:thermal_time_linear. R package representing BioCro module library must now four non-exported functions related accessing modules: get_all_modules, get_all_quantities, module_creators, framework_version. fully-qualified module name library_name:local_module_name passed function module_info, internal call library_name:::module_creators(module_name) made retrieve pointer module. Hence, library_name must module library package name. required part method passing C objects module library core BioCro framework via R; full details discussed . code src directory reorganized reflect division framework code, module code, “R--C” code discussed manuscript; now, src/framework contains core C++ code, src/module_library contains module code, “R--C” code can found directly src. C++ framework code src/framework moved separate repository licensed GNU LGPL; included BioCro R package repository Git submodule. allows us use permissive license BioCro R package still protecting code assembles solves models. Associated change, BioCro R package now licensed MIT license. See LICENSE.note details.","code":""},{"path":"/news/index.html","id":"minor-changes-3-0-0","dir":"Changelog","previous_headings":"","what":"MINOR CHANGES","title":"CHANGES IN BioCro VERSION 3.0.0","text":"soil_type_selector module removed replaced data object called soil_parameters. crop models previously set soil_type_indicator 6 choose soil parameter values, parameter replaced values soil_parameters$clay_loam. Crop model definitions now stored single lists rather multiple objects; example, soybean_parameters soybean_initial_values now stored two elements soybean list: soybean$parameters soybean$initial_values. function returned partial_run_biocro can now properly respond vectors lists named elements. Module testing functions added package namespace. Many small improvements made documentation module code src/module_library; changes numerous list .","code":""},{"path":"/news/index.html","id":"bug-fixes-3-0-0","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN BioCro VERSION 3.0.0","text":"elements arg_names input partial_run_biocro can now order; previously, required supplied order appear inputs partial_run_biocro, example, names initial values required come names parameters. arguments supplied wrong order, inputs function returned partial_run_biocro interpreted wrong order. bug sometimes caused last time point simulation contain NaN quantities fixed; related --bounds error accessing vector elements C++ function dynamical_system::update_drivers.","code":""},{"path":[]},{"path":"/news/index.html","id":"major-changes-2-0-0","dir":"Changelog","previous_headings":"","what":"MAJOR CHANGES","title":"CHANGES IN BioCro VERSION 2.0.0","text":"Make easier reuse modules species, C3 photosynthesis modules. Make easier swap related modules comparison, example, comparing Farquhar-von-Caemmerer-Berry model radiation use efficiency model. Simplify parameter optimization sensitivity analysis providing interface readily useable common optimizers similar functions. Practical Guide BioCro Quantitative Comparison Two Photosynthesis Models Introduction BioCro Want Add Models","code":""},{"path":"/news/index.html","id":"biocro-version-0951","dir":"Changelog","previous_headings":"","what":"BioCro VERSION 0.951","title":"BioCro VERSION 0.951","text":"last release original version BioCro, first described Miguez et al., 2009 updated years add crop models R functions. full change log version previous versions available document.","code":""}]
